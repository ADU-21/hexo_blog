{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/next/source/404.html","path":"404.html","modified":1,"renderable":1},{"_id":"source/images/default_avatar.jpg","path":"images/default_avatar.jpg","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"416bf7ae82f16f8838f85acced136854bb897573","modified":1467114555000},{"_id":"source/CNAME","hash":"b3c489f5f10324d8a05f806afaf4f42513d47982","modified":1467114555000},{"_id":"themes/next/.DS_Store","hash":"1339ddbd7b17481667e7e251c832393fb161a367","modified":1467114555000},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1467114555000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1467114555000},{"_id":"themes/next/.gitignore","hash":"efec790f5b7a0256763e1cc08f12c4f0aff509f6","modified":1467114555000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1467114555000},{"_id":"themes/next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1467114555000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1467114555000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1467114555000},{"_id":"themes/next/_config.yml","hash":"61fbfe0c913fc87ab2bd083a0ccf9b02d5948b72","modified":1467114555000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1467114555000},{"_id":"themes/next/bower.json","hash":"d7f8d4eb7c6ac1bb8d642112601005f93e3da49b","modified":1467114555000},{"_id":"themes/next/gulpfile.coffee","hash":"b3d53f36460119c741a98c0dc494b1c65d3ec943","modified":1467114555000},{"_id":"themes/next/package.json","hash":"bd016b54983b7e06a649ee915b2e13a60d47553e","modified":1467114555000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1467114555000},{"_id":"source/_posts/CI-CD.md","hash":"db144a2f1d792d001c7270c6c32ecb0d1800d513","modified":1467114555000},{"_id":"source/_posts/HTTP协议详解.md","hash":"5dd1766c81b6b6004ff318daf3748f8d47a137db","modified":1467114555000},{"_id":"source/_posts/RDBMS和NOSQL的技术差别.md","hash":"235d49b58f67df992356e754b054695eda65ea1b","modified":1467114555000},{"_id":"source/_posts/Systemd.md","hash":"644967f39c1d4a1aaa980b7d58a141d2f7af4642","modified":1467114555000},{"_id":"source/_posts/ThoughtWorks第一周学习总结.md","hash":"80ce81309ecaf06f4fc13088b5dc858f2427e76f","modified":1467114555000},{"_id":"source/_posts/ansible学习小记.md","hash":"4e8140c3fd45825b741b045c250b15c146744ca8","modified":1467114555000},{"_id":"source/_posts/hello-world.md","hash":"8fcbf5ea11d82c8677aace74eea0a38133fd8b3b","modified":1467114555000},{"_id":"source/_posts/python代码优化小技巧.md","hash":"5b36901a5ebf0a8e582188fc90037519da493f27","modified":1467114555000},{"_id":"source/_posts/python函数式编程.md","hash":"7a0e5d31c49357050df294a910e8afd320581496","modified":1467114555000},{"_id":"source/_posts/python函数调用小技巧.md","hash":"9eceb8d44f8628eaff093229a3fe1178d3b96daf","modified":1467114555000},{"_id":"source/_posts/redis、memcache、mongoDB性能总结.md","hash":"b18d76fc944460ad82902d10ca21cc1697e5e9c2","modified":1467114555000},{"_id":"source/_posts/关于爬虫你不得不知道的几个库.md","hash":"47b0f4f1054120e78bcdf2afda87cdaed79fd09b","modified":1467114555000},{"_id":"source/_posts/thoughtworks面试.md","hash":"a28edd1f8d608e47f140f49d55c7a5eeaf3f5be4","modified":1467114555000},{"_id":"source/_posts/一次完整的HTTP事务是怎样一个过程？.md","hash":"5d4ab1469e5a9aa7364d1b8c9b772c75e547675d","modified":1467114555000},{"_id":"source/_posts/推荐几个学习python还不错的网站.md","hash":"1fa5a304d30d6cf44b669fdc7e65e0b5cb4e71d4","modified":1467114555000},{"_id":"source/_posts/单元测试.md","hash":"540a911ac61327765edb2327cf2c0f9449489feb","modified":1467114555000},{"_id":"source/_posts/敏捷开发.md","hash":"d3cc2c06a7c40b20957d943fad9519a372de0275","modified":1467114555000},{"_id":"source/_posts/程序员入门之git.md","hash":"a9ec8c01fa3a9dc013f0587e3b1ff3be87f01223","modified":1467114555000},{"_id":"source/_posts/程序员工具（mac）.md","hash":"25d381c6cdba8f37b3012d8e104e7182294160b2","modified":1467114555000},{"_id":"source/_posts/程序员工具（windows）.md","hash":"88d31a8814bb045d73db257d68336234cf87f2d2","modified":1467114555000},{"_id":"source/about/index.md","hash":"681175f6d75a42721129840a075ea2361f33e54c","modified":1467114555000},{"_id":"source/categories/index.md","hash":"904b8bc3b1e60db7af01177ace10ae8fe88f249b","modified":1467114555000},{"_id":"source/tags/index.md","hash":"c16250b7b85b6d266052956c4c7a81370465d785","modified":1467114555000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1467114555000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"d6047c2afeabe9a329d92eb2a03490ff181616c2","modified":1467114555000},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1467114555000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1467114555000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1467114555000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1467114555000},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1467114555000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1467114555000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1467114555000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"bea452bc49aed171a210d09bd6cddc4e846ea8ab","modified":1467114555000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1467114555000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1467114555000},{"_id":"themes/next/layout/_layout.swig","hash":"b2bba2630b51ec27e3242859e8d4fe3b181742c2","modified":1467114555000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1467114555000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1467114555000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1467114555000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1467114555000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1467114555000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1467114555000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1467114555000},{"_id":"themes/next/source/404.html","hash":"72df58bbe64d52d7bf9b1b6e155acb77c7900143","modified":1467114555000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1467114555000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1467114555000},{"_id":"themes/next/test/.jshintrc","hash":"096ed6df627373edd820f24d46b8baf528dee61d","modified":1467114555000},{"_id":"source/images/default_avatar.jpg","hash":"93dba0f41bf0c09d8fbb345c20d0086d3136bf89","modified":1467114555000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1467114555000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1467114555000},{"_id":"themes/next/layout/_macro/post.swig","hash":"379737761f44fb71de997a73192f35b8e568ac58","modified":1467114555000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"e8e9c986ce1a0b370afd36703d49f1818492cb64","modified":1467114555000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"0ff291b272808fd471747f66b621822ed1dc8abd","modified":1467114555000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"82a9bc2ba60ce68419128ff60624bd74b15dfb78","modified":1467114555000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1467114555000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"3003fda5a8af553451f7945f4e1ce006ca72e4c4","modified":1467114555000},{"_id":"themes/next/layout/_partials/head.swig","hash":"a7084dcef03fa0d0c97962ec9828b77c9a73592f","modified":1467114555000},{"_id":"themes/next/layout/_partials/header.swig","hash":"7739068b69f87ae641dea19c3445169ae80d5df4","modified":1467114555000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1467114555000},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1467114555000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1467114555000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1467114555000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1467114555000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"21b055278a74f190571af67cfae03ae6c3fb295c","modified":1467114555000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1467114555000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1467114555000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1467114555000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1467114555000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1467114555000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1467114555000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1467114555000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1467114555000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1467114555000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1467114555000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1467114555000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1467114555000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1467114555000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1467114555000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1467114555000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1467114555000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1467114555000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1467114555000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1467114555000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1467114555000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1467114555000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1467114555000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1467114555000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1467114555000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1467114555000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1467114555000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1467114555000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1467114555000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1467114555000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1467114555000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"ce88ec0557b6d765ae38dd5984b178c7fc4d376e","modified":1467114555000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1467114555000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1467114555000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1467114555000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"2fc4a0d2c825a512f39c0eadd78452e90615465a","modified":1467114555000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"1561bd0c107d725252c6d746e9ac177fc18f93bf","modified":1467114555000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1467114555000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"df03220eb8526e17dc9c9f17780c2d6699367181","modified":1467114555000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1467114555000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1467114555000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"4e49707c99c8bbcfa0a607dfdaff0fbb7dffd2a3","modified":1467114555000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1467114555000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"bcf8238cf842bbfc8f3ea733889bc4dacf59d3c4","modified":1467114555000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"23df0070bef4952cc0e669f20fc78a8abba9676e","modified":1467114555000},{"_id":"themes/next/source/css/_variables/default.styl","hash":"8ec3307fe42d738b1bbda4b6419d0995f5560222","modified":1467114555000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1467114555000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1467114555000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1467114555000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1467114555000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1467114555000},{"_id":"themes/next/source/js/src/utils.js","hash":"19d36fa3874b088bc3514a15c2360b2d06318047","modified":1467114555000},{"_id":"themes/next/source/vendors/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1467114555000},{"_id":"themes/next/source/vendors/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1467114555000},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1467114555000},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1467114555000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1467114555000},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1467114555000},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1467114555000},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1467114555000},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1467114555000},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1467114555000},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1467114555000},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1467114555000},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1467114555000},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1467114555000},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1467114555000},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1467114555000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1467114555000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1467114555000},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1467114555000},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1467114555000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1467114555000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1467114555000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1467114555000},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1467114555000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1467114555000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"44e761721e8ad787ef571a3cc57bbc12d318a2a3","modified":1467114555000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"334176d838ee528e58468d8bc74ff3a6d3f25b2b","modified":1467114555000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1467114555000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1467114555000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"3491d3cebabc8a28857200db28a1be65aad6adc2","modified":1467114555000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"fa2b7a0006b6c447fa025474f8e0af4e4e569a36","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1467114555000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1467114555000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1467114555000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"2e829b0a7b6cbc4318672f3eeb7b26249038132d","modified":1467114555000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1467114555000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1467114555000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"04e6c5257814c65e638ab70c53030e8dfdb3f37d","modified":1467114555000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1467114555000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1467114555000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1467114555000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1467114555000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1467114555000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1467114555000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"6cc10d943d92eac953e6978e46d27ae55584482c","modified":1467114555000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1467114555000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1467114555000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1467114555000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1467114555000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"8aca5d9f1df157ab27e699c1b3ba9438b9e039ad","modified":1467114555000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"9658d09de4fcc809a29d4b706a9621adfb3090ad","modified":1467114555000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1467114555000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1467114555000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1467114555000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1467114555000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"b28187c610bf5f05e27732f72c3486494689bbfe","modified":1467114555000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1467114555000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"94f935331995bfeadf1084fb8f0665ab39fd1c8d","modified":1467114555000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1467114555000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1467114555000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1467114555000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1467114555000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1467114555000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1467114555000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1467114555000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1467114555000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1467114555000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1467114555000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1467114555000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1467114555000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1467114555000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1467114555000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1467114555000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1467114555000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1467114555000},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1467114555000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1467114555000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1467114555000},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"61763d236029d2a4414be499d0e65d7dfb34605b","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"23dd966324937deeccc8f5fa16a6d32e4e46243b","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4c0be672d977ef793c72cf838f1d920f2749dda0","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"ae19721ceee5ba460e131cb2427dae3c1ff39d6f","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"fe71e9be08cb418cf68352fd6212ddd0d7150579","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"330a2ce52c5a5fefc1e85c473113a3bc58210c76","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"99d994bd19895a4aaa2fa8d12801ec72dd3cf118","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4677ae612ff9c593ee17ab2ea82dbb995432d301","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"89fef1caf94caf76ca09c643b83b0b4d4e417e08","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"6533563b34241e5c73da68156aba89e880b93f53","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"12f703e5fea9d8a7ba65c8cea93a5cf5c2b78457","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"58fb7604b44e3f56d880bbbd95d0baface38c4ee","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1467114555000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"f7ebd428f3058ec3ecc7648788712617bea520ba","modified":1467114555000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1467114555000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1467114555000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1467114555000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1467114555000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1467114555000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1467114555000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1467114555000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1467114555000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1467114555000}],"Category":[{"name":"ThoughtWorker","_id":"cipzgzejz0005egfyjf3z46uo"},{"name":"web","_id":"cipzgzek3000aegfyvsgqtjuv"},{"name":"SQL","_id":"cipzgzek9000gegfybinnrdrz"},{"name":"Linux","_id":"cipzgzekd000megfysy7we4xx"},{"name":"Devops","_id":"cipzgzekg000regfyczas022t"},{"name":"code","_id":"cipzgzekn000zegfyr1d5ie15"},{"name":"crawler","_id":"cipzgzekx001jegfyd236u397"},{"name":"study","_id":"cipzgzeky001oegfy6ngpdol6"},{"name":"TDD","_id":"cipzgzekz001regfy59n14okg"},{"name":"worker","_id":"cipzgzel1001zegfyge4dyeti"}],"Data":[],"Page":[{"title":"about","date":"2016-03-23T14:12:09.000Z","type":"about","_content":"\n# 关于作者\n\n![me](/images/me.jpg)\n\n**职业经历：**\n> * name:**杜屹东**\n> * **2015年** 毕业于**西华大学** **计算机科学与技术**\n> * 坐标：四川**成都**\n> * 现就职于四川神琥科技有限公司\n> * `python` `js`  `web`开发\n\n----\n**座右铭**\n> * **一个人旺盛的生命力在于不断地学习**\n\n----\n**你可以在这里找到我：**\n\nhomepage: [Adu's blog](http://adu.404nf.cn)\n\ngithub： [@ADU-21](https://github.com/ADU-21)\n\ntwitter: [@LukeDu](https://twitter.com/duuyidong)\n\nstackoverflow:[@LukeDu](http://stackoverflow.com/users/6069208/luke-du)\n\nLOFTER： [@duuyidong](http://duuyidong.lofter.com/)\n\n豆瓣： [@蝼蚁](https://www.douban.com/people/69144075/)\n\n微博： [@说实话会死星人](http://weibo.com/2959896944)\n\n500px: [@说实话会死星人](http://500px.me/community/user-details/d66b850364162b7a6e323dc5ba8fb8662)\n\n图虫： [@旅行的意义](https://tuchong.com/439960/)\n\n知乎： [@Luke](https://www.zhihu.com/people/luke-10)\n\nCSDN：[@duuyidong](http://my.csdn.net/u012778922)\n\n邮箱：duuyidong@163.com\n\n微信：duuyidong\n\nQQ：1352996268\n\n----\n\n**我常去的网站：**\n\n乌云网：[http://zone.wooyun.org/](http://zone.wooyun.org/)\n\nfreebuf: [http://www.freebuf.com/](http://www.freebuf.com/)\n\n漏洞盒子： [https://www.vulbox.com/](https://www.vulbox.com/)\n\nshodan: [https://shodan.io](https://shodan.io)\n\n钟馗之眼： [https://www.zoomeye.org/](https://www.zoomeye.org/)\n\n爱范儿： [http://www.ifanr.com/](http://www.ifanr.com/)\n\n前沿： [http://t.qianzhan.com/](http://t.qianzhan.com/)\n\n威锋： [http://www.feng.com/](http://www.feng.com/)\n\n站长之家： [http://www.chinaz.com/](http://www.chinaz.com/)\n\nCSDN: [http://www.csdn.net/](http://www.csdn.net/)\n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-03-23 22:12:09\ntype: \"about\"\n---\n\n# 关于作者\n\n![me](/images/me.jpg)\n\n**职业经历：**\n> * name:**杜屹东**\n> * **2015年** 毕业于**西华大学** **计算机科学与技术**\n> * 坐标：四川**成都**\n> * 现就职于四川神琥科技有限公司\n> * `python` `js`  `web`开发\n\n----\n**座右铭**\n> * **一个人旺盛的生命力在于不断地学习**\n\n----\n**你可以在这里找到我：**\n\nhomepage: [Adu's blog](http://adu.404nf.cn)\n\ngithub： [@ADU-21](https://github.com/ADU-21)\n\ntwitter: [@LukeDu](https://twitter.com/duuyidong)\n\nstackoverflow:[@LukeDu](http://stackoverflow.com/users/6069208/luke-du)\n\nLOFTER： [@duuyidong](http://duuyidong.lofter.com/)\n\n豆瓣： [@蝼蚁](https://www.douban.com/people/69144075/)\n\n微博： [@说实话会死星人](http://weibo.com/2959896944)\n\n500px: [@说实话会死星人](http://500px.me/community/user-details/d66b850364162b7a6e323dc5ba8fb8662)\n\n图虫： [@旅行的意义](https://tuchong.com/439960/)\n\n知乎： [@Luke](https://www.zhihu.com/people/luke-10)\n\nCSDN：[@duuyidong](http://my.csdn.net/u012778922)\n\n邮箱：duuyidong@163.com\n\n微信：duuyidong\n\nQQ：1352996268\n\n----\n\n**我常去的网站：**\n\n乌云网：[http://zone.wooyun.org/](http://zone.wooyun.org/)\n\nfreebuf: [http://www.freebuf.com/](http://www.freebuf.com/)\n\n漏洞盒子： [https://www.vulbox.com/](https://www.vulbox.com/)\n\nshodan: [https://shodan.io](https://shodan.io)\n\n钟馗之眼： [https://www.zoomeye.org/](https://www.zoomeye.org/)\n\n爱范儿： [http://www.ifanr.com/](http://www.ifanr.com/)\n\n前沿： [http://t.qianzhan.com/](http://t.qianzhan.com/)\n\n威锋： [http://www.feng.com/](http://www.feng.com/)\n\n站长之家： [http://www.chinaz.com/](http://www.chinaz.com/)\n\nCSDN: [http://www.csdn.net/](http://www.csdn.net/)\n\n","updated":"2016-06-28T11:49:15.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cipzgzeju0001egfy4yqhl9xd","content":"<h1 id=\"关于作者\"><a href=\"#关于作者\" class=\"headerlink\" title=\"关于作者\"></a>关于作者</h1><p><img src=\"/images/me.jpg\" alt=\"me\"></p>\n<p><strong>职业经历：</strong></p>\n<blockquote>\n<ul>\n<li>name:<strong>杜屹东</strong></li>\n<li><strong>2015年</strong> 毕业于<strong>西华大学</strong> <strong>计算机科学与技术</strong></li>\n<li>坐标：四川<strong>成都</strong></li>\n<li>现就职于四川神琥科技有限公司</li>\n<li><code>python</code> <code>js</code>  <code>web</code>开发</li>\n</ul>\n</blockquote>\n<hr>\n<p><strong>座右铭</strong></p>\n<blockquote>\n<ul>\n<li><strong>一个人旺盛的生命力在于不断地学习</strong></li>\n</ul>\n</blockquote>\n<hr>\n<p><strong>你可以在这里找到我：</strong></p>\n<p>homepage: <a href=\"http://adu.404nf.cn\">Adu’s blog</a></p>\n<p>github： <a href=\"https://github.com/ADU-21\" target=\"_blank\" rel=\"external\">@ADU-21</a></p>\n<p>twitter: <a href=\"https://twitter.com/duuyidong\" target=\"_blank\" rel=\"external\">@LukeDu</a></p>\n<p>stackoverflow:<a href=\"http://stackoverflow.com/users/6069208/luke-du\" target=\"_blank\" rel=\"external\">@LukeDu</a></p>\n<p>LOFTER： <a href=\"http://duuyidong.lofter.com/\" target=\"_blank\" rel=\"external\">@duuyidong</a></p>\n<p>豆瓣： <a href=\"https://www.douban.com/people/69144075/\" target=\"_blank\" rel=\"external\">@蝼蚁</a></p>\n<p>微博： <a href=\"http://weibo.com/2959896944\" target=\"_blank\" rel=\"external\">@说实话会死星人</a></p>\n<p>500px: <a href=\"http://500px.me/community/user-details/d66b850364162b7a6e323dc5ba8fb8662\" target=\"_blank\" rel=\"external\">@说实话会死星人</a></p>\n<p>图虫： <a href=\"https://tuchong.com/439960/\" target=\"_blank\" rel=\"external\">@旅行的意义</a></p>\n<p>知乎： <a href=\"https://www.zhihu.com/people/luke-10\" target=\"_blank\" rel=\"external\">@Luke</a></p>\n<p>CSDN：<a href=\"http://my.csdn.net/u012778922\" target=\"_blank\" rel=\"external\">@duuyidong</a></p>\n<p>邮箱：duuyidong@163.com</p>\n<p>微信：duuyidong</p>\n<p>QQ：1352996268</p>\n<hr>\n<p><strong>我常去的网站：</strong></p>\n<p>乌云网：<a href=\"http://zone.wooyun.org/\" target=\"_blank\" rel=\"external\">http://zone.wooyun.org/</a></p>\n<p>freebuf: <a href=\"http://www.freebuf.com/\" target=\"_blank\" rel=\"external\">http://www.freebuf.com/</a></p>\n<p>漏洞盒子： <a href=\"https://www.vulbox.com/\" target=\"_blank\" rel=\"external\">https://www.vulbox.com/</a></p>\n<p>shodan: <a href=\"https://shodan.io\" target=\"_blank\" rel=\"external\">https://shodan.io</a></p>\n<p>钟馗之眼： <a href=\"https://www.zoomeye.org/\" target=\"_blank\" rel=\"external\">https://www.zoomeye.org/</a></p>\n<p>爱范儿： <a href=\"http://www.ifanr.com/\" target=\"_blank\" rel=\"external\">http://www.ifanr.com/</a></p>\n<p>前沿： <a href=\"http://t.qianzhan.com/\" target=\"_blank\" rel=\"external\">http://t.qianzhan.com/</a></p>\n<p>威锋： <a href=\"http://www.feng.com/\" target=\"_blank\" rel=\"external\">http://www.feng.com/</a></p>\n<p>站长之家： <a href=\"http://www.chinaz.com/\" target=\"_blank\" rel=\"external\">http://www.chinaz.com/</a></p>\n<p>CSDN: <a href=\"http://www.csdn.net/\" target=\"_blank\" rel=\"external\">http://www.csdn.net/</a></p>\n","excerpt":"","more":"<h1 id=\"关于作者\"><a href=\"#关于作者\" class=\"headerlink\" title=\"关于作者\"></a>关于作者</h1><p><img src=\"/images/me.jpg\" alt=\"me\"></p>\n<p><strong>职业经历：</strong></p>\n<blockquote>\n<ul>\n<li>name:<strong>杜屹东</strong></li>\n<li><strong>2015年</strong> 毕业于<strong>西华大学</strong> <strong>计算机科学与技术</strong></li>\n<li>坐标：四川<strong>成都</strong></li>\n<li>现就职于四川神琥科技有限公司</li>\n<li><code>python</code> <code>js</code>  <code>web</code>开发</li>\n</ul>\n</blockquote>\n<hr>\n<p><strong>座右铭</strong></p>\n<blockquote>\n<ul>\n<li><strong>一个人旺盛的生命力在于不断地学习</strong></li>\n</ul>\n</blockquote>\n<hr>\n<p><strong>你可以在这里找到我：</strong></p>\n<p>homepage: <a href=\"http://adu.404nf.cn\">Adu’s blog</a></p>\n<p>github： <a href=\"https://github.com/ADU-21\">@ADU-21</a></p>\n<p>twitter: <a href=\"https://twitter.com/duuyidong\">@LukeDu</a></p>\n<p>stackoverflow:<a href=\"http://stackoverflow.com/users/6069208/luke-du\">@LukeDu</a></p>\n<p>LOFTER： <a href=\"http://duuyidong.lofter.com/\">@duuyidong</a></p>\n<p>豆瓣： <a href=\"https://www.douban.com/people/69144075/\">@蝼蚁</a></p>\n<p>微博： <a href=\"http://weibo.com/2959896944\">@说实话会死星人</a></p>\n<p>500px: <a href=\"http://500px.me/community/user-details/d66b850364162b7a6e323dc5ba8fb8662\">@说实话会死星人</a></p>\n<p>图虫： <a href=\"https://tuchong.com/439960/\">@旅行的意义</a></p>\n<p>知乎： <a href=\"https://www.zhihu.com/people/luke-10\">@Luke</a></p>\n<p>CSDN：<a href=\"http://my.csdn.net/u012778922\">@duuyidong</a></p>\n<p>邮箱：duuyidong@163.com</p>\n<p>微信：duuyidong</p>\n<p>QQ：1352996268</p>\n<hr>\n<p><strong>我常去的网站：</strong></p>\n<p>乌云网：<a href=\"http://zone.wooyun.org/\">http://zone.wooyun.org/</a></p>\n<p>freebuf: <a href=\"http://www.freebuf.com/\">http://www.freebuf.com/</a></p>\n<p>漏洞盒子： <a href=\"https://www.vulbox.com/\">https://www.vulbox.com/</a></p>\n<p>shodan: <a href=\"https://shodan.io\">https://shodan.io</a></p>\n<p>钟馗之眼： <a href=\"https://www.zoomeye.org/\">https://www.zoomeye.org/</a></p>\n<p>爱范儿： <a href=\"http://www.ifanr.com/\">http://www.ifanr.com/</a></p>\n<p>前沿： <a href=\"http://t.qianzhan.com/\">http://t.qianzhan.com/</a></p>\n<p>威锋： <a href=\"http://www.feng.com/\">http://www.feng.com/</a></p>\n<p>站长之家： <a href=\"http://www.chinaz.com/\">http://www.chinaz.com/</a></p>\n<p>CSDN: <a href=\"http://www.csdn.net/\">http://www.csdn.net/</a></p>\n"},{"title":"categories","date":"2016-03-23T13:43:43.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-03-23 21:43:43\ntype: \"categories\"\ncomments: false\n---\n","updated":"2016-06-28T11:49:15.000Z","path":"categories/index.html","layout":"page","_id":"cipzgzejx0003egfys016z3fk","content":"","excerpt":"","more":""},{"title":"tags","date":"2016-03-23T13:40:49.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-03-23 21:40:49\ntype: \"tags\"\ncomments: false\n---\n","updated":"2016-06-28T11:49:15.000Z","path":"tags/index.html","layout":"page","_id":"cipzgzeo3003degfyjy7prbyc","content":"","excerpt":"","more":""}],"Post":[{"title":"CI/CD","date":"2016-05-19T12:04:35.000Z","_content":"# Agile Development\n\nbefore we talk about CI and CD， I think we should figure out why we need them, so we have to talk about Agile Development first.\nAgile Development is a set of principles for software development. It was develop to response to changing customer's requirement. As we all know, managers generally desirable to quantify the progress of the development, but quantify of the coding is not easy, the quantify we can only control is the process of the requirment. So we can process a requirement implemented as an iteration cycle of software development.\nFor this purpose, they created with CI and CD as the core of agile development.\n<!-- more -->\n## Continuous Integration(CI)\n\nContinuous Integration means you need to integration at least daily, It's a development practice that requires developers to integrate code into a shared repository several times a day.\"Shared\"\" means everyone can see what others working on, Frequently compile, test, commit means every times we commit, the code could be running, ideally, every integration should be automated, the unit-test allowing teams to detect problems early. By integration regularly, you can detect errors quickly, and locate them more easily.  \nthere are many advantages for Continuous Integration, one of which is the continuous delivery.\n\n## Continuous Delivery(CD)\n\nContinuous Delivery is customer requirement oriented, It's like Continuous Integration but more than it, Continuous Delivery is the natural extension of Continuous Integration, Continuous Delivery makes releases boring, so we can deliver frequently and get fast feedback on what users care about.\n\n## Continuous Deployment\n\nContinuous Deployment is more than Continuous Delivery, seams like this:\n ![88cd2b608bfb92ca5487a3e41694e9ccf6b.jpg](https://d1089v03p3mzyq.cloudfront.net/assets/website/continuous-integration-essentials/continuous-delivery-vs-continuous-deployment-b371cf5be55b1c52635058af7b70188cd2b608bfb92ca5487a3e41694e9ccf6b.jpg)\nIt is the practice of keeping your codebase deployable at any point. Beyond making sure your application passes automated tests it has to have all the configuration necessary to push it into production. Many teams then do push changes that pass the automated tests into a test or production environment immediately to ensure a fast development loop.\nA simplified continuous deployment flow can look like this:\n![New-Page.png](https://risingstack-blog.s3-eu-west-1.amazonaws.com/2014/Sep/Continuous-deployment---New-Page.png)\n\n\n## Development Operations(DevOps)\n\nDevelopment Operations is bigger than Continuous Deployment, It aims at establishing a culture and environment where building testing, and releasing software, can happen rapidly, and more reliably.\nIn my words, DevOps is a practical form of agile.\n\n## Tools for CI and CD\n\n[Jenkins](https://jenkins.io/)\n\n[GoCD](https://www.go.cd/download/)\n\n[TeamCity](https://www.jetbrains.com/teamcity/)\n\n[Travis CI](https://travis-ci.org/)","source":"_posts/CI-CD.md","raw":"---\ntitle: CI/CD\ndate: 2016-05-19 20:04:35\ncategories: ThoughtWorker\ntags: [敏捷开发]\n\n---\n# Agile Development\n\nbefore we talk about CI and CD， I think we should figure out why we need them, so we have to talk about Agile Development first.\nAgile Development is a set of principles for software development. It was develop to response to changing customer's requirement. As we all know, managers generally desirable to quantify the progress of the development, but quantify of the coding is not easy, the quantify we can only control is the process of the requirment. So we can process a requirement implemented as an iteration cycle of software development.\nFor this purpose, they created with CI and CD as the core of agile development.\n<!-- more -->\n## Continuous Integration(CI)\n\nContinuous Integration means you need to integration at least daily, It's a development practice that requires developers to integrate code into a shared repository several times a day.\"Shared\"\" means everyone can see what others working on, Frequently compile, test, commit means every times we commit, the code could be running, ideally, every integration should be automated, the unit-test allowing teams to detect problems early. By integration regularly, you can detect errors quickly, and locate them more easily.  \nthere are many advantages for Continuous Integration, one of which is the continuous delivery.\n\n## Continuous Delivery(CD)\n\nContinuous Delivery is customer requirement oriented, It's like Continuous Integration but more than it, Continuous Delivery is the natural extension of Continuous Integration, Continuous Delivery makes releases boring, so we can deliver frequently and get fast feedback on what users care about.\n\n## Continuous Deployment\n\nContinuous Deployment is more than Continuous Delivery, seams like this:\n ![88cd2b608bfb92ca5487a3e41694e9ccf6b.jpg](https://d1089v03p3mzyq.cloudfront.net/assets/website/continuous-integration-essentials/continuous-delivery-vs-continuous-deployment-b371cf5be55b1c52635058af7b70188cd2b608bfb92ca5487a3e41694e9ccf6b.jpg)\nIt is the practice of keeping your codebase deployable at any point. Beyond making sure your application passes automated tests it has to have all the configuration necessary to push it into production. Many teams then do push changes that pass the automated tests into a test or production environment immediately to ensure a fast development loop.\nA simplified continuous deployment flow can look like this:\n![New-Page.png](https://risingstack-blog.s3-eu-west-1.amazonaws.com/2014/Sep/Continuous-deployment---New-Page.png)\n\n\n## Development Operations(DevOps)\n\nDevelopment Operations is bigger than Continuous Deployment, It aims at establishing a culture and environment where building testing, and releasing software, can happen rapidly, and more reliably.\nIn my words, DevOps is a practical form of agile.\n\n## Tools for CI and CD\n\n[Jenkins](https://jenkins.io/)\n\n[GoCD](https://www.go.cd/download/)\n\n[TeamCity](https://www.jetbrains.com/teamcity/)\n\n[Travis CI](https://travis-ci.org/)","slug":"CI-CD","published":1,"updated":"2016-06-28T11:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzgzejq0000egfypsq7c5j7","content":"<h1 id=\"Agile-Development\"><a href=\"#Agile-Development\" class=\"headerlink\" title=\"Agile Development\"></a>Agile Development</h1><p>before we talk about CI and CD， I think we should figure out why we need them, so we have to talk about Agile Development first.<br>Agile Development is a set of principles for software development. It was develop to response to changing customer’s requirement. As we all know, managers generally desirable to quantify the progress of the development, but quantify of the coding is not easy, the quantify we can only control is the process of the requirment. So we can process a requirement implemented as an iteration cycle of software development.<br>For this purpose, they created with CI and CD as the core of agile development.<br><a id=\"more\"></a></p>\n<h2 id=\"Continuous-Integration-CI\"><a href=\"#Continuous-Integration-CI\" class=\"headerlink\" title=\"Continuous Integration(CI)\"></a>Continuous Integration(CI)</h2><p>Continuous Integration means you need to integration at least daily, It’s a development practice that requires developers to integrate code into a shared repository several times a day.”Shared”” means everyone can see what others working on, Frequently compile, test, commit means every times we commit, the code could be running, ideally, every integration should be automated, the unit-test allowing teams to detect problems early. By integration regularly, you can detect errors quickly, and locate them more easily.<br>there are many advantages for Continuous Integration, one of which is the continuous delivery.</p>\n<h2 id=\"Continuous-Delivery-CD\"><a href=\"#Continuous-Delivery-CD\" class=\"headerlink\" title=\"Continuous Delivery(CD)\"></a>Continuous Delivery(CD)</h2><p>Continuous Delivery is customer requirement oriented, It’s like Continuous Integration but more than it, Continuous Delivery is the natural extension of Continuous Integration, Continuous Delivery makes releases boring, so we can deliver frequently and get fast feedback on what users care about.</p>\n<h2 id=\"Continuous-Deployment\"><a href=\"#Continuous-Deployment\" class=\"headerlink\" title=\"Continuous Deployment\"></a>Continuous Deployment</h2><p>Continuous Deployment is more than Continuous Delivery, seams like this:<br> <img src=\"https://d1089v03p3mzyq.cloudfront.net/assets/website/continuous-integration-essentials/continuous-delivery-vs-continuous-deployment-b371cf5be55b1c52635058af7b70188cd2b608bfb92ca5487a3e41694e9ccf6b.jpg\" alt=\"88cd2b608bfb92ca5487a3e41694e9ccf6b.jpg\"><br>It is the practice of keeping your codebase deployable at any point. Beyond making sure your application passes automated tests it has to have all the configuration necessary to push it into production. Many teams then do push changes that pass the automated tests into a test or production environment immediately to ensure a fast development loop.<br>A simplified continuous deployment flow can look like this:<br><img src=\"https://risingstack-blog.s3-eu-west-1.amazonaws.com/2014/Sep/Continuous-deployment---New-Page.png\" alt=\"New-Page.png\"></p>\n<h2 id=\"Development-Operations-DevOps\"><a href=\"#Development-Operations-DevOps\" class=\"headerlink\" title=\"Development Operations(DevOps)\"></a>Development Operations(DevOps)</h2><p>Development Operations is bigger than Continuous Deployment, It aims at establishing a culture and environment where building testing, and releasing software, can happen rapidly, and more reliably.<br>In my words, DevOps is a practical form of agile.</p>\n<h2 id=\"Tools-for-CI-and-CD\"><a href=\"#Tools-for-CI-and-CD\" class=\"headerlink\" title=\"Tools for CI and CD\"></a>Tools for CI and CD</h2><p><a href=\"https://jenkins.io/\" target=\"_blank\" rel=\"external\">Jenkins</a></p>\n<p><a href=\"https://www.go.cd/download/\" target=\"_blank\" rel=\"external\">GoCD</a></p>\n<p><a href=\"https://www.jetbrains.com/teamcity/\" target=\"_blank\" rel=\"external\">TeamCity</a></p>\n<p><a href=\"https://travis-ci.org/\" target=\"_blank\" rel=\"external\">Travis CI</a></p>\n","excerpt":"<h1 id=\"Agile-Development\"><a href=\"#Agile-Development\" class=\"headerlink\" title=\"Agile Development\"></a>Agile Development</h1><p>before we talk about CI and CD， I think we should figure out why we need them, so we have to talk about Agile Development first.<br>Agile Development is a set of principles for software development. It was develop to response to changing customer’s requirement. As we all know, managers generally desirable to quantify the progress of the development, but quantify of the coding is not easy, the quantify we can only control is the process of the requirment. So we can process a requirement implemented as an iteration cycle of software development.<br>For this purpose, they created with CI and CD as the core of agile development.<br>","more":"</p>\n<h2 id=\"Continuous-Integration-CI\"><a href=\"#Continuous-Integration-CI\" class=\"headerlink\" title=\"Continuous Integration(CI)\"></a>Continuous Integration(CI)</h2><p>Continuous Integration means you need to integration at least daily, It’s a development practice that requires developers to integrate code into a shared repository several times a day.”Shared”” means everyone can see what others working on, Frequently compile, test, commit means every times we commit, the code could be running, ideally, every integration should be automated, the unit-test allowing teams to detect problems early. By integration regularly, you can detect errors quickly, and locate them more easily.<br>there are many advantages for Continuous Integration, one of which is the continuous delivery.</p>\n<h2 id=\"Continuous-Delivery-CD\"><a href=\"#Continuous-Delivery-CD\" class=\"headerlink\" title=\"Continuous Delivery(CD)\"></a>Continuous Delivery(CD)</h2><p>Continuous Delivery is customer requirement oriented, It’s like Continuous Integration but more than it, Continuous Delivery is the natural extension of Continuous Integration, Continuous Delivery makes releases boring, so we can deliver frequently and get fast feedback on what users care about.</p>\n<h2 id=\"Continuous-Deployment\"><a href=\"#Continuous-Deployment\" class=\"headerlink\" title=\"Continuous Deployment\"></a>Continuous Deployment</h2><p>Continuous Deployment is more than Continuous Delivery, seams like this:<br> <img src=\"https://d1089v03p3mzyq.cloudfront.net/assets/website/continuous-integration-essentials/continuous-delivery-vs-continuous-deployment-b371cf5be55b1c52635058af7b70188cd2b608bfb92ca5487a3e41694e9ccf6b.jpg\" alt=\"88cd2b608bfb92ca5487a3e41694e9ccf6b.jpg\"><br>It is the practice of keeping your codebase deployable at any point. Beyond making sure your application passes automated tests it has to have all the configuration necessary to push it into production. Many teams then do push changes that pass the automated tests into a test or production environment immediately to ensure a fast development loop.<br>A simplified continuous deployment flow can look like this:<br><img src=\"https://risingstack-blog.s3-eu-west-1.amazonaws.com/2014/Sep/Continuous-deployment---New-Page.png\" alt=\"New-Page.png\"></p>\n<h2 id=\"Development-Operations-DevOps\"><a href=\"#Development-Operations-DevOps\" class=\"headerlink\" title=\"Development Operations(DevOps)\"></a>Development Operations(DevOps)</h2><p>Development Operations is bigger than Continuous Deployment, It aims at establishing a culture and environment where building testing, and releasing software, can happen rapidly, and more reliably.<br>In my words, DevOps is a practical form of agile.</p>\n<h2 id=\"Tools-for-CI-and-CD\"><a href=\"#Tools-for-CI-and-CD\" class=\"headerlink\" title=\"Tools for CI and CD\"></a>Tools for CI and CD</h2><p><a href=\"https://jenkins.io/\">Jenkins</a></p>\n<p><a href=\"https://www.go.cd/download/\">GoCD</a></p>\n<p><a href=\"https://www.jetbrains.com/teamcity/\">TeamCity</a></p>\n<p><a href=\"https://travis-ci.org/\">Travis CI</a></p>"},{"title":"HTTP协议详解","date":"2016-03-30T13:02:31.000Z","_content":"# HTTP协议详解\n这是一篇想写了很久却迟迟没有动笔的题目\n\n从开始接触爬虫，或者说接触web开始，你就是在和http协议打交道了，我想web这个职业只要http协议不过时应该就不会有太大的变化。\n<!-- more -->\n好，下面是正文:\n\n----\n先说说HTTP协议是怎样工作的：\n步骤1：浏览器首先向服务器发送HTTP请求，请求包括：\n\n方法：GET还是POST，GET仅请求资源，POST会附带用户数据；\n\n路径：/full/url/path；\n\n域名：由Host头指定：Host: www.sina.com.cn\n\n以及其他相关的Header；\n\n如果是POST，那么请求还包括一个Body，包含用户数据。\n\n步骤2：服务器向浏览器返回HTTP响应，响应包括：\n\n响应代码：200表示成功，3xx表示重定向，4xx表示客户端发送的请求有错误，5xx表示服务器端处理时发生了错误；\n\n响应类型：由Content-Type指定；\n\n以及其他相关的Header；\n\n通常服务器的HTTP响应会携带内容，也就是有一个Body，包含响应的内容，网页的HTML源码就在Body中。\n\n步骤3：如果浏览器还需要继续向服务器请求其他资源，比如图片，就再次发出HTTP请求，重复步骤1、2。\n\nWeb采用的HTTP协议采用了非常简单的请求-响应模式，从而大大简化了开发。当我们编写一个页面时，我们只需要在HTTP请求中把HTML发送出去，不需要考虑如何附带图片、视频等，浏览器如果需要请求图片和视频，它会发送另一个HTTP请求，因此，一个HTTP请求只处理一个资源。\n\nHTTP协议同时具备极强的扩展性，虽然浏览器请求的是 http://www.sina.com.cn/ 的首页，但是新浪在HTML中可以链入其他服务器的资源，比如\n```\n<img src=\"http://i1.sinaimg.cn/home/2013/1008/U8455P30DT20131008135420.png\">\n```\n\n，从而将请求压力分散到各个服务器上，并且，一个站点可以链接到其他站点，无数个站点互相链接起来，就形成了World Wide Web，简称WWW。\n\n\n----\n\n## 超文本传输协议\nhttp就是用于规范客户端和服务器之间文本传输的一个协议，我们在访问网站的时候大多数时候都是通过这个协议从服务器上获取想要的数据的。\n### 从get方法和post方法谈起\n最早让我想要弄清楚HTTP协议是源于我在写爬虫的时候使用python的requests模块，经常会弄不清楚到底该用get方法还是post方法，比较通俗的说法是post方法比较安全，可以带data，get方法就是url请求，请求体全部都暴露在url里面，较不安全，然而研究后发现，HTTP的四种方法get,post,put,delete方法并没有本质上的区别，协议本身并没有强制规范什么情况下必须使用什么请求，事实上这几种请求方法的格式是一样的。\n### 请求方法\n请求方法（所有方法全为大写）有多种，各个方法的解释如下：\n\n\tGET     请求获取Request-URI所标识的资源\n\tPOST    在Request-URI所标识的资源后附加新的数据\n\tHEAD    请求获取由Request-URI所标识的资源的响应消息报头\n\tPUT     请求服务器存储一个资源，并用Request-URI作为其标识\n\tDELETE  请求服务器删除Request-URI所标识的资源\n\tTRACE   请求服务器回送收到的请求信息，主要用于测试或诊断\n\tCONNECT 保留将来使用\t\n\tOPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求\n\n## header\n### General Header（通用头）\nHTTP里的通用头既可以包含在请求头中也可以包含在响应头中，作用主要是描述HTTO协议本身，下面举例几个常见的通用头：\n#### Cache-Control头域\nCache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下：\n> * Public指示响应可被任何缓存区缓存。\n> * Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。\n> * no-cache指示请求或响应消息不能缓存\n> * no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。\n> * max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。\n> * min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。\n> * max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。\n\n#### HTTP Keep-Alive\nKeep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。市场上的大部分Web服务器，包括iPlanet、IIS和Apache，都支持HTTP Keep-Alive。对于提供静态内容的网站来说，这个功能通常很有用。但是，对于负担较重的网站来说，这里存在另外一个问题：虽然为客户保留打开的连接有一定的好处，但它同样影响了性能，因为在处理暂停期间，本来可以释放的资源仍旧被占用。当Web服务器和应用服务器在同一台机器上运行时，Keep- Alive功能对资源利用的影响尤其突出。\nKeepAliveTime 值控制 TCP/IP 尝试验证空闲连接是否完好的频率。如果这段时间内没有活动，则会发送保持活动信号。如果网络工作正常，而且接收方是活动的，它就会响应。如果需要对丢失接收方敏感，换句话说，需要更快地发现丢失了接收方，请考虑减小这个值。如果长期不活动的空闲连接出现次数较多，而丢失接收方的情况出现较少，您可能会要提高该值以减少开销。缺省情况下，如果空闲连接 7200000 毫秒（2 小时）内没有活动，Windows 就发送保持活动的消息。通常，1800000 毫秒是首选值，从而一半的已关闭连接会在 30 分钟内被检测到。 KeepAliveInterval 值定义了如果未从接收方收到保持活动消息的响应，TCP/IP 重复发送保持活动信号的频率。当连续发送保持活动信号、但未收到响应的次数超出 TcpMaxDataRetransmissions 的值时，会放弃该连接。如果期望较长的响应时间，您可能需要提高该值以减少开销。如果需要减少花在验证接收方是否已丢失上的时间，请考虑减小该值或 TcpMaxDataRetransmissions 值。缺省情况下，在未收到响应而重新发送保持活动的消息之前，Windows 会等待 1000 毫秒（1 秒）。 KeepAliveTime 根据你的需要设置就行，比如10分钟，注意要转换成MS。 XXX代表这个间隔值得大小。\n#### Date头域\nDate头域表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。\n#### Pragma头域\nPragma头域用来包含实现特定的指令，最常用的是Pragma:no-cache。在HTTP/1.1协议中，它的含义和Cache-Control:no-cache相同。\n### Entity header(实体头)\n请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体头，但是这些域可能无法被接受方识别。实体可以是一个经过编码的字节流，它的编码方式由Content-Encoding或Content-Type定义，它的长度由Content-Length或Content-Range定义。\n#### Content-Type实体头\nContent-Type实体头用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型\n#### Content-Range实体头\nContent-Range实体头用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式：\nContent-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth\n例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围，Content-Length表示实际传送的字节数。\n#### Last-modified实体头\nLast-modified实体头指定服务器上保存内容的最后修订时间。\n例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围，Content-Length表示实际传送的字节数。\n### HTTP Request Header（请求头）\n这就是我们最常见的header了，请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。\n以下为常见的请求报头：\n#### Accept\nAccept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。\n\n#### Accept-Charset\nAccept-Charset请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。\n\n#### Accept-Encoding\nAccept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。\n\n#### Accept-Language\nAccept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。\n\n#### Authorization\nAuthorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。\n\n#### Host（发送请求时，该报头域是必需的）\nHost请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，eg：\n我们在浏览器中输入：http://www.guet.edu.cn/index.html\n浏览器发送的请求消息中，就会包含Host请求报头域，如下：\nHost：www.guet.edu.cn\n此处使用缺省端口号80，若指定了端口号，则变成：Host：www.guet.edu.cn:指定端口号\n#### Referer头域\nReferer头域允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等。他也允许废除的或错误的连接由于维护的目的被追踪。如果请求的uri没有自己的uri地址，Referer不能被发送。如果指定的是部分uri地址，则此地址应该是一个相对地址。\n\n#### User-Agent\n我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。\n\n请求报头举例：\n\n```\nGET /form.html HTTP/1.1 (CRLF)\nAccept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,*/* (CRLF)\nAccept-Language:zh-cn (CRLF)\nAccept-Encoding:gzip,deflate (CRLF)\nIf-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)\nIf-None-Match:W/\"80b1a4c018f3c41:8317\" (CRLF)\nUser-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)\nHost:www.guet.edu.cn (CRLF)\nConnection:Keep-Alive (CRLF)\n(CRLF)\n\n```\n\n## body\nbody包涵请求的实体。\n\n\n## Response\n### 状态码\n响应消息的第一行为下面的格式：\nHTTP-VersionSPStatus-CodeSPReason-PhraseCRLF\nHTTP-Version表示支持的HTTP版本，例如为HTTP/1.1。Status-Code是一个三个数字的结果代码。Reason-Phrase给Status-Code提供一个简单的文本描述。Status-Code主要用于机器自动识别，Reason-Phrase主要用于帮助用户理解。Status-Code的第一个数字定义响应的类别，后两个数字没有分类的作用。第一个数字可能取5个不同的值：\n1xx:信息响应类，表示接收到请求并且继续处理\n2xx:处理成功响应类，表示动作被成功接收、理解和接受\n3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理\n4xx:客户端错误，客户请求包含语法错误或者是不能正确执行\n5xx:服务端错误，服务器不能正确执行一个正确的请求\n### 响应头\n响应头域允许服务器传递不能放在状态行的附加信息，这些域主要描述服务器的信息和Request-URI进一步的信息。响应头域包含Age、Location、Proxy-Authenticate、Public、Retry-After、Server、Vary、Warning、WWW-Authenticate。对响应头域的扩展要求通讯双方都支持，如果存在不支持的响应头域，一般将会作为实体头域处理。\n### 典型的响应消息：\n\n```\nHTTP/1.0200OK\nDate:Mon,31Dec200104:25:57GMT\nServer:Apache/1.3.14(Unix)\nContent-type:text/html\nLast-modified:Tue,17Apr200106:46:28GMT\nEtag:\"a030f020ac7c01:1e9f\"\nContent-length:39725426\nContent-range:bytes55******/40279980\n上例第一行表示HTTP服务端响应一个GET方法。棕色的部分表示响应头域的信息，绿色的部分表示通用头部分，红色的部分表示实体头域的信息。\n```\n#### Location响应头\nLocation响应头用于重定向接收者到一个新URI地址。\n#### Server响应头\nServer响应头包含处理请求的原始服务器的软件信息。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。\n## 实体信息\n请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体头，但是这些域可能无法被接受方识别。实体可以是一个经过编码的字节流，它的编码方式由Content-Encoding或Content-Type定义，它的长度由Content-Length或Content-Range定义。\n### Content-Type实体头\nContent-Type实体头用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型\n### Content-Range实体头\nContent-Range实体头用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式：\nContent-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth\n例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围，Content-Length表示实际传送的字节数。\n### Last-modified实体头\nLast-modified实体头指定服务器上保存内容的最后修订时间。\n例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围，Content-Length表示实际传送的字节数。\n\n```熟悉HTTP是web工程师的基本功```\n","source":"_posts/HTTP协议详解.md","raw":"---\ntitle: HTTP协议详解\ndate: 2016-03-30 21:02:31\ncategories: web\ntags: [爬虫, web, HTTP]\n\n---\n# HTTP协议详解\n这是一篇想写了很久却迟迟没有动笔的题目\n\n从开始接触爬虫，或者说接触web开始，你就是在和http协议打交道了，我想web这个职业只要http协议不过时应该就不会有太大的变化。\n<!-- more -->\n好，下面是正文:\n\n----\n先说说HTTP协议是怎样工作的：\n步骤1：浏览器首先向服务器发送HTTP请求，请求包括：\n\n方法：GET还是POST，GET仅请求资源，POST会附带用户数据；\n\n路径：/full/url/path；\n\n域名：由Host头指定：Host: www.sina.com.cn\n\n以及其他相关的Header；\n\n如果是POST，那么请求还包括一个Body，包含用户数据。\n\n步骤2：服务器向浏览器返回HTTP响应，响应包括：\n\n响应代码：200表示成功，3xx表示重定向，4xx表示客户端发送的请求有错误，5xx表示服务器端处理时发生了错误；\n\n响应类型：由Content-Type指定；\n\n以及其他相关的Header；\n\n通常服务器的HTTP响应会携带内容，也就是有一个Body，包含响应的内容，网页的HTML源码就在Body中。\n\n步骤3：如果浏览器还需要继续向服务器请求其他资源，比如图片，就再次发出HTTP请求，重复步骤1、2。\n\nWeb采用的HTTP协议采用了非常简单的请求-响应模式，从而大大简化了开发。当我们编写一个页面时，我们只需要在HTTP请求中把HTML发送出去，不需要考虑如何附带图片、视频等，浏览器如果需要请求图片和视频，它会发送另一个HTTP请求，因此，一个HTTP请求只处理一个资源。\n\nHTTP协议同时具备极强的扩展性，虽然浏览器请求的是 http://www.sina.com.cn/ 的首页，但是新浪在HTML中可以链入其他服务器的资源，比如\n```\n<img src=\"http://i1.sinaimg.cn/home/2013/1008/U8455P30DT20131008135420.png\">\n```\n\n，从而将请求压力分散到各个服务器上，并且，一个站点可以链接到其他站点，无数个站点互相链接起来，就形成了World Wide Web，简称WWW。\n\n\n----\n\n## 超文本传输协议\nhttp就是用于规范客户端和服务器之间文本传输的一个协议，我们在访问网站的时候大多数时候都是通过这个协议从服务器上获取想要的数据的。\n### 从get方法和post方法谈起\n最早让我想要弄清楚HTTP协议是源于我在写爬虫的时候使用python的requests模块，经常会弄不清楚到底该用get方法还是post方法，比较通俗的说法是post方法比较安全，可以带data，get方法就是url请求，请求体全部都暴露在url里面，较不安全，然而研究后发现，HTTP的四种方法get,post,put,delete方法并没有本质上的区别，协议本身并没有强制规范什么情况下必须使用什么请求，事实上这几种请求方法的格式是一样的。\n### 请求方法\n请求方法（所有方法全为大写）有多种，各个方法的解释如下：\n\n\tGET     请求获取Request-URI所标识的资源\n\tPOST    在Request-URI所标识的资源后附加新的数据\n\tHEAD    请求获取由Request-URI所标识的资源的响应消息报头\n\tPUT     请求服务器存储一个资源，并用Request-URI作为其标识\n\tDELETE  请求服务器删除Request-URI所标识的资源\n\tTRACE   请求服务器回送收到的请求信息，主要用于测试或诊断\n\tCONNECT 保留将来使用\t\n\tOPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求\n\n## header\n### General Header（通用头）\nHTTP里的通用头既可以包含在请求头中也可以包含在响应头中，作用主要是描述HTTO协议本身，下面举例几个常见的通用头：\n#### Cache-Control头域\nCache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下：\n> * Public指示响应可被任何缓存区缓存。\n> * Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。\n> * no-cache指示请求或响应消息不能缓存\n> * no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。\n> * max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。\n> * min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。\n> * max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。\n\n#### HTTP Keep-Alive\nKeep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。市场上的大部分Web服务器，包括iPlanet、IIS和Apache，都支持HTTP Keep-Alive。对于提供静态内容的网站来说，这个功能通常很有用。但是，对于负担较重的网站来说，这里存在另外一个问题：虽然为客户保留打开的连接有一定的好处，但它同样影响了性能，因为在处理暂停期间，本来可以释放的资源仍旧被占用。当Web服务器和应用服务器在同一台机器上运行时，Keep- Alive功能对资源利用的影响尤其突出。\nKeepAliveTime 值控制 TCP/IP 尝试验证空闲连接是否完好的频率。如果这段时间内没有活动，则会发送保持活动信号。如果网络工作正常，而且接收方是活动的，它就会响应。如果需要对丢失接收方敏感，换句话说，需要更快地发现丢失了接收方，请考虑减小这个值。如果长期不活动的空闲连接出现次数较多，而丢失接收方的情况出现较少，您可能会要提高该值以减少开销。缺省情况下，如果空闲连接 7200000 毫秒（2 小时）内没有活动，Windows 就发送保持活动的消息。通常，1800000 毫秒是首选值，从而一半的已关闭连接会在 30 分钟内被检测到。 KeepAliveInterval 值定义了如果未从接收方收到保持活动消息的响应，TCP/IP 重复发送保持活动信号的频率。当连续发送保持活动信号、但未收到响应的次数超出 TcpMaxDataRetransmissions 的值时，会放弃该连接。如果期望较长的响应时间，您可能需要提高该值以减少开销。如果需要减少花在验证接收方是否已丢失上的时间，请考虑减小该值或 TcpMaxDataRetransmissions 值。缺省情况下，在未收到响应而重新发送保持活动的消息之前，Windows 会等待 1000 毫秒（1 秒）。 KeepAliveTime 根据你的需要设置就行，比如10分钟，注意要转换成MS。 XXX代表这个间隔值得大小。\n#### Date头域\nDate头域表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。\n#### Pragma头域\nPragma头域用来包含实现特定的指令，最常用的是Pragma:no-cache。在HTTP/1.1协议中，它的含义和Cache-Control:no-cache相同。\n### Entity header(实体头)\n请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体头，但是这些域可能无法被接受方识别。实体可以是一个经过编码的字节流，它的编码方式由Content-Encoding或Content-Type定义，它的长度由Content-Length或Content-Range定义。\n#### Content-Type实体头\nContent-Type实体头用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型\n#### Content-Range实体头\nContent-Range实体头用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式：\nContent-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth\n例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围，Content-Length表示实际传送的字节数。\n#### Last-modified实体头\nLast-modified实体头指定服务器上保存内容的最后修订时间。\n例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围，Content-Length表示实际传送的字节数。\n### HTTP Request Header（请求头）\n这就是我们最常见的header了，请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。\n以下为常见的请求报头：\n#### Accept\nAccept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。\n\n#### Accept-Charset\nAccept-Charset请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。\n\n#### Accept-Encoding\nAccept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。\n\n#### Accept-Language\nAccept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。\n\n#### Authorization\nAuthorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。\n\n#### Host（发送请求时，该报头域是必需的）\nHost请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，eg：\n我们在浏览器中输入：http://www.guet.edu.cn/index.html\n浏览器发送的请求消息中，就会包含Host请求报头域，如下：\nHost：www.guet.edu.cn\n此处使用缺省端口号80，若指定了端口号，则变成：Host：www.guet.edu.cn:指定端口号\n#### Referer头域\nReferer头域允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等。他也允许废除的或错误的连接由于维护的目的被追踪。如果请求的uri没有自己的uri地址，Referer不能被发送。如果指定的是部分uri地址，则此地址应该是一个相对地址。\n\n#### User-Agent\n我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。\n\n请求报头举例：\n\n```\nGET /form.html HTTP/1.1 (CRLF)\nAccept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,*/* (CRLF)\nAccept-Language:zh-cn (CRLF)\nAccept-Encoding:gzip,deflate (CRLF)\nIf-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)\nIf-None-Match:W/\"80b1a4c018f3c41:8317\" (CRLF)\nUser-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)\nHost:www.guet.edu.cn (CRLF)\nConnection:Keep-Alive (CRLF)\n(CRLF)\n\n```\n\n## body\nbody包涵请求的实体。\n\n\n## Response\n### 状态码\n响应消息的第一行为下面的格式：\nHTTP-VersionSPStatus-CodeSPReason-PhraseCRLF\nHTTP-Version表示支持的HTTP版本，例如为HTTP/1.1。Status-Code是一个三个数字的结果代码。Reason-Phrase给Status-Code提供一个简单的文本描述。Status-Code主要用于机器自动识别，Reason-Phrase主要用于帮助用户理解。Status-Code的第一个数字定义响应的类别，后两个数字没有分类的作用。第一个数字可能取5个不同的值：\n1xx:信息响应类，表示接收到请求并且继续处理\n2xx:处理成功响应类，表示动作被成功接收、理解和接受\n3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理\n4xx:客户端错误，客户请求包含语法错误或者是不能正确执行\n5xx:服务端错误，服务器不能正确执行一个正确的请求\n### 响应头\n响应头域允许服务器传递不能放在状态行的附加信息，这些域主要描述服务器的信息和Request-URI进一步的信息。响应头域包含Age、Location、Proxy-Authenticate、Public、Retry-After、Server、Vary、Warning、WWW-Authenticate。对响应头域的扩展要求通讯双方都支持，如果存在不支持的响应头域，一般将会作为实体头域处理。\n### 典型的响应消息：\n\n```\nHTTP/1.0200OK\nDate:Mon,31Dec200104:25:57GMT\nServer:Apache/1.3.14(Unix)\nContent-type:text/html\nLast-modified:Tue,17Apr200106:46:28GMT\nEtag:\"a030f020ac7c01:1e9f\"\nContent-length:39725426\nContent-range:bytes55******/40279980\n上例第一行表示HTTP服务端响应一个GET方法。棕色的部分表示响应头域的信息，绿色的部分表示通用头部分，红色的部分表示实体头域的信息。\n```\n#### Location响应头\nLocation响应头用于重定向接收者到一个新URI地址。\n#### Server响应头\nServer响应头包含处理请求的原始服务器的软件信息。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。\n## 实体信息\n请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体头，但是这些域可能无法被接受方识别。实体可以是一个经过编码的字节流，它的编码方式由Content-Encoding或Content-Type定义，它的长度由Content-Length或Content-Range定义。\n### Content-Type实体头\nContent-Type实体头用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型\n### Content-Range实体头\nContent-Range实体头用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式：\nContent-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth\n例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围，Content-Length表示实际传送的字节数。\n### Last-modified实体头\nLast-modified实体头指定服务器上保存内容的最后修订时间。\n例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围，Content-Length表示实际传送的字节数。\n\n```熟悉HTTP是web工程师的基本功```\n","slug":"HTTP协议详解","published":1,"updated":"2016-06-28T11:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzgzejv0002egfyjykery5x","content":"<h1 id=\"HTTP协议详解\"><a href=\"#HTTP协议详解\" class=\"headerlink\" title=\"HTTP协议详解\"></a>HTTP协议详解</h1><p>这是一篇想写了很久却迟迟没有动笔的题目</p>\n<p>从开始接触爬虫，或者说接触web开始，你就是在和http协议打交道了，我想web这个职业只要http协议不过时应该就不会有太大的变化。<br><a id=\"more\"></a><br>好，下面是正文:</p>\n<hr>\n<p>先说说HTTP协议是怎样工作的：<br>步骤1：浏览器首先向服务器发送HTTP请求，请求包括：</p>\n<p>方法：GET还是POST，GET仅请求资源，POST会附带用户数据；</p>\n<p>路径：/full/url/path；</p>\n<p>域名：由Host头指定：Host: www.sina.com.cn</p>\n<p>以及其他相关的Header；</p>\n<p>如果是POST，那么请求还包括一个Body，包含用户数据。</p>\n<p>步骤2：服务器向浏览器返回HTTP响应，响应包括：</p>\n<p>响应代码：200表示成功，3xx表示重定向，4xx表示客户端发送的请求有错误，5xx表示服务器端处理时发生了错误；</p>\n<p>响应类型：由Content-Type指定；</p>\n<p>以及其他相关的Header；</p>\n<p>通常服务器的HTTP响应会携带内容，也就是有一个Body，包含响应的内容，网页的HTML源码就在Body中。</p>\n<p>步骤3：如果浏览器还需要继续向服务器请求其他资源，比如图片，就再次发出HTTP请求，重复步骤1、2。</p>\n<p>Web采用的HTTP协议采用了非常简单的请求-响应模式，从而大大简化了开发。当我们编写一个页面时，我们只需要在HTTP请求中把HTML发送出去，不需要考虑如何附带图片、视频等，浏览器如果需要请求图片和视频，它会发送另一个HTTP请求，因此，一个HTTP请求只处理一个资源。</p>\n<p>HTTP协议同时具备极强的扩展性，虽然浏览器请求的是 <a href=\"http://www.sina.com.cn/\" target=\"_blank\" rel=\"external\">http://www.sina.com.cn/</a> 的首页，但是新浪在HTML中可以链入其他服务器的资源，比如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img src=&quot;http://i1.sinaimg.cn/home/2013/1008/U8455P30DT20131008135420.png&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>，从而将请求压力分散到各个服务器上，并且，一个站点可以链接到其他站点，无数个站点互相链接起来，就形成了World Wide Web，简称WWW。</p>\n<hr>\n<h2 id=\"超文本传输协议\"><a href=\"#超文本传输协议\" class=\"headerlink\" title=\"超文本传输协议\"></a>超文本传输协议</h2><p>http就是用于规范客户端和服务器之间文本传输的一个协议，我们在访问网站的时候大多数时候都是通过这个协议从服务器上获取想要的数据的。</p>\n<h3 id=\"从get方法和post方法谈起\"><a href=\"#从get方法和post方法谈起\" class=\"headerlink\" title=\"从get方法和post方法谈起\"></a>从get方法和post方法谈起</h3><p>最早让我想要弄清楚HTTP协议是源于我在写爬虫的时候使用python的requests模块，经常会弄不清楚到底该用get方法还是post方法，比较通俗的说法是post方法比较安全，可以带data，get方法就是url请求，请求体全部都暴露在url里面，较不安全，然而研究后发现，HTTP的四种方法get,post,put,delete方法并没有本质上的区别，协议本身并没有强制规范什么情况下必须使用什么请求，事实上这几种请求方法的格式是一样的。</p>\n<h3 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h3><p>请求方法（所有方法全为大写）有多种，各个方法的解释如下：</p>\n<pre><code>GET     请求获取Request-URI所标识的资源\nPOST    在Request-URI所标识的资源后附加新的数据\nHEAD    请求获取由Request-URI所标识的资源的响应消息报头\nPUT     请求服务器存储一个资源，并用Request-URI作为其标识\nDELETE  请求服务器删除Request-URI所标识的资源\nTRACE   请求服务器回送收到的请求信息，主要用于测试或诊断\nCONNECT 保留将来使用    \nOPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求\n</code></pre><h2 id=\"header\"><a href=\"#header\" class=\"headerlink\" title=\"header\"></a>header</h2><h3 id=\"General-Header（通用头）\"><a href=\"#General-Header（通用头）\" class=\"headerlink\" title=\"General Header（通用头）\"></a>General Header（通用头）</h3><p>HTTP里的通用头既可以包含在请求头中也可以包含在响应头中，作用主要是描述HTTO协议本身，下面举例几个常见的通用头：</p>\n<h4 id=\"Cache-Control头域\"><a href=\"#Cache-Control头域\" class=\"headerlink\" title=\"Cache-Control头域\"></a>Cache-Control头域</h4><p>Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下：</p>\n<blockquote>\n<ul>\n<li>Public指示响应可被任何缓存区缓存。</li>\n<li>Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。</li>\n<li>no-cache指示请求或响应消息不能缓存</li>\n<li>no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。</li>\n<li>max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。</li>\n<li>min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。</li>\n<li>max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</li>\n</ul>\n</blockquote>\n<h4 id=\"HTTP-Keep-Alive\"><a href=\"#HTTP-Keep-Alive\" class=\"headerlink\" title=\"HTTP Keep-Alive\"></a>HTTP Keep-Alive</h4><p>Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。市场上的大部分Web服务器，包括iPlanet、IIS和Apache，都支持HTTP Keep-Alive。对于提供静态内容的网站来说，这个功能通常很有用。但是，对于负担较重的网站来说，这里存在另外一个问题：虽然为客户保留打开的连接有一定的好处，但它同样影响了性能，因为在处理暂停期间，本来可以释放的资源仍旧被占用。当Web服务器和应用服务器在同一台机器上运行时，Keep- Alive功能对资源利用的影响尤其突出。<br>KeepAliveTime 值控制 TCP/IP 尝试验证空闲连接是否完好的频率。如果这段时间内没有活动，则会发送保持活动信号。如果网络工作正常，而且接收方是活动的，它就会响应。如果需要对丢失接收方敏感，换句话说，需要更快地发现丢失了接收方，请考虑减小这个值。如果长期不活动的空闲连接出现次数较多，而丢失接收方的情况出现较少，您可能会要提高该值以减少开销。缺省情况下，如果空闲连接 7200000 毫秒（2 小时）内没有活动，Windows 就发送保持活动的消息。通常，1800000 毫秒是首选值，从而一半的已关闭连接会在 30 分钟内被检测到。 KeepAliveInterval 值定义了如果未从接收方收到保持活动消息的响应，TCP/IP 重复发送保持活动信号的频率。当连续发送保持活动信号、但未收到响应的次数超出 TcpMaxDataRetransmissions 的值时，会放弃该连接。如果期望较长的响应时间，您可能需要提高该值以减少开销。如果需要减少花在验证接收方是否已丢失上的时间，请考虑减小该值或 TcpMaxDataRetransmissions 值。缺省情况下，在未收到响应而重新发送保持活动的消息之前，Windows 会等待 1000 毫秒（1 秒）。 KeepAliveTime 根据你的需要设置就行，比如10分钟，注意要转换成MS。 XXX代表这个间隔值得大小。</p>\n<h4 id=\"Date头域\"><a href=\"#Date头域\" class=\"headerlink\" title=\"Date头域\"></a>Date头域</h4><p>Date头域表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。</p>\n<h4 id=\"Pragma头域\"><a href=\"#Pragma头域\" class=\"headerlink\" title=\"Pragma头域\"></a>Pragma头域</h4><p>Pragma头域用来包含实现特定的指令，最常用的是Pragma:no-cache。在HTTP/1.1协议中，它的含义和Cache-Control:no-cache相同。</p>\n<h3 id=\"Entity-header-实体头\"><a href=\"#Entity-header-实体头\" class=\"headerlink\" title=\"Entity header(实体头)\"></a>Entity header(实体头)</h3><p>请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体头，但是这些域可能无法被接受方识别。实体可以是一个经过编码的字节流，它的编码方式由Content-Encoding或Content-Type定义，它的长度由Content-Length或Content-Range定义。</p>\n<h4 id=\"Content-Type实体头\"><a href=\"#Content-Type实体头\" class=\"headerlink\" title=\"Content-Type实体头\"></a>Content-Type实体头</h4><p>Content-Type实体头用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型</p>\n<h4 id=\"Content-Range实体头\"><a href=\"#Content-Range实体头\" class=\"headerlink\" title=\"Content-Range实体头\"></a>Content-Range实体头</h4><p>Content-Range实体头用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式：<br>Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth<br>例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围，Content-Length表示实际传送的字节数。</p>\n<h4 id=\"Last-modified实体头\"><a href=\"#Last-modified实体头\" class=\"headerlink\" title=\"Last-modified实体头\"></a>Last-modified实体头</h4><p>Last-modified实体头指定服务器上保存内容的最后修订时间。<br>例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围，Content-Length表示实际传送的字节数。</p>\n<h3 id=\"HTTP-Request-Header（请求头）\"><a href=\"#HTTP-Request-Header（请求头）\" class=\"headerlink\" title=\"HTTP Request Header（请求头）\"></a>HTTP Request Header（请求头）</h3><p>这就是我们最常见的header了，请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。<br>以下为常见的请求报头：</p>\n<h4 id=\"Accept\"><a href=\"#Accept\" class=\"headerlink\" title=\"Accept\"></a>Accept</h4><p>Accept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。</p>\n<h4 id=\"Accept-Charset\"><a href=\"#Accept-Charset\" class=\"headerlink\" title=\"Accept-Charset\"></a>Accept-Charset</h4><p>Accept-Charset请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。</p>\n<h4 id=\"Accept-Encoding\"><a href=\"#Accept-Encoding\" class=\"headerlink\" title=\"Accept-Encoding\"></a>Accept-Encoding</h4><p>Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。</p>\n<h4 id=\"Accept-Language\"><a href=\"#Accept-Language\" class=\"headerlink\" title=\"Accept-Language\"></a>Accept-Language</h4><p>Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。</p>\n<h4 id=\"Authorization\"><a href=\"#Authorization\" class=\"headerlink\" title=\"Authorization\"></a>Authorization</h4><p>Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。</p>\n<h4 id=\"Host（发送请求时，该报头域是必需的）\"><a href=\"#Host（发送请求时，该报头域是必需的）\" class=\"headerlink\" title=\"Host（发送请求时，该报头域是必需的）\"></a>Host（发送请求时，该报头域是必需的）</h4><p>Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，eg：<br>我们在浏览器中输入：<a href=\"http://www.guet.edu.cn/index.html\" target=\"_blank\" rel=\"external\">http://www.guet.edu.cn/index.html</a><br>浏览器发送的请求消息中，就会包含Host请求报头域，如下：<br>Host：www.guet.edu.cn<br>此处使用缺省端口号80，若指定了端口号，则变成：Host：www.guet.edu.cn:指定端口号</p>\n<h4 id=\"Referer头域\"><a href=\"#Referer头域\" class=\"headerlink\" title=\"Referer头域\"></a>Referer头域</h4><p>Referer头域允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等。他也允许废除的或错误的连接由于维护的目的被追踪。如果请求的uri没有自己的uri地址，Referer不能被发送。如果指定的是部分uri地址，则此地址应该是一个相对地址。</p>\n<h4 id=\"User-Agent\"><a href=\"#User-Agent\" class=\"headerlink\" title=\"User-Agent\"></a>User-Agent</h4><p>我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。</p>\n<p>请求报头举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /form.html HTTP/1.1 (CRLF)</span><br><span class=\"line\">Accept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,*/* (CRLF)</span><br><span class=\"line\">Accept-Language:zh-cn (CRLF)</span><br><span class=\"line\">Accept-Encoding:gzip,deflate (CRLF)</span><br><span class=\"line\">If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)</span><br><span class=\"line\">If-None-Match:W/&quot;80b1a4c018f3c41:8317&quot; (CRLF)</span><br><span class=\"line\">User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)</span><br><span class=\"line\">Host:www.guet.edu.cn (CRLF)</span><br><span class=\"line\">Connection:Keep-Alive (CRLF)</span><br><span class=\"line\">(CRLF)</span><br></pre></td></tr></table></figure>\n<h2 id=\"body\"><a href=\"#body\" class=\"headerlink\" title=\"body\"></a>body</h2><p>body包涵请求的实体。</p>\n<h2 id=\"Response\"><a href=\"#Response\" class=\"headerlink\" title=\"Response\"></a>Response</h2><h3 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h3><p>响应消息的第一行为下面的格式：<br>HTTP-VersionSPStatus-CodeSPReason-PhraseCRLF<br>HTTP-Version表示支持的HTTP版本，例如为HTTP/1.1。Status-Code是一个三个数字的结果代码。Reason-Phrase给Status-Code提供一个简单的文本描述。Status-Code主要用于机器自动识别，Reason-Phrase主要用于帮助用户理解。Status-Code的第一个数字定义响应的类别，后两个数字没有分类的作用。第一个数字可能取5个不同的值：<br>1xx:信息响应类，表示接收到请求并且继续处理<br>2xx:处理成功响应类，表示动作被成功接收、理解和接受<br>3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理<br>4xx:客户端错误，客户请求包含语法错误或者是不能正确执行<br>5xx:服务端错误，服务器不能正确执行一个正确的请求</p>\n<h3 id=\"响应头\"><a href=\"#响应头\" class=\"headerlink\" title=\"响应头\"></a>响应头</h3><p>响应头域允许服务器传递不能放在状态行的附加信息，这些域主要描述服务器的信息和Request-URI进一步的信息。响应头域包含Age、Location、Proxy-Authenticate、Public、Retry-After、Server、Vary、Warning、WWW-Authenticate。对响应头域的扩展要求通讯双方都支持，如果存在不支持的响应头域，一般将会作为实体头域处理。</p>\n<h3 id=\"典型的响应消息：\"><a href=\"#典型的响应消息：\" class=\"headerlink\" title=\"典型的响应消息：\"></a>典型的响应消息：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.0200OK</span><br><span class=\"line\">Date:Mon,31Dec200104:25:57GMT</span><br><span class=\"line\">Server:Apache/1.3.14(Unix)</span><br><span class=\"line\">Content-type:text/html</span><br><span class=\"line\">Last-modified:Tue,17Apr200106:46:28GMT</span><br><span class=\"line\">Etag:&quot;a030f020ac7c01:1e9f&quot;</span><br><span class=\"line\">Content-length:39725426</span><br><span class=\"line\">Content-range:bytes55******/40279980</span><br><span class=\"line\">上例第一行表示HTTP服务端响应一个GET方法。棕色的部分表示响应头域的信息，绿色的部分表示通用头部分，红色的部分表示实体头域的信息。</span><br></pre></td></tr></table></figure>\n<h4 id=\"Location响应头\"><a href=\"#Location响应头\" class=\"headerlink\" title=\"Location响应头\"></a>Location响应头</h4><p>Location响应头用于重定向接收者到一个新URI地址。</p>\n<h4 id=\"Server响应头\"><a href=\"#Server响应头\" class=\"headerlink\" title=\"Server响应头\"></a>Server响应头</h4><p>Server响应头包含处理请求的原始服务器的软件信息。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。</p>\n<h2 id=\"实体信息\"><a href=\"#实体信息\" class=\"headerlink\" title=\"实体信息\"></a>实体信息</h2><p>请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体头，但是这些域可能无法被接受方识别。实体可以是一个经过编码的字节流，它的编码方式由Content-Encoding或Content-Type定义，它的长度由Content-Length或Content-Range定义。</p>\n<h3 id=\"Content-Type实体头-1\"><a href=\"#Content-Type实体头-1\" class=\"headerlink\" title=\"Content-Type实体头\"></a>Content-Type实体头</h3><p>Content-Type实体头用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型</p>\n<h3 id=\"Content-Range实体头-1\"><a href=\"#Content-Range实体头-1\" class=\"headerlink\" title=\"Content-Range实体头\"></a>Content-Range实体头</h3><p>Content-Range实体头用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式：<br>Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth<br>例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围，Content-Length表示实际传送的字节数。</p>\n<h3 id=\"Last-modified实体头-1\"><a href=\"#Last-modified实体头-1\" class=\"headerlink\" title=\"Last-modified实体头\"></a>Last-modified实体头</h3><p>Last-modified实体头指定服务器上保存内容的最后修订时间。<br>例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围，Content-Length表示实际传送的字节数。</p>\n<p><code>熟悉HTTP是web工程师的基本功</code></p>\n","excerpt":"<h1 id=\"HTTP协议详解\"><a href=\"#HTTP协议详解\" class=\"headerlink\" title=\"HTTP协议详解\"></a>HTTP协议详解</h1><p>这是一篇想写了很久却迟迟没有动笔的题目</p>\n<p>从开始接触爬虫，或者说接触web开始，你就是在和http协议打交道了，我想web这个职业只要http协议不过时应该就不会有太大的变化。<br>","more":"<br>好，下面是正文:</p>\n<hr>\n<p>先说说HTTP协议是怎样工作的：<br>步骤1：浏览器首先向服务器发送HTTP请求，请求包括：</p>\n<p>方法：GET还是POST，GET仅请求资源，POST会附带用户数据；</p>\n<p>路径：/full/url/path；</p>\n<p>域名：由Host头指定：Host: www.sina.com.cn</p>\n<p>以及其他相关的Header；</p>\n<p>如果是POST，那么请求还包括一个Body，包含用户数据。</p>\n<p>步骤2：服务器向浏览器返回HTTP响应，响应包括：</p>\n<p>响应代码：200表示成功，3xx表示重定向，4xx表示客户端发送的请求有错误，5xx表示服务器端处理时发生了错误；</p>\n<p>响应类型：由Content-Type指定；</p>\n<p>以及其他相关的Header；</p>\n<p>通常服务器的HTTP响应会携带内容，也就是有一个Body，包含响应的内容，网页的HTML源码就在Body中。</p>\n<p>步骤3：如果浏览器还需要继续向服务器请求其他资源，比如图片，就再次发出HTTP请求，重复步骤1、2。</p>\n<p>Web采用的HTTP协议采用了非常简单的请求-响应模式，从而大大简化了开发。当我们编写一个页面时，我们只需要在HTTP请求中把HTML发送出去，不需要考虑如何附带图片、视频等，浏览器如果需要请求图片和视频，它会发送另一个HTTP请求，因此，一个HTTP请求只处理一个资源。</p>\n<p>HTTP协议同时具备极强的扩展性，虽然浏览器请求的是 <a href=\"http://www.sina.com.cn/\">http://www.sina.com.cn/</a> 的首页，但是新浪在HTML中可以链入其他服务器的资源，比如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img src=&quot;http://i1.sinaimg.cn/home/2013/1008/U8455P30DT20131008135420.png&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>，从而将请求压力分散到各个服务器上，并且，一个站点可以链接到其他站点，无数个站点互相链接起来，就形成了World Wide Web，简称WWW。</p>\n<hr>\n<h2 id=\"超文本传输协议\"><a href=\"#超文本传输协议\" class=\"headerlink\" title=\"超文本传输协议\"></a>超文本传输协议</h2><p>http就是用于规范客户端和服务器之间文本传输的一个协议，我们在访问网站的时候大多数时候都是通过这个协议从服务器上获取想要的数据的。</p>\n<h3 id=\"从get方法和post方法谈起\"><a href=\"#从get方法和post方法谈起\" class=\"headerlink\" title=\"从get方法和post方法谈起\"></a>从get方法和post方法谈起</h3><p>最早让我想要弄清楚HTTP协议是源于我在写爬虫的时候使用python的requests模块，经常会弄不清楚到底该用get方法还是post方法，比较通俗的说法是post方法比较安全，可以带data，get方法就是url请求，请求体全部都暴露在url里面，较不安全，然而研究后发现，HTTP的四种方法get,post,put,delete方法并没有本质上的区别，协议本身并没有强制规范什么情况下必须使用什么请求，事实上这几种请求方法的格式是一样的。</p>\n<h3 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h3><p>请求方法（所有方法全为大写）有多种，各个方法的解释如下：</p>\n<pre><code>GET     请求获取Request-URI所标识的资源\nPOST    在Request-URI所标识的资源后附加新的数据\nHEAD    请求获取由Request-URI所标识的资源的响应消息报头\nPUT     请求服务器存储一个资源，并用Request-URI作为其标识\nDELETE  请求服务器删除Request-URI所标识的资源\nTRACE   请求服务器回送收到的请求信息，主要用于测试或诊断\nCONNECT 保留将来使用    \nOPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求\n</code></pre><h2 id=\"header\"><a href=\"#header\" class=\"headerlink\" title=\"header\"></a>header</h2><h3 id=\"General-Header（通用头）\"><a href=\"#General-Header（通用头）\" class=\"headerlink\" title=\"General Header（通用头）\"></a>General Header（通用头）</h3><p>HTTP里的通用头既可以包含在请求头中也可以包含在响应头中，作用主要是描述HTTO协议本身，下面举例几个常见的通用头：</p>\n<h4 id=\"Cache-Control头域\"><a href=\"#Cache-Control头域\" class=\"headerlink\" title=\"Cache-Control头域\"></a>Cache-Control头域</h4><p>Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下：</p>\n<blockquote>\n<ul>\n<li>Public指示响应可被任何缓存区缓存。</li>\n<li>Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。</li>\n<li>no-cache指示请求或响应消息不能缓存</li>\n<li>no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。</li>\n<li>max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。</li>\n<li>min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。</li>\n<li>max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</li>\n</ul>\n</blockquote>\n<h4 id=\"HTTP-Keep-Alive\"><a href=\"#HTTP-Keep-Alive\" class=\"headerlink\" title=\"HTTP Keep-Alive\"></a>HTTP Keep-Alive</h4><p>Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。市场上的大部分Web服务器，包括iPlanet、IIS和Apache，都支持HTTP Keep-Alive。对于提供静态内容的网站来说，这个功能通常很有用。但是，对于负担较重的网站来说，这里存在另外一个问题：虽然为客户保留打开的连接有一定的好处，但它同样影响了性能，因为在处理暂停期间，本来可以释放的资源仍旧被占用。当Web服务器和应用服务器在同一台机器上运行时，Keep- Alive功能对资源利用的影响尤其突出。<br>KeepAliveTime 值控制 TCP/IP 尝试验证空闲连接是否完好的频率。如果这段时间内没有活动，则会发送保持活动信号。如果网络工作正常，而且接收方是活动的，它就会响应。如果需要对丢失接收方敏感，换句话说，需要更快地发现丢失了接收方，请考虑减小这个值。如果长期不活动的空闲连接出现次数较多，而丢失接收方的情况出现较少，您可能会要提高该值以减少开销。缺省情况下，如果空闲连接 7200000 毫秒（2 小时）内没有活动，Windows 就发送保持活动的消息。通常，1800000 毫秒是首选值，从而一半的已关闭连接会在 30 分钟内被检测到。 KeepAliveInterval 值定义了如果未从接收方收到保持活动消息的响应，TCP/IP 重复发送保持活动信号的频率。当连续发送保持活动信号、但未收到响应的次数超出 TcpMaxDataRetransmissions 的值时，会放弃该连接。如果期望较长的响应时间，您可能需要提高该值以减少开销。如果需要减少花在验证接收方是否已丢失上的时间，请考虑减小该值或 TcpMaxDataRetransmissions 值。缺省情况下，在未收到响应而重新发送保持活动的消息之前，Windows 会等待 1000 毫秒（1 秒）。 KeepAliveTime 根据你的需要设置就行，比如10分钟，注意要转换成MS。 XXX代表这个间隔值得大小。</p>\n<h4 id=\"Date头域\"><a href=\"#Date头域\" class=\"headerlink\" title=\"Date头域\"></a>Date头域</h4><p>Date头域表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。</p>\n<h4 id=\"Pragma头域\"><a href=\"#Pragma头域\" class=\"headerlink\" title=\"Pragma头域\"></a>Pragma头域</h4><p>Pragma头域用来包含实现特定的指令，最常用的是Pragma:no-cache。在HTTP/1.1协议中，它的含义和Cache-Control:no-cache相同。</p>\n<h3 id=\"Entity-header-实体头\"><a href=\"#Entity-header-实体头\" class=\"headerlink\" title=\"Entity header(实体头)\"></a>Entity header(实体头)</h3><p>请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体头，但是这些域可能无法被接受方识别。实体可以是一个经过编码的字节流，它的编码方式由Content-Encoding或Content-Type定义，它的长度由Content-Length或Content-Range定义。</p>\n<h4 id=\"Content-Type实体头\"><a href=\"#Content-Type实体头\" class=\"headerlink\" title=\"Content-Type实体头\"></a>Content-Type实体头</h4><p>Content-Type实体头用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型</p>\n<h4 id=\"Content-Range实体头\"><a href=\"#Content-Range实体头\" class=\"headerlink\" title=\"Content-Range实体头\"></a>Content-Range实体头</h4><p>Content-Range实体头用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式：<br>Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth<br>例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围，Content-Length表示实际传送的字节数。</p>\n<h4 id=\"Last-modified实体头\"><a href=\"#Last-modified实体头\" class=\"headerlink\" title=\"Last-modified实体头\"></a>Last-modified实体头</h4><p>Last-modified实体头指定服务器上保存内容的最后修订时间。<br>例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围，Content-Length表示实际传送的字节数。</p>\n<h3 id=\"HTTP-Request-Header（请求头）\"><a href=\"#HTTP-Request-Header（请求头）\" class=\"headerlink\" title=\"HTTP Request Header（请求头）\"></a>HTTP Request Header（请求头）</h3><p>这就是我们最常见的header了，请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。<br>以下为常见的请求报头：</p>\n<h4 id=\"Accept\"><a href=\"#Accept\" class=\"headerlink\" title=\"Accept\"></a>Accept</h4><p>Accept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。</p>\n<h4 id=\"Accept-Charset\"><a href=\"#Accept-Charset\" class=\"headerlink\" title=\"Accept-Charset\"></a>Accept-Charset</h4><p>Accept-Charset请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。</p>\n<h4 id=\"Accept-Encoding\"><a href=\"#Accept-Encoding\" class=\"headerlink\" title=\"Accept-Encoding\"></a>Accept-Encoding</h4><p>Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。</p>\n<h4 id=\"Accept-Language\"><a href=\"#Accept-Language\" class=\"headerlink\" title=\"Accept-Language\"></a>Accept-Language</h4><p>Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。</p>\n<h4 id=\"Authorization\"><a href=\"#Authorization\" class=\"headerlink\" title=\"Authorization\"></a>Authorization</h4><p>Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。</p>\n<h4 id=\"Host（发送请求时，该报头域是必需的）\"><a href=\"#Host（发送请求时，该报头域是必需的）\" class=\"headerlink\" title=\"Host（发送请求时，该报头域是必需的）\"></a>Host（发送请求时，该报头域是必需的）</h4><p>Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，eg：<br>我们在浏览器中输入：<a href=\"http://www.guet.edu.cn/index.html\">http://www.guet.edu.cn/index.html</a><br>浏览器发送的请求消息中，就会包含Host请求报头域，如下：<br>Host：www.guet.edu.cn<br>此处使用缺省端口号80，若指定了端口号，则变成：Host：www.guet.edu.cn:指定端口号</p>\n<h4 id=\"Referer头域\"><a href=\"#Referer头域\" class=\"headerlink\" title=\"Referer头域\"></a>Referer头域</h4><p>Referer头域允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等。他也允许废除的或错误的连接由于维护的目的被追踪。如果请求的uri没有自己的uri地址，Referer不能被发送。如果指定的是部分uri地址，则此地址应该是一个相对地址。</p>\n<h4 id=\"User-Agent\"><a href=\"#User-Agent\" class=\"headerlink\" title=\"User-Agent\"></a>User-Agent</h4><p>我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。</p>\n<p>请求报头举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /form.html HTTP/1.1 (CRLF)</span><br><span class=\"line\">Accept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,*/* (CRLF)</span><br><span class=\"line\">Accept-Language:zh-cn (CRLF)</span><br><span class=\"line\">Accept-Encoding:gzip,deflate (CRLF)</span><br><span class=\"line\">If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)</span><br><span class=\"line\">If-None-Match:W/&quot;80b1a4c018f3c41:8317&quot; (CRLF)</span><br><span class=\"line\">User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)</span><br><span class=\"line\">Host:www.guet.edu.cn (CRLF)</span><br><span class=\"line\">Connection:Keep-Alive (CRLF)</span><br><span class=\"line\">(CRLF)</span><br></pre></td></tr></table></figure>\n<h2 id=\"body\"><a href=\"#body\" class=\"headerlink\" title=\"body\"></a>body</h2><p>body包涵请求的实体。</p>\n<h2 id=\"Response\"><a href=\"#Response\" class=\"headerlink\" title=\"Response\"></a>Response</h2><h3 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h3><p>响应消息的第一行为下面的格式：<br>HTTP-VersionSPStatus-CodeSPReason-PhraseCRLF<br>HTTP-Version表示支持的HTTP版本，例如为HTTP/1.1。Status-Code是一个三个数字的结果代码。Reason-Phrase给Status-Code提供一个简单的文本描述。Status-Code主要用于机器自动识别，Reason-Phrase主要用于帮助用户理解。Status-Code的第一个数字定义响应的类别，后两个数字没有分类的作用。第一个数字可能取5个不同的值：<br>1xx:信息响应类，表示接收到请求并且继续处理<br>2xx:处理成功响应类，表示动作被成功接收、理解和接受<br>3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理<br>4xx:客户端错误，客户请求包含语法错误或者是不能正确执行<br>5xx:服务端错误，服务器不能正确执行一个正确的请求</p>\n<h3 id=\"响应头\"><a href=\"#响应头\" class=\"headerlink\" title=\"响应头\"></a>响应头</h3><p>响应头域允许服务器传递不能放在状态行的附加信息，这些域主要描述服务器的信息和Request-URI进一步的信息。响应头域包含Age、Location、Proxy-Authenticate、Public、Retry-After、Server、Vary、Warning、WWW-Authenticate。对响应头域的扩展要求通讯双方都支持，如果存在不支持的响应头域，一般将会作为实体头域处理。</p>\n<h3 id=\"典型的响应消息：\"><a href=\"#典型的响应消息：\" class=\"headerlink\" title=\"典型的响应消息：\"></a>典型的响应消息：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.0200OK</span><br><span class=\"line\">Date:Mon,31Dec200104:25:57GMT</span><br><span class=\"line\">Server:Apache/1.3.14(Unix)</span><br><span class=\"line\">Content-type:text/html</span><br><span class=\"line\">Last-modified:Tue,17Apr200106:46:28GMT</span><br><span class=\"line\">Etag:&quot;a030f020ac7c01:1e9f&quot;</span><br><span class=\"line\">Content-length:39725426</span><br><span class=\"line\">Content-range:bytes55******/40279980</span><br><span class=\"line\">上例第一行表示HTTP服务端响应一个GET方法。棕色的部分表示响应头域的信息，绿色的部分表示通用头部分，红色的部分表示实体头域的信息。</span><br></pre></td></tr></table></figure>\n<h4 id=\"Location响应头\"><a href=\"#Location响应头\" class=\"headerlink\" title=\"Location响应头\"></a>Location响应头</h4><p>Location响应头用于重定向接收者到一个新URI地址。</p>\n<h4 id=\"Server响应头\"><a href=\"#Server响应头\" class=\"headerlink\" title=\"Server响应头\"></a>Server响应头</h4><p>Server响应头包含处理请求的原始服务器的软件信息。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。</p>\n<h2 id=\"实体信息\"><a href=\"#实体信息\" class=\"headerlink\" title=\"实体信息\"></a>实体信息</h2><p>请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体头，但是这些域可能无法被接受方识别。实体可以是一个经过编码的字节流，它的编码方式由Content-Encoding或Content-Type定义，它的长度由Content-Length或Content-Range定义。</p>\n<h3 id=\"Content-Type实体头-1\"><a href=\"#Content-Type实体头-1\" class=\"headerlink\" title=\"Content-Type实体头\"></a>Content-Type实体头</h3><p>Content-Type实体头用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型</p>\n<h3 id=\"Content-Range实体头-1\"><a href=\"#Content-Range实体头-1\" class=\"headerlink\" title=\"Content-Range实体头\"></a>Content-Range实体头</h3><p>Content-Range实体头用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式：<br>Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth<br>例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围，Content-Length表示实际传送的字节数。</p>\n<h3 id=\"Last-modified实体头-1\"><a href=\"#Last-modified实体头-1\" class=\"headerlink\" title=\"Last-modified实体头\"></a>Last-modified实体头</h3><p>Last-modified实体头指定服务器上保存内容的最后修订时间。<br>例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围，Content-Length表示实际传送的字节数。</p>\n<p><code>熟悉HTTP是web工程师的基本功</code></p>"},{"title":"RDBMS和NOSQL的技术差别","date":"2016-04-20T02:01:24.000Z","_content":"# RDBMS和NOSQL的技术差别\n创新的背后往往会刺激痛苦。这一点在PDD(我们亲切地称为痛处驱动开发)软件开发领域尤为真实。从上世纪80年代以来，我们就都知道如何处理关系型数据——只要把数据放到关系型数据库管理系统(RDBMS)中，就可以使用SQL语句操作数据。然而，在过去几年来，我们的行业采纳NoSQL数据库的趋势在增长，数据不见得都在关系型数据库中存储了。\n\n诚然，在互联网上有成千上万关于选择SQL还是NoSQL的辩论。但是，这两者是不是必须站在对立面战斗呢？如果你选择一种或另一种，你知道为什么做选择，知道各自有何潜在益处吗？本文简要地讨论了SQL和NoSQL两种方法最常见的优点和缺点，包括简单的比较和开发者考虑的因素。像别的一些话题一样，这个问题没有对错，永远正确的经典答案依然是：具体问题具体分析。\n<!-- more -->\n## 数据表VS.数据集\n\n关系型和非关系型数据库的主要差异是数据存储的方式。关系型数据天然就是表格式的，因此存储在数据表的行和列中。数据表可以彼此关联协作存储，也很容易提取数据。与其相反，非关系型数据不适合存储在数据表的行和列中，而是大块组合在一起。非关系型数据通常存储在数据集中，就像文档、键值对或者图结构。你的数据及其特性是选择数据存储和提取方式的首要影响因素。\n\n## 预定义结构VS.动态结构\n\n关系型数据通常对应于结构化数据，因为数据表都有预定义好的结构(列的定义)，结构描述了数据的形式和内容。这一点对数据建模至关重要，你必须“第一时间先把结构定义好”。虽然预定义结构带来了可靠性和稳定性，但是已经存入数据的表结构要修改就非常痛苦了。另一方面，非关系型数据基于动态结构，通常适用于非结构化数据。非关系型数据可以很容易适应数据类型和结构的变化，因为动态结构本身就支持这一点。\n\n## 存储规范化VS存储代价\n\n关系型数据库的数据存储是为了更高的规范性，把数据分隔成最小的逻辑表(关系表)以避免重复，获得最精简的空间利用。虽然数据规范性会使数据管理更清晰，但它通常也会带来一点点复杂性，尤其是单个操作可能涉及多个关系表的时候，数据管理就有点麻烦。另外，更精简的空间利用通常可以节约宝贵的数据存储，但是在当今世界我们基本可以认为存储的代价(磁盘空间)是微不足道的。而非关系型数据存储在平面数据集中，数据经常可能存在重复。单个数据库很少被分隔开，而是存储成一个整体，这样是为了整块数据更容易读写。\n\n## 纵向扩容VS横向扩容\n\nSQL和NoSQL数据库最大的差别可能是在扩展方式上，要支持日益增长的需求当然要扩展。要支持更多并发量，SQL数据库是纵向扩展，也就是说提高处理能力，使用速度更快速的计算机，这样处理相同的数据集就更快了。因为数据存储在关系表中，操作的性能瓶颈可能涉及很多个表，这都需要通过提高计算机性能来客服。虽然SQL数据库有很大扩展空间，但最终肯定会达到纵向扩展的上限。而NoSQL数据库是横向扩展的。非关系型数据存储天然就是分布式的，NoSQL数据库的扩展可以通过给资源池添加更多普通的数据库服务器(节点)来分担负载。\n\n## 结构化查询VS非结构化查询\n\n关系型数据库通过所谓结构化查询语言(也就是我们常说的SQL)来操作数据。SQL支持数据库CRUD(增加，查询，更新，删除)操作的功能非常强大，是业界标准用法。非关系型数据库以块(像文档一样)为单元操纵数据，使用所谓的非结构化查询语言(UnQL)，它是没有标准的，因数据库提供商的不同而不同。关系型表中主键的概念对应非关系存储中的文档Id。SQL数据库使用预定义优化方式(比如列索引定义)帮助加速查询操作，而NoSQL数据库采用更简单而精确的数据访问模式。\n\n## 映射VS本地化\n\nSQL和NoSQL数据存储的选择还取决于开发人员，尽管这个因素影响不大。采用面向对象编程语言的开发人员通常会同时操作一个或多个数据实体(包括嵌套数据、列表和数组的复杂结构)，把数据传递给应用程序用户界面。要是讨论到底层数据库，事情就并不总是那么公平合理了。在关系型存储中，数据实体通常需要分成多个部分进行规范化，然后分开存储到多个关系型表中精简存储。幸运的是，这是一个长期存在的问题，大部分编程平台都有相应的简单解决方案，比如ORM层(对象关系映射)。ORM是位于关系型数据源和开发者使用的面向对象数据实体之间的一个映射层。然而，对于非关系型存储，不需要规范化数据，复杂数据实体可以整体存放在独立单元中。应用程序中使用的对象通常序列化为JSon串，存储在NoSQL数据库的JSon文档中。\n\n## 事务性VS纯扩展性\n\n如果你的数据操作需要高事务性或者复杂数据查询需要控制执行计划，那么传统的SQL数据库从性能和稳定性方面考虑是你的最佳选择。SQL数据库支持对事务原子性细粒度控制，并且易于回滚事务。虽然NoSQL数据库也可以使用事务操作，但它们真正闪亮的价值是在操作的扩展性和大数据量处理方面。\n\n## ACID VS CAP\n\nSQL 数据库久负盛名的价值就是通过所谓的ACID属性(原子性，一致性，隔离性，持久性)保证数据完整性，大部分关系型存储供应商都支持ACID。我们的目标是支持隔离不可分割的事务，其变化是持久的，数据也保持一致状态。而NoSQL数据库是让你在CAP(一致性，可用性，分区容忍度)中的任意两项中选择，因为在基于节点的分布式系统中，很难做到三项都满足。\n\n## 数据VS大数据\n\nSQL数据库可以可靠地存储和处理数据，而NoSQL最大的优势是在应对大数据方面，也就是由我们社会或者计算机每天产生的大量非结构化的数据实体。NoSQL用无模式方式做数据管理，所以其横向扩展潜力是无限的，这可能是深度处理大数据捕获、管理、检索、分析和可视化的唯一有效途径。\n\n## 数据记录VS物联网和人联网\n\n关系数据库在关注数据规范化和保证性能的基础上精简存储。但是近年来，我们产生数据的速度远大于关系型存储能满足存储的能力增长。刺激数据如此迅猛增长的原因是：巨大量的用户数和物联网。连接到互联网的用户在成倍增加，在同步使用我们的应用。由于大量移动设备数据传感设备接入互联网，机器产生的数据量也大幅增加。因此企业必须寻求NoSQL技术及基础架构来处理持续涌入的半结构化和非结构化数据。\n\n## 内部部署VS云计算\n\n云计算现在已经无处不在了，它兼具SQL和NoSQL数据库的益处。云环境中的关系型存储通常是以服务形式提供的，是可复制、高可用性且分布式的，极大地提高了横向扩展能力。托管于云服务中的NoSQL数据库也天然享有自动分片的好处，可以阶段性地灵活弹性处理，集成高速缓存和巨大的计算能力来捕获、存储和分析大数据。\n\n## 付费VS开源\n\n有一种看法认为，SQL数据库大多数比较昂贵，而NoSQL数据库通常都是开源的。事实上，两种类型数据库都有开源的和商业的。常见的SQL 数据库有微软公司的SQL Server，MySQL，SQLite，Oracle和PostGres。流行的NoSQL数据库有Couchbase，MongoDB，Redis，BigTable和RavenDB。\n\n# 结论\n\n就像Neo之于Matrix，你可以选择。幸福的无知和幻想或者接受残酷的现实。但是，盲目选择使用SQL还是NoSQL技术，或者根据大众需求选择都是在幻想有魔法会自动选择合适的方案。SQL和NoSQL这两者都有各自的优缺点，选择正确的架构取决于你构建应用的需求。传统SQL数据库依然非常强大，可以可靠地处理你的事务性需求并保持完整性。只有在你接近关系数据库局限性边缘时，或者你的数据处理量浩如烟海时，操作扩展需要更加分布式的系统时，才考虑NoSQL方案。考虑这些因素之后再做选择，你就可以变成释放你的数据构建下一代应用令人叹为观止的神人。\n\n[原文链接](http://www.36dsj.com/archives/16986)","source":"_posts/RDBMS和NOSQL的技术差别.md","raw":"---\ntitle: RDBMS和NOSQL的技术差别\ndate: 2016-04-20 10:01:24\ncategories: SQL\ntags: [Nosql, RDBMS]\n\n---\n# RDBMS和NOSQL的技术差别\n创新的背后往往会刺激痛苦。这一点在PDD(我们亲切地称为痛处驱动开发)软件开发领域尤为真实。从上世纪80年代以来，我们就都知道如何处理关系型数据——只要把数据放到关系型数据库管理系统(RDBMS)中，就可以使用SQL语句操作数据。然而，在过去几年来，我们的行业采纳NoSQL数据库的趋势在增长，数据不见得都在关系型数据库中存储了。\n\n诚然，在互联网上有成千上万关于选择SQL还是NoSQL的辩论。但是，这两者是不是必须站在对立面战斗呢？如果你选择一种或另一种，你知道为什么做选择，知道各自有何潜在益处吗？本文简要地讨论了SQL和NoSQL两种方法最常见的优点和缺点，包括简单的比较和开发者考虑的因素。像别的一些话题一样，这个问题没有对错，永远正确的经典答案依然是：具体问题具体分析。\n<!-- more -->\n## 数据表VS.数据集\n\n关系型和非关系型数据库的主要差异是数据存储的方式。关系型数据天然就是表格式的，因此存储在数据表的行和列中。数据表可以彼此关联协作存储，也很容易提取数据。与其相反，非关系型数据不适合存储在数据表的行和列中，而是大块组合在一起。非关系型数据通常存储在数据集中，就像文档、键值对或者图结构。你的数据及其特性是选择数据存储和提取方式的首要影响因素。\n\n## 预定义结构VS.动态结构\n\n关系型数据通常对应于结构化数据，因为数据表都有预定义好的结构(列的定义)，结构描述了数据的形式和内容。这一点对数据建模至关重要，你必须“第一时间先把结构定义好”。虽然预定义结构带来了可靠性和稳定性，但是已经存入数据的表结构要修改就非常痛苦了。另一方面，非关系型数据基于动态结构，通常适用于非结构化数据。非关系型数据可以很容易适应数据类型和结构的变化，因为动态结构本身就支持这一点。\n\n## 存储规范化VS存储代价\n\n关系型数据库的数据存储是为了更高的规范性，把数据分隔成最小的逻辑表(关系表)以避免重复，获得最精简的空间利用。虽然数据规范性会使数据管理更清晰，但它通常也会带来一点点复杂性，尤其是单个操作可能涉及多个关系表的时候，数据管理就有点麻烦。另外，更精简的空间利用通常可以节约宝贵的数据存储，但是在当今世界我们基本可以认为存储的代价(磁盘空间)是微不足道的。而非关系型数据存储在平面数据集中，数据经常可能存在重复。单个数据库很少被分隔开，而是存储成一个整体，这样是为了整块数据更容易读写。\n\n## 纵向扩容VS横向扩容\n\nSQL和NoSQL数据库最大的差别可能是在扩展方式上，要支持日益增长的需求当然要扩展。要支持更多并发量，SQL数据库是纵向扩展，也就是说提高处理能力，使用速度更快速的计算机，这样处理相同的数据集就更快了。因为数据存储在关系表中，操作的性能瓶颈可能涉及很多个表，这都需要通过提高计算机性能来客服。虽然SQL数据库有很大扩展空间，但最终肯定会达到纵向扩展的上限。而NoSQL数据库是横向扩展的。非关系型数据存储天然就是分布式的，NoSQL数据库的扩展可以通过给资源池添加更多普通的数据库服务器(节点)来分担负载。\n\n## 结构化查询VS非结构化查询\n\n关系型数据库通过所谓结构化查询语言(也就是我们常说的SQL)来操作数据。SQL支持数据库CRUD(增加，查询，更新，删除)操作的功能非常强大，是业界标准用法。非关系型数据库以块(像文档一样)为单元操纵数据，使用所谓的非结构化查询语言(UnQL)，它是没有标准的，因数据库提供商的不同而不同。关系型表中主键的概念对应非关系存储中的文档Id。SQL数据库使用预定义优化方式(比如列索引定义)帮助加速查询操作，而NoSQL数据库采用更简单而精确的数据访问模式。\n\n## 映射VS本地化\n\nSQL和NoSQL数据存储的选择还取决于开发人员，尽管这个因素影响不大。采用面向对象编程语言的开发人员通常会同时操作一个或多个数据实体(包括嵌套数据、列表和数组的复杂结构)，把数据传递给应用程序用户界面。要是讨论到底层数据库，事情就并不总是那么公平合理了。在关系型存储中，数据实体通常需要分成多个部分进行规范化，然后分开存储到多个关系型表中精简存储。幸运的是，这是一个长期存在的问题，大部分编程平台都有相应的简单解决方案，比如ORM层(对象关系映射)。ORM是位于关系型数据源和开发者使用的面向对象数据实体之间的一个映射层。然而，对于非关系型存储，不需要规范化数据，复杂数据实体可以整体存放在独立单元中。应用程序中使用的对象通常序列化为JSon串，存储在NoSQL数据库的JSon文档中。\n\n## 事务性VS纯扩展性\n\n如果你的数据操作需要高事务性或者复杂数据查询需要控制执行计划，那么传统的SQL数据库从性能和稳定性方面考虑是你的最佳选择。SQL数据库支持对事务原子性细粒度控制，并且易于回滚事务。虽然NoSQL数据库也可以使用事务操作，但它们真正闪亮的价值是在操作的扩展性和大数据量处理方面。\n\n## ACID VS CAP\n\nSQL 数据库久负盛名的价值就是通过所谓的ACID属性(原子性，一致性，隔离性，持久性)保证数据完整性，大部分关系型存储供应商都支持ACID。我们的目标是支持隔离不可分割的事务，其变化是持久的，数据也保持一致状态。而NoSQL数据库是让你在CAP(一致性，可用性，分区容忍度)中的任意两项中选择，因为在基于节点的分布式系统中，很难做到三项都满足。\n\n## 数据VS大数据\n\nSQL数据库可以可靠地存储和处理数据，而NoSQL最大的优势是在应对大数据方面，也就是由我们社会或者计算机每天产生的大量非结构化的数据实体。NoSQL用无模式方式做数据管理，所以其横向扩展潜力是无限的，这可能是深度处理大数据捕获、管理、检索、分析和可视化的唯一有效途径。\n\n## 数据记录VS物联网和人联网\n\n关系数据库在关注数据规范化和保证性能的基础上精简存储。但是近年来，我们产生数据的速度远大于关系型存储能满足存储的能力增长。刺激数据如此迅猛增长的原因是：巨大量的用户数和物联网。连接到互联网的用户在成倍增加，在同步使用我们的应用。由于大量移动设备数据传感设备接入互联网，机器产生的数据量也大幅增加。因此企业必须寻求NoSQL技术及基础架构来处理持续涌入的半结构化和非结构化数据。\n\n## 内部部署VS云计算\n\n云计算现在已经无处不在了，它兼具SQL和NoSQL数据库的益处。云环境中的关系型存储通常是以服务形式提供的，是可复制、高可用性且分布式的，极大地提高了横向扩展能力。托管于云服务中的NoSQL数据库也天然享有自动分片的好处，可以阶段性地灵活弹性处理，集成高速缓存和巨大的计算能力来捕获、存储和分析大数据。\n\n## 付费VS开源\n\n有一种看法认为，SQL数据库大多数比较昂贵，而NoSQL数据库通常都是开源的。事实上，两种类型数据库都有开源的和商业的。常见的SQL 数据库有微软公司的SQL Server，MySQL，SQLite，Oracle和PostGres。流行的NoSQL数据库有Couchbase，MongoDB，Redis，BigTable和RavenDB。\n\n# 结论\n\n就像Neo之于Matrix，你可以选择。幸福的无知和幻想或者接受残酷的现实。但是，盲目选择使用SQL还是NoSQL技术，或者根据大众需求选择都是在幻想有魔法会自动选择合适的方案。SQL和NoSQL这两者都有各自的优缺点，选择正确的架构取决于你构建应用的需求。传统SQL数据库依然非常强大，可以可靠地处理你的事务性需求并保持完整性。只有在你接近关系数据库局限性边缘时，或者你的数据处理量浩如烟海时，操作扩展需要更加分布式的系统时，才考虑NoSQL方案。考虑这些因素之后再做选择，你就可以变成释放你的数据构建下一代应用令人叹为观止的神人。\n\n[原文链接](http://www.36dsj.com/archives/16986)","slug":"RDBMS和NOSQL的技术差别","published":1,"updated":"2016-06-28T11:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzgzejz0006egfyqdzj1whc","content":"<h1 id=\"RDBMS和NOSQL的技术差别\"><a href=\"#RDBMS和NOSQL的技术差别\" class=\"headerlink\" title=\"RDBMS和NOSQL的技术差别\"></a>RDBMS和NOSQL的技术差别</h1><p>创新的背后往往会刺激痛苦。这一点在PDD(我们亲切地称为痛处驱动开发)软件开发领域尤为真实。从上世纪80年代以来，我们就都知道如何处理关系型数据——只要把数据放到关系型数据库管理系统(RDBMS)中，就可以使用SQL语句操作数据。然而，在过去几年来，我们的行业采纳NoSQL数据库的趋势在增长，数据不见得都在关系型数据库中存储了。</p>\n<p>诚然，在互联网上有成千上万关于选择SQL还是NoSQL的辩论。但是，这两者是不是必须站在对立面战斗呢？如果你选择一种或另一种，你知道为什么做选择，知道各自有何潜在益处吗？本文简要地讨论了SQL和NoSQL两种方法最常见的优点和缺点，包括简单的比较和开发者考虑的因素。像别的一些话题一样，这个问题没有对错，永远正确的经典答案依然是：具体问题具体分析。<br><a id=\"more\"></a></p>\n<h2 id=\"数据表VS-数据集\"><a href=\"#数据表VS-数据集\" class=\"headerlink\" title=\"数据表VS.数据集\"></a>数据表VS.数据集</h2><p>关系型和非关系型数据库的主要差异是数据存储的方式。关系型数据天然就是表格式的，因此存储在数据表的行和列中。数据表可以彼此关联协作存储，也很容易提取数据。与其相反，非关系型数据不适合存储在数据表的行和列中，而是大块组合在一起。非关系型数据通常存储在数据集中，就像文档、键值对或者图结构。你的数据及其特性是选择数据存储和提取方式的首要影响因素。</p>\n<h2 id=\"预定义结构VS-动态结构\"><a href=\"#预定义结构VS-动态结构\" class=\"headerlink\" title=\"预定义结构VS.动态结构\"></a>预定义结构VS.动态结构</h2><p>关系型数据通常对应于结构化数据，因为数据表都有预定义好的结构(列的定义)，结构描述了数据的形式和内容。这一点对数据建模至关重要，你必须“第一时间先把结构定义好”。虽然预定义结构带来了可靠性和稳定性，但是已经存入数据的表结构要修改就非常痛苦了。另一方面，非关系型数据基于动态结构，通常适用于非结构化数据。非关系型数据可以很容易适应数据类型和结构的变化，因为动态结构本身就支持这一点。</p>\n<h2 id=\"存储规范化VS存储代价\"><a href=\"#存储规范化VS存储代价\" class=\"headerlink\" title=\"存储规范化VS存储代价\"></a>存储规范化VS存储代价</h2><p>关系型数据库的数据存储是为了更高的规范性，把数据分隔成最小的逻辑表(关系表)以避免重复，获得最精简的空间利用。虽然数据规范性会使数据管理更清晰，但它通常也会带来一点点复杂性，尤其是单个操作可能涉及多个关系表的时候，数据管理就有点麻烦。另外，更精简的空间利用通常可以节约宝贵的数据存储，但是在当今世界我们基本可以认为存储的代价(磁盘空间)是微不足道的。而非关系型数据存储在平面数据集中，数据经常可能存在重复。单个数据库很少被分隔开，而是存储成一个整体，这样是为了整块数据更容易读写。</p>\n<h2 id=\"纵向扩容VS横向扩容\"><a href=\"#纵向扩容VS横向扩容\" class=\"headerlink\" title=\"纵向扩容VS横向扩容\"></a>纵向扩容VS横向扩容</h2><p>SQL和NoSQL数据库最大的差别可能是在扩展方式上，要支持日益增长的需求当然要扩展。要支持更多并发量，SQL数据库是纵向扩展，也就是说提高处理能力，使用速度更快速的计算机，这样处理相同的数据集就更快了。因为数据存储在关系表中，操作的性能瓶颈可能涉及很多个表，这都需要通过提高计算机性能来客服。虽然SQL数据库有很大扩展空间，但最终肯定会达到纵向扩展的上限。而NoSQL数据库是横向扩展的。非关系型数据存储天然就是分布式的，NoSQL数据库的扩展可以通过给资源池添加更多普通的数据库服务器(节点)来分担负载。</p>\n<h2 id=\"结构化查询VS非结构化查询\"><a href=\"#结构化查询VS非结构化查询\" class=\"headerlink\" title=\"结构化查询VS非结构化查询\"></a>结构化查询VS非结构化查询</h2><p>关系型数据库通过所谓结构化查询语言(也就是我们常说的SQL)来操作数据。SQL支持数据库CRUD(增加，查询，更新，删除)操作的功能非常强大，是业界标准用法。非关系型数据库以块(像文档一样)为单元操纵数据，使用所谓的非结构化查询语言(UnQL)，它是没有标准的，因数据库提供商的不同而不同。关系型表中主键的概念对应非关系存储中的文档Id。SQL数据库使用预定义优化方式(比如列索引定义)帮助加速查询操作，而NoSQL数据库采用更简单而精确的数据访问模式。</p>\n<h2 id=\"映射VS本地化\"><a href=\"#映射VS本地化\" class=\"headerlink\" title=\"映射VS本地化\"></a>映射VS本地化</h2><p>SQL和NoSQL数据存储的选择还取决于开发人员，尽管这个因素影响不大。采用面向对象编程语言的开发人员通常会同时操作一个或多个数据实体(包括嵌套数据、列表和数组的复杂结构)，把数据传递给应用程序用户界面。要是讨论到底层数据库，事情就并不总是那么公平合理了。在关系型存储中，数据实体通常需要分成多个部分进行规范化，然后分开存储到多个关系型表中精简存储。幸运的是，这是一个长期存在的问题，大部分编程平台都有相应的简单解决方案，比如ORM层(对象关系映射)。ORM是位于关系型数据源和开发者使用的面向对象数据实体之间的一个映射层。然而，对于非关系型存储，不需要规范化数据，复杂数据实体可以整体存放在独立单元中。应用程序中使用的对象通常序列化为JSon串，存储在NoSQL数据库的JSon文档中。</p>\n<h2 id=\"事务性VS纯扩展性\"><a href=\"#事务性VS纯扩展性\" class=\"headerlink\" title=\"事务性VS纯扩展性\"></a>事务性VS纯扩展性</h2><p>如果你的数据操作需要高事务性或者复杂数据查询需要控制执行计划，那么传统的SQL数据库从性能和稳定性方面考虑是你的最佳选择。SQL数据库支持对事务原子性细粒度控制，并且易于回滚事务。虽然NoSQL数据库也可以使用事务操作，但它们真正闪亮的价值是在操作的扩展性和大数据量处理方面。</p>\n<h2 id=\"ACID-VS-CAP\"><a href=\"#ACID-VS-CAP\" class=\"headerlink\" title=\"ACID VS CAP\"></a>ACID VS CAP</h2><p>SQL 数据库久负盛名的价值就是通过所谓的ACID属性(原子性，一致性，隔离性，持久性)保证数据完整性，大部分关系型存储供应商都支持ACID。我们的目标是支持隔离不可分割的事务，其变化是持久的，数据也保持一致状态。而NoSQL数据库是让你在CAP(一致性，可用性，分区容忍度)中的任意两项中选择，因为在基于节点的分布式系统中，很难做到三项都满足。</p>\n<h2 id=\"数据VS大数据\"><a href=\"#数据VS大数据\" class=\"headerlink\" title=\"数据VS大数据\"></a>数据VS大数据</h2><p>SQL数据库可以可靠地存储和处理数据，而NoSQL最大的优势是在应对大数据方面，也就是由我们社会或者计算机每天产生的大量非结构化的数据实体。NoSQL用无模式方式做数据管理，所以其横向扩展潜力是无限的，这可能是深度处理大数据捕获、管理、检索、分析和可视化的唯一有效途径。</p>\n<h2 id=\"数据记录VS物联网和人联网\"><a href=\"#数据记录VS物联网和人联网\" class=\"headerlink\" title=\"数据记录VS物联网和人联网\"></a>数据记录VS物联网和人联网</h2><p>关系数据库在关注数据规范化和保证性能的基础上精简存储。但是近年来，我们产生数据的速度远大于关系型存储能满足存储的能力增长。刺激数据如此迅猛增长的原因是：巨大量的用户数和物联网。连接到互联网的用户在成倍增加，在同步使用我们的应用。由于大量移动设备数据传感设备接入互联网，机器产生的数据量也大幅增加。因此企业必须寻求NoSQL技术及基础架构来处理持续涌入的半结构化和非结构化数据。</p>\n<h2 id=\"内部部署VS云计算\"><a href=\"#内部部署VS云计算\" class=\"headerlink\" title=\"内部部署VS云计算\"></a>内部部署VS云计算</h2><p>云计算现在已经无处不在了，它兼具SQL和NoSQL数据库的益处。云环境中的关系型存储通常是以服务形式提供的，是可复制、高可用性且分布式的，极大地提高了横向扩展能力。托管于云服务中的NoSQL数据库也天然享有自动分片的好处，可以阶段性地灵活弹性处理，集成高速缓存和巨大的计算能力来捕获、存储和分析大数据。</p>\n<h2 id=\"付费VS开源\"><a href=\"#付费VS开源\" class=\"headerlink\" title=\"付费VS开源\"></a>付费VS开源</h2><p>有一种看法认为，SQL数据库大多数比较昂贵，而NoSQL数据库通常都是开源的。事实上，两种类型数据库都有开源的和商业的。常见的SQL 数据库有微软公司的SQL Server，MySQL，SQLite，Oracle和PostGres。流行的NoSQL数据库有Couchbase，MongoDB，Redis，BigTable和RavenDB。</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>就像Neo之于Matrix，你可以选择。幸福的无知和幻想或者接受残酷的现实。但是，盲目选择使用SQL还是NoSQL技术，或者根据大众需求选择都是在幻想有魔法会自动选择合适的方案。SQL和NoSQL这两者都有各自的优缺点，选择正确的架构取决于你构建应用的需求。传统SQL数据库依然非常强大，可以可靠地处理你的事务性需求并保持完整性。只有在你接近关系数据库局限性边缘时，或者你的数据处理量浩如烟海时，操作扩展需要更加分布式的系统时，才考虑NoSQL方案。考虑这些因素之后再做选择，你就可以变成释放你的数据构建下一代应用令人叹为观止的神人。</p>\n<p><a href=\"http://www.36dsj.com/archives/16986\" target=\"_blank\" rel=\"external\">原文链接</a></p>\n","excerpt":"<h1 id=\"RDBMS和NOSQL的技术差别\"><a href=\"#RDBMS和NOSQL的技术差别\" class=\"headerlink\" title=\"RDBMS和NOSQL的技术差别\"></a>RDBMS和NOSQL的技术差别</h1><p>创新的背后往往会刺激痛苦。这一点在PDD(我们亲切地称为痛处驱动开发)软件开发领域尤为真实。从上世纪80年代以来，我们就都知道如何处理关系型数据——只要把数据放到关系型数据库管理系统(RDBMS)中，就可以使用SQL语句操作数据。然而，在过去几年来，我们的行业采纳NoSQL数据库的趋势在增长，数据不见得都在关系型数据库中存储了。</p>\n<p>诚然，在互联网上有成千上万关于选择SQL还是NoSQL的辩论。但是，这两者是不是必须站在对立面战斗呢？如果你选择一种或另一种，你知道为什么做选择，知道各自有何潜在益处吗？本文简要地讨论了SQL和NoSQL两种方法最常见的优点和缺点，包括简单的比较和开发者考虑的因素。像别的一些话题一样，这个问题没有对错，永远正确的经典答案依然是：具体问题具体分析。<br>","more":"</p>\n<h2 id=\"数据表VS-数据集\"><a href=\"#数据表VS-数据集\" class=\"headerlink\" title=\"数据表VS.数据集\"></a>数据表VS.数据集</h2><p>关系型和非关系型数据库的主要差异是数据存储的方式。关系型数据天然就是表格式的，因此存储在数据表的行和列中。数据表可以彼此关联协作存储，也很容易提取数据。与其相反，非关系型数据不适合存储在数据表的行和列中，而是大块组合在一起。非关系型数据通常存储在数据集中，就像文档、键值对或者图结构。你的数据及其特性是选择数据存储和提取方式的首要影响因素。</p>\n<h2 id=\"预定义结构VS-动态结构\"><a href=\"#预定义结构VS-动态结构\" class=\"headerlink\" title=\"预定义结构VS.动态结构\"></a>预定义结构VS.动态结构</h2><p>关系型数据通常对应于结构化数据，因为数据表都有预定义好的结构(列的定义)，结构描述了数据的形式和内容。这一点对数据建模至关重要，你必须“第一时间先把结构定义好”。虽然预定义结构带来了可靠性和稳定性，但是已经存入数据的表结构要修改就非常痛苦了。另一方面，非关系型数据基于动态结构，通常适用于非结构化数据。非关系型数据可以很容易适应数据类型和结构的变化，因为动态结构本身就支持这一点。</p>\n<h2 id=\"存储规范化VS存储代价\"><a href=\"#存储规范化VS存储代价\" class=\"headerlink\" title=\"存储规范化VS存储代价\"></a>存储规范化VS存储代价</h2><p>关系型数据库的数据存储是为了更高的规范性，把数据分隔成最小的逻辑表(关系表)以避免重复，获得最精简的空间利用。虽然数据规范性会使数据管理更清晰，但它通常也会带来一点点复杂性，尤其是单个操作可能涉及多个关系表的时候，数据管理就有点麻烦。另外，更精简的空间利用通常可以节约宝贵的数据存储，但是在当今世界我们基本可以认为存储的代价(磁盘空间)是微不足道的。而非关系型数据存储在平面数据集中，数据经常可能存在重复。单个数据库很少被分隔开，而是存储成一个整体，这样是为了整块数据更容易读写。</p>\n<h2 id=\"纵向扩容VS横向扩容\"><a href=\"#纵向扩容VS横向扩容\" class=\"headerlink\" title=\"纵向扩容VS横向扩容\"></a>纵向扩容VS横向扩容</h2><p>SQL和NoSQL数据库最大的差别可能是在扩展方式上，要支持日益增长的需求当然要扩展。要支持更多并发量，SQL数据库是纵向扩展，也就是说提高处理能力，使用速度更快速的计算机，这样处理相同的数据集就更快了。因为数据存储在关系表中，操作的性能瓶颈可能涉及很多个表，这都需要通过提高计算机性能来客服。虽然SQL数据库有很大扩展空间，但最终肯定会达到纵向扩展的上限。而NoSQL数据库是横向扩展的。非关系型数据存储天然就是分布式的，NoSQL数据库的扩展可以通过给资源池添加更多普通的数据库服务器(节点)来分担负载。</p>\n<h2 id=\"结构化查询VS非结构化查询\"><a href=\"#结构化查询VS非结构化查询\" class=\"headerlink\" title=\"结构化查询VS非结构化查询\"></a>结构化查询VS非结构化查询</h2><p>关系型数据库通过所谓结构化查询语言(也就是我们常说的SQL)来操作数据。SQL支持数据库CRUD(增加，查询，更新，删除)操作的功能非常强大，是业界标准用法。非关系型数据库以块(像文档一样)为单元操纵数据，使用所谓的非结构化查询语言(UnQL)，它是没有标准的，因数据库提供商的不同而不同。关系型表中主键的概念对应非关系存储中的文档Id。SQL数据库使用预定义优化方式(比如列索引定义)帮助加速查询操作，而NoSQL数据库采用更简单而精确的数据访问模式。</p>\n<h2 id=\"映射VS本地化\"><a href=\"#映射VS本地化\" class=\"headerlink\" title=\"映射VS本地化\"></a>映射VS本地化</h2><p>SQL和NoSQL数据存储的选择还取决于开发人员，尽管这个因素影响不大。采用面向对象编程语言的开发人员通常会同时操作一个或多个数据实体(包括嵌套数据、列表和数组的复杂结构)，把数据传递给应用程序用户界面。要是讨论到底层数据库，事情就并不总是那么公平合理了。在关系型存储中，数据实体通常需要分成多个部分进行规范化，然后分开存储到多个关系型表中精简存储。幸运的是，这是一个长期存在的问题，大部分编程平台都有相应的简单解决方案，比如ORM层(对象关系映射)。ORM是位于关系型数据源和开发者使用的面向对象数据实体之间的一个映射层。然而，对于非关系型存储，不需要规范化数据，复杂数据实体可以整体存放在独立单元中。应用程序中使用的对象通常序列化为JSon串，存储在NoSQL数据库的JSon文档中。</p>\n<h2 id=\"事务性VS纯扩展性\"><a href=\"#事务性VS纯扩展性\" class=\"headerlink\" title=\"事务性VS纯扩展性\"></a>事务性VS纯扩展性</h2><p>如果你的数据操作需要高事务性或者复杂数据查询需要控制执行计划，那么传统的SQL数据库从性能和稳定性方面考虑是你的最佳选择。SQL数据库支持对事务原子性细粒度控制，并且易于回滚事务。虽然NoSQL数据库也可以使用事务操作，但它们真正闪亮的价值是在操作的扩展性和大数据量处理方面。</p>\n<h2 id=\"ACID-VS-CAP\"><a href=\"#ACID-VS-CAP\" class=\"headerlink\" title=\"ACID VS CAP\"></a>ACID VS CAP</h2><p>SQL 数据库久负盛名的价值就是通过所谓的ACID属性(原子性，一致性，隔离性，持久性)保证数据完整性，大部分关系型存储供应商都支持ACID。我们的目标是支持隔离不可分割的事务，其变化是持久的，数据也保持一致状态。而NoSQL数据库是让你在CAP(一致性，可用性，分区容忍度)中的任意两项中选择，因为在基于节点的分布式系统中，很难做到三项都满足。</p>\n<h2 id=\"数据VS大数据\"><a href=\"#数据VS大数据\" class=\"headerlink\" title=\"数据VS大数据\"></a>数据VS大数据</h2><p>SQL数据库可以可靠地存储和处理数据，而NoSQL最大的优势是在应对大数据方面，也就是由我们社会或者计算机每天产生的大量非结构化的数据实体。NoSQL用无模式方式做数据管理，所以其横向扩展潜力是无限的，这可能是深度处理大数据捕获、管理、检索、分析和可视化的唯一有效途径。</p>\n<h2 id=\"数据记录VS物联网和人联网\"><a href=\"#数据记录VS物联网和人联网\" class=\"headerlink\" title=\"数据记录VS物联网和人联网\"></a>数据记录VS物联网和人联网</h2><p>关系数据库在关注数据规范化和保证性能的基础上精简存储。但是近年来，我们产生数据的速度远大于关系型存储能满足存储的能力增长。刺激数据如此迅猛增长的原因是：巨大量的用户数和物联网。连接到互联网的用户在成倍增加，在同步使用我们的应用。由于大量移动设备数据传感设备接入互联网，机器产生的数据量也大幅增加。因此企业必须寻求NoSQL技术及基础架构来处理持续涌入的半结构化和非结构化数据。</p>\n<h2 id=\"内部部署VS云计算\"><a href=\"#内部部署VS云计算\" class=\"headerlink\" title=\"内部部署VS云计算\"></a>内部部署VS云计算</h2><p>云计算现在已经无处不在了，它兼具SQL和NoSQL数据库的益处。云环境中的关系型存储通常是以服务形式提供的，是可复制、高可用性且分布式的，极大地提高了横向扩展能力。托管于云服务中的NoSQL数据库也天然享有自动分片的好处，可以阶段性地灵活弹性处理，集成高速缓存和巨大的计算能力来捕获、存储和分析大数据。</p>\n<h2 id=\"付费VS开源\"><a href=\"#付费VS开源\" class=\"headerlink\" title=\"付费VS开源\"></a>付费VS开源</h2><p>有一种看法认为，SQL数据库大多数比较昂贵，而NoSQL数据库通常都是开源的。事实上，两种类型数据库都有开源的和商业的。常见的SQL 数据库有微软公司的SQL Server，MySQL，SQLite，Oracle和PostGres。流行的NoSQL数据库有Couchbase，MongoDB，Redis，BigTable和RavenDB。</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>就像Neo之于Matrix，你可以选择。幸福的无知和幻想或者接受残酷的现实。但是，盲目选择使用SQL还是NoSQL技术，或者根据大众需求选择都是在幻想有魔法会自动选择合适的方案。SQL和NoSQL这两者都有各自的优缺点，选择正确的架构取决于你构建应用的需求。传统SQL数据库依然非常强大，可以可靠地处理你的事务性需求并保持完整性。只有在你接近关系数据库局限性边缘时，或者你的数据处理量浩如烟海时，操作扩展需要更加分布式的系统时，才考虑NoSQL方案。考虑这些因素之后再做选择，你就可以变成释放你的数据构建下一代应用令人叹为观止的神人。</p>\n<p><a href=\"http://www.36dsj.com/archives/16986\">原文链接</a></p>"},{"title":"Systemd","date":"2016-06-05T07:55:33.000Z","_content":"\nSystemd 是 Linux 系统工具，用来启动守护进程，已成为大多数发行版的标准配置。\n<!-- more -->\n# 由来\n历史上，Linux 的启动一直采用`init`进程。\n下面的命令用来启动服务。\n\n```\n$ sudo /etc/init.d/apache2 start\n# 或者\n$ service apache2 start\n```\n这种方法有两个缺点。\n一是启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。\n二是启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。\n# Systemd概述\nSystemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。\n根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。\n使用了 Systemd，就不需要再用init了。Systemd 取代了initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。\n\n```\n$ systemctl --version\n```\n上面的命令查看 Systemd 的版本。\nSystemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反\"keep simple, keep stupid\"的Unix 哲学。\n![](http://www.ruanyifeng.com/blogimg/asset/2016/bg2016030703.png)\n（上图为 Systemd 架构图）\n# 系统管理\nSystemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。\n##  systemctl\nsystemctl是 Systemd 的主命令，用于管理系统。\n\n```\n# 重启系统\n$ sudo systemctl reboot\n\n# 关闭系统，切断电源\n$ sudo systemctl poweroff\n\n# CPU停止工作\n$ sudo systemctl halt\n\n# 暂停系统\n$ sudo systemctl suspend\n\n# 让系统进入冬眠状态\n$ sudo systemctl hibernate\n\n# 让系统进入交互式休眠状态\n$ sudo systemctl hybrid-sleep\n\n# 启动进入救援状态（单用户状态）\n$ sudo systemctl rescue\n```\n## systemd-analyze\nsystemd-analyze命令用于查看启动耗时。\n\n```\n# 查看启动耗时\n$ systemd-analyze                                                                                       \n\n# 查看每个服务的启动耗时\n$ systemd-analyze blame\n\n# 显示瀑布状的启动过程流\n$ systemd-analyze critical-chain\n\n# 显示指定服务的启动流\n$ systemd-analyze critical-chain atd.service\n```\n## hostnamectl\nhostnamectl命令用于查看当前主机的信息。\n\n```\n# 显示当前主机的信息\n$ hostnamectl\n\n# 设置主机名。\n$ sudo hostnamectl set-hostname rhel7\n```\n## localectl\nlocalectl命令用于查看本地化设置。\n\n```\n# 查看本地化设置\n$ localectl\n\n# 设置本地化参数。\n$ sudo localectl set-locale LANG=en_GB.utf8\n$ sudo localectl set-keymap en_GB\n```\n## timedatectl\ntimedatectl命令用于查看当前时区设置。\n\n```\n# 查看当前时区设置\n$ timedatectl\n\n# 显示所有可用的时区\n$ timedatectl list-timezones                                                                                   \n\n# 设置当前时区\n$ sudo timedatectl set-timezone America/New_York\n$ sudo timedatectl set-time YYYY-MM-DD\n$ sudo timedatectl set-time HH:MM:SS\n```\n## loginctl\nloginctl命令用于查看当前登录的用户。\n\n```\n# 列出当前session\n$ loginctl list-sessions\n\n# 列出当前登录用户\n$ loginctl list-users\n\n# 列出显示指定用户的信息\n$ loginctl show-user ruanyf\n```\n# Until\n## 含义\nSystemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。\nUnit 一共分成12种。\n\n```\nService unit：系统服务\nTarget unit：多个 Unit 构成的一个组\nDevice Unit：硬件设备\nMount Unit：文件系统的挂载点\nAutomount Unit：自动挂载点\nPath Unit：文件或路径\nScope Unit：不是由 Systemd 启动的外部进程\nSlice Unit：进程组\nSnapshot Unit：Systemd 快照，可以切回某个快照\nSocket Unit：进程间通信的 socket\nSwap Unit：swap 文件\nTimer Unit：定时器\n```\n`systemctl list-units`命令可以查看当前系统的所有 Unit 。\n\n```\n# 列出正在运行的 Unit\n$ systemctl list-units\n\n# 列出所有Unit，包括没有找到配置文件的或者启动失败的\n$ systemctl list-units --all\n\n# 列出所有没有运行的 Unit\n$ systemctl list-units --all --state=inactive\n\n# 列出所有加载失败的 Unit\n$ systemctl list-units --failed\n\n# 列出所有正在运行的、类型为 service 的 Unit\n$ systemctl list-units --type=service\n```\n## Unit的状态\n`systemctl status`命令用于查看系统状态和单个 Unit 的状态。\n\n```\n# 显示系统状态\n$ systemctl status\n\n# 显示单个 Unit 的状态\n$ sysystemctl status bluetooth.service\n\n# 显示远程主机的某个 Unit 的状态\n$ systemctl -H root@rhel7.example.com status httpd.service\n```\n除了`status`命令，`systemctl`还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。\n\n```\n# 显示某个 Unit 是否正在运行\n$ systemctl is-active application.service\n\n# 显示某个 Unit 是否处于启动失败状态\n$ systemctl is-failed application.service\n\n# 显示某个 Unit 服务是否建立了启动链接\n$ systemctl is-enabled application.service\n```\n## Unit管理\n对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。\n\n```\n# 立即启动一个服务\n$ sudo systemctl start apache.service\n\n# 立即停止一个服务\n$ sudo systemctl stop apache.service\n\n# 重启一个服务\n$ sudo systemctl restart apache.service\n\n# 杀死一个服务的所有子进程\n$ sudo systemctl kill apache.service\n\n# 重新加载一个服务的配置文件\n$ sudo systemctl reload apache.service\n\n# 重载所有修改过的配置文件\n$ sudo systemctl daemon-reload\n\n# 显示某个 Unit 的所有底层参数\n$ systemctl show httpd.service\n\n# 显示某个 Unit 的指定属性的值\n$ systemctl show -p CPUShares httpd.service\n\n# 设置某个 Unit 的指定属性\n$ sudo systemctl set-property httpd.service CPUShares=500\n```\n## 依赖关系\nUnit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。\n`systemctl list-dependencies`命令列出一个 Unit 的所有依赖。\n\n```\n$ systemctl list-dependencies nginx.service\n```\n上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用`--all`参数。\n\n```\n$ systemctl list-dependencies --all nginx.service\n```\n# Unit配置文件\n## 概述\n每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。\nSystemd 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的配置文件存放在那个目录。\n`systemctl enable`命令用于在上面两个目录之间，建立符号链接关系。\n\n```\n$ sudo systemctl enable clamd@scan.service\n# 等同于\n$ sudo ln -s '/usr/lib/systemd/system/clamd@scan.service' '/etc/systemd/system/m\n```\n如果配置文件里面设置了开机启动，`systemctl enable`命令相当于激活开机启动。\n与之对应的，`systemctl disable`命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。\n\n```\n$ sudo systemctl disable clamd@scan.service\n```\n配置文件的后缀名，就是该 Unit 的种类，比如sshd.socket。如果省略，Systemd 默认后缀名为.service，所以sshd会被理解成sshd.service。\n##  配置文件的状态\n`systemctl list-unit-files`命令用于列出所有配置文件。\n\n```\n# 列出所有配置文件\n$ systemctl list-unit-files\n\n# 列出指定类型的配置文件\n$ systemctl list-unit-files --type=service\n```\n这个命令会输出一个列表。\n\n\n```\n$ systemctl list-unit-files\n\nUNIT FILE              STATE\nchronyd.service        enabled\nclamd@.service         static\nclamd@scan.service     disabled\n```\n这个列表显示每个配置文件的状态，一共有四种。\n\n```\nenabled：已建立启动链接\ndisabled：没建立启动链接\nstatic：该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖\nmasked：该配置文件被禁止建立启动链接\n```\n注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的`systemctl status`命令。\n\n```\n$ systemctl status bluetooth.service\n```\n一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。\n\n```\n$ sudo systemctl daemon-reload\n$ sudo systemctl restart httpd.service\n```\n## 配置文件的格式\n配置文件就是普通的文本文件，可以用文本编辑器打开。\n`systemctl cat`命令可以查看配置文件的内容。\n\n```\n$ systemctl cat atd.service\n\n[Unit]\nDescription=ATD daemon\n\n[Service]\nType=forking\nExecStart=/usr/bin/atd\n\n[Install]\nWantedBy=multi-user.target\n```\n从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如[Unit]。注意，配置文件的区块名和字段名，都是大小写敏感的。\n每个区块内部是一些等号连接的键值对。\n\n```\n[Section]\nDirective1=value\nDirective2=value\n\n. . .\n```\n注意，键值对的等号两侧不能有空格。\n## 配置文件的区块\n[Unit]区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。\n\n```\nDescription：简短描述\nDocumentation：文档地址\nRequires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败\nWants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败\nBindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行\nBefore：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动\nAfter：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动\nConflicts：这里指定的 Unit 不能与当前 Unit 同时运行\nCondition...：当前 Unit 运行必须满足的条件，否则不会运行\nAssert...：当前 Unit 运行必须满足的条件，否则会报启动失败\n```\n[Install]通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。\n\n```\nWantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中\nRequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中\nAlias：当前 Unit 可用于启动的别名\nAlso：当前 Unit 激活（enable）时，会被同时激活的其他 Unit\n```\n[Service]区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。\n\n```\nType：定义启动时的进程行为。它有以下几种值。\nType=simple：默认值，执行ExecStart指定的命令，启动主进程\nType=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出\nType=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行\nType=dbus：当前服务通过D-Bus启动\nType=notify：当前服务启动完毕，会通知Systemd，再继续往下执行\nType=idle：若有其他任务执行完毕，当前服务才会运行\nExecStart：启动当前服务的命令\nExecStartPre：启动当前服务之前执行的命令\nExecStartPost：启动当前服务之后执行的命令\nExecReload：重启当前服务时执行的命令\nExecStop：停止当前服务时执行的命令\nExecStopPost：停止当其服务之后执行的命令\nRestartSec：自动重启当前服务间隔的秒数\nRestart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog\nTimeoutSec：定义 Systemd 停止当前服务之前等待的秒数\nEnvironment：指定环境变量\n```\nUnit 配置文件的完整字段清单，请参考[官方文档](https://www.freedesktop.org/software/systemd/man/systemd.unit.html)。\n# Target\n启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。\n简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于\"状态点\"，启动某个 Target 就好比启动到某种状态。\n传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。\n\n```\n# 查看当前系统的所有 Target\n$ systemctl list-unit-files --type=target\n\n# 查看一个 Target 包含的所有 Unit\n$ systemctl list-dependencies multi-user.target\n\n# 查看启动时的默认 Target\n$ systemctl get-default\n\n# 设置启动时的默认 Target\n$ sudo systemctl set-default multi-user.target\n\n# 切换 Target 时，默认不关闭前一个 Target 启动的进程，\n# systemctl isolate 命令改变这种行为，\n# 关闭前一个 Target 里面所有不属于后一个 Target 的进程\n$ sudo systemctl isolate multi-user.target\n```\nTarget 与 传统 RunLevel 的对应关系如下。\n\n```\nTraditional runlevel      New target name     Symbolically linked to...\n\nRunlevel 0           |    runlevel0.target -> poweroff.target\nRunlevel 1           |    runlevel1.target -> rescue.target\nRunlevel 2           |    runlevel2.target -> multi-user.target\nRunlevel 3           |    runlevel3.target -> multi-user.target\nRunlevel 4           |    runlevel4.target -> multi-user.target\nRunlevel 5           |    runlevel5.target -> graphical.target\nRunlevel 6           |    runlevel6.target -> reboot.target\n```\n它与init进程的主要差别如下。\n\n```\n（1）默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。\n（2）启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。\n（3）配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。\n```\n# 日志管理\nSystemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用journalctl一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是/etc/systemd/journald.conf。\njournalctl功能强大，用法非常多。\n\n```\n# 查看所有日志（默认情况下 ，只保存本次启动的日志）\n$ sudo journalctl\n\n# 查看内核日志（不显示应用日志）\n$ sudo journalctl -k\n\n# 查看系统本次启动的日志\n$ sudo journalctl -b\n$ sudo journalctl -b -0\n\n# 查看上一次启动的日志（需更改设置）\n$ sudo journalctl -b -1\n\n# 查看指定时间的日志\n$ sudo journalctl --since=\"2012-10-30 18:17:16\"\n$ sudo journalctl --since \"20 min ago\"\n$ sudo journalctl --since yesterday\n$ sudo journalctl --since \"2015-01-10\" --until \"2015-01-11 03:00\"\n$ sudo journalctl --since 09:00 --until \"1 hour ago\"\n\n# 显示尾部的最新10行日志\n$ sudo journalctl -n\n\n# 显示尾部指定行数的日志\n$ sudo journalctl -n 20\n\n# 实时滚动显示最新日志\n$ sudo journalctl -f\n\n# 查看指定服务的日志\n$ sudo journalctl /usr/lib/systemd/systemd\n\n# 查看指定进程的日志\n$ sudo journalctl _PID=1\n\n# 查看某个路径的脚本的日志\n$ sudo journalctl /usr/bin/bash\n\n# 查看指定用户的日志\n$ sudo journalctl _UID=33 --since today\n\n# 查看某个 Unit 的日志\n$ sudo journalctl -u nginx.service\n$ sudo journalctl -u nginx.service --since today\n\n# 实时滚动显示某个 Unit 的最新日志\n$ sudo journalctl -u nginx.service -f\n\n# 合并显示多个 Unit 的日志\n$ journalctl -u nginx.service -u php-fpm.service --since today\n\n# 查看指定优先级（及其以上级别）的日志，共有8级\n# 0: emerg\n# 1: alert\n# 2: crit\n# 3: err\n# 4: warning\n# 5: notice\n# 6: info\n# 7: debug\n$ sudo journalctl -p err -b\n\n# 日志默认分页输出，--no-pager 改为正常的标准输出\n$ sudo journalctl --no-pager\n\n# 以 JSON 格式（单行）输出\n$ sudo journalctl -b -u nginx.service -o json\n\n# 以 JSON 格式（多行）输出，可读性更好\n$ sudo journalctl -b -u nginx.serviceqq\n -o json-pretty\n\n# 显示日志占据的硬盘空间\n$ sudo journalctl --disk-usage\n\n# 指定日志文件占据的最大空间\n$ sudo journalctl --vacuum-size=1G\n\n# 指定日志文件保存多久\n$ sudo journalctl --vacuum-time=1years\n```","source":"_posts/Systemd.md","raw":"---\ntitle: Systemd\ndate: 2016-06-05 15:55:33\ncategories: Linux\ntags: [Linux, Systemd]\n\n---\n\nSystemd 是 Linux 系统工具，用来启动守护进程，已成为大多数发行版的标准配置。\n<!-- more -->\n# 由来\n历史上，Linux 的启动一直采用`init`进程。\n下面的命令用来启动服务。\n\n```\n$ sudo /etc/init.d/apache2 start\n# 或者\n$ service apache2 start\n```\n这种方法有两个缺点。\n一是启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。\n二是启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。\n# Systemd概述\nSystemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。\n根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。\n使用了 Systemd，就不需要再用init了。Systemd 取代了initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。\n\n```\n$ systemctl --version\n```\n上面的命令查看 Systemd 的版本。\nSystemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反\"keep simple, keep stupid\"的Unix 哲学。\n![](http://www.ruanyifeng.com/blogimg/asset/2016/bg2016030703.png)\n（上图为 Systemd 架构图）\n# 系统管理\nSystemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。\n##  systemctl\nsystemctl是 Systemd 的主命令，用于管理系统。\n\n```\n# 重启系统\n$ sudo systemctl reboot\n\n# 关闭系统，切断电源\n$ sudo systemctl poweroff\n\n# CPU停止工作\n$ sudo systemctl halt\n\n# 暂停系统\n$ sudo systemctl suspend\n\n# 让系统进入冬眠状态\n$ sudo systemctl hibernate\n\n# 让系统进入交互式休眠状态\n$ sudo systemctl hybrid-sleep\n\n# 启动进入救援状态（单用户状态）\n$ sudo systemctl rescue\n```\n## systemd-analyze\nsystemd-analyze命令用于查看启动耗时。\n\n```\n# 查看启动耗时\n$ systemd-analyze                                                                                       \n\n# 查看每个服务的启动耗时\n$ systemd-analyze blame\n\n# 显示瀑布状的启动过程流\n$ systemd-analyze critical-chain\n\n# 显示指定服务的启动流\n$ systemd-analyze critical-chain atd.service\n```\n## hostnamectl\nhostnamectl命令用于查看当前主机的信息。\n\n```\n# 显示当前主机的信息\n$ hostnamectl\n\n# 设置主机名。\n$ sudo hostnamectl set-hostname rhel7\n```\n## localectl\nlocalectl命令用于查看本地化设置。\n\n```\n# 查看本地化设置\n$ localectl\n\n# 设置本地化参数。\n$ sudo localectl set-locale LANG=en_GB.utf8\n$ sudo localectl set-keymap en_GB\n```\n## timedatectl\ntimedatectl命令用于查看当前时区设置。\n\n```\n# 查看当前时区设置\n$ timedatectl\n\n# 显示所有可用的时区\n$ timedatectl list-timezones                                                                                   \n\n# 设置当前时区\n$ sudo timedatectl set-timezone America/New_York\n$ sudo timedatectl set-time YYYY-MM-DD\n$ sudo timedatectl set-time HH:MM:SS\n```\n## loginctl\nloginctl命令用于查看当前登录的用户。\n\n```\n# 列出当前session\n$ loginctl list-sessions\n\n# 列出当前登录用户\n$ loginctl list-users\n\n# 列出显示指定用户的信息\n$ loginctl show-user ruanyf\n```\n# Until\n## 含义\nSystemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。\nUnit 一共分成12种。\n\n```\nService unit：系统服务\nTarget unit：多个 Unit 构成的一个组\nDevice Unit：硬件设备\nMount Unit：文件系统的挂载点\nAutomount Unit：自动挂载点\nPath Unit：文件或路径\nScope Unit：不是由 Systemd 启动的外部进程\nSlice Unit：进程组\nSnapshot Unit：Systemd 快照，可以切回某个快照\nSocket Unit：进程间通信的 socket\nSwap Unit：swap 文件\nTimer Unit：定时器\n```\n`systemctl list-units`命令可以查看当前系统的所有 Unit 。\n\n```\n# 列出正在运行的 Unit\n$ systemctl list-units\n\n# 列出所有Unit，包括没有找到配置文件的或者启动失败的\n$ systemctl list-units --all\n\n# 列出所有没有运行的 Unit\n$ systemctl list-units --all --state=inactive\n\n# 列出所有加载失败的 Unit\n$ systemctl list-units --failed\n\n# 列出所有正在运行的、类型为 service 的 Unit\n$ systemctl list-units --type=service\n```\n## Unit的状态\n`systemctl status`命令用于查看系统状态和单个 Unit 的状态。\n\n```\n# 显示系统状态\n$ systemctl status\n\n# 显示单个 Unit 的状态\n$ sysystemctl status bluetooth.service\n\n# 显示远程主机的某个 Unit 的状态\n$ systemctl -H root@rhel7.example.com status httpd.service\n```\n除了`status`命令，`systemctl`还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。\n\n```\n# 显示某个 Unit 是否正在运行\n$ systemctl is-active application.service\n\n# 显示某个 Unit 是否处于启动失败状态\n$ systemctl is-failed application.service\n\n# 显示某个 Unit 服务是否建立了启动链接\n$ systemctl is-enabled application.service\n```\n## Unit管理\n对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。\n\n```\n# 立即启动一个服务\n$ sudo systemctl start apache.service\n\n# 立即停止一个服务\n$ sudo systemctl stop apache.service\n\n# 重启一个服务\n$ sudo systemctl restart apache.service\n\n# 杀死一个服务的所有子进程\n$ sudo systemctl kill apache.service\n\n# 重新加载一个服务的配置文件\n$ sudo systemctl reload apache.service\n\n# 重载所有修改过的配置文件\n$ sudo systemctl daemon-reload\n\n# 显示某个 Unit 的所有底层参数\n$ systemctl show httpd.service\n\n# 显示某个 Unit 的指定属性的值\n$ systemctl show -p CPUShares httpd.service\n\n# 设置某个 Unit 的指定属性\n$ sudo systemctl set-property httpd.service CPUShares=500\n```\n## 依赖关系\nUnit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。\n`systemctl list-dependencies`命令列出一个 Unit 的所有依赖。\n\n```\n$ systemctl list-dependencies nginx.service\n```\n上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用`--all`参数。\n\n```\n$ systemctl list-dependencies --all nginx.service\n```\n# Unit配置文件\n## 概述\n每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。\nSystemd 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的配置文件存放在那个目录。\n`systemctl enable`命令用于在上面两个目录之间，建立符号链接关系。\n\n```\n$ sudo systemctl enable clamd@scan.service\n# 等同于\n$ sudo ln -s '/usr/lib/systemd/system/clamd@scan.service' '/etc/systemd/system/m\n```\n如果配置文件里面设置了开机启动，`systemctl enable`命令相当于激活开机启动。\n与之对应的，`systemctl disable`命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。\n\n```\n$ sudo systemctl disable clamd@scan.service\n```\n配置文件的后缀名，就是该 Unit 的种类，比如sshd.socket。如果省略，Systemd 默认后缀名为.service，所以sshd会被理解成sshd.service。\n##  配置文件的状态\n`systemctl list-unit-files`命令用于列出所有配置文件。\n\n```\n# 列出所有配置文件\n$ systemctl list-unit-files\n\n# 列出指定类型的配置文件\n$ systemctl list-unit-files --type=service\n```\n这个命令会输出一个列表。\n\n\n```\n$ systemctl list-unit-files\n\nUNIT FILE              STATE\nchronyd.service        enabled\nclamd@.service         static\nclamd@scan.service     disabled\n```\n这个列表显示每个配置文件的状态，一共有四种。\n\n```\nenabled：已建立启动链接\ndisabled：没建立启动链接\nstatic：该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖\nmasked：该配置文件被禁止建立启动链接\n```\n注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的`systemctl status`命令。\n\n```\n$ systemctl status bluetooth.service\n```\n一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。\n\n```\n$ sudo systemctl daemon-reload\n$ sudo systemctl restart httpd.service\n```\n## 配置文件的格式\n配置文件就是普通的文本文件，可以用文本编辑器打开。\n`systemctl cat`命令可以查看配置文件的内容。\n\n```\n$ systemctl cat atd.service\n\n[Unit]\nDescription=ATD daemon\n\n[Service]\nType=forking\nExecStart=/usr/bin/atd\n\n[Install]\nWantedBy=multi-user.target\n```\n从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如[Unit]。注意，配置文件的区块名和字段名，都是大小写敏感的。\n每个区块内部是一些等号连接的键值对。\n\n```\n[Section]\nDirective1=value\nDirective2=value\n\n. . .\n```\n注意，键值对的等号两侧不能有空格。\n## 配置文件的区块\n[Unit]区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。\n\n```\nDescription：简短描述\nDocumentation：文档地址\nRequires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败\nWants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败\nBindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行\nBefore：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动\nAfter：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动\nConflicts：这里指定的 Unit 不能与当前 Unit 同时运行\nCondition...：当前 Unit 运行必须满足的条件，否则不会运行\nAssert...：当前 Unit 运行必须满足的条件，否则会报启动失败\n```\n[Install]通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。\n\n```\nWantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中\nRequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中\nAlias：当前 Unit 可用于启动的别名\nAlso：当前 Unit 激活（enable）时，会被同时激活的其他 Unit\n```\n[Service]区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。\n\n```\nType：定义启动时的进程行为。它有以下几种值。\nType=simple：默认值，执行ExecStart指定的命令，启动主进程\nType=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出\nType=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行\nType=dbus：当前服务通过D-Bus启动\nType=notify：当前服务启动完毕，会通知Systemd，再继续往下执行\nType=idle：若有其他任务执行完毕，当前服务才会运行\nExecStart：启动当前服务的命令\nExecStartPre：启动当前服务之前执行的命令\nExecStartPost：启动当前服务之后执行的命令\nExecReload：重启当前服务时执行的命令\nExecStop：停止当前服务时执行的命令\nExecStopPost：停止当其服务之后执行的命令\nRestartSec：自动重启当前服务间隔的秒数\nRestart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog\nTimeoutSec：定义 Systemd 停止当前服务之前等待的秒数\nEnvironment：指定环境变量\n```\nUnit 配置文件的完整字段清单，请参考[官方文档](https://www.freedesktop.org/software/systemd/man/systemd.unit.html)。\n# Target\n启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。\n简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于\"状态点\"，启动某个 Target 就好比启动到某种状态。\n传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。\n\n```\n# 查看当前系统的所有 Target\n$ systemctl list-unit-files --type=target\n\n# 查看一个 Target 包含的所有 Unit\n$ systemctl list-dependencies multi-user.target\n\n# 查看启动时的默认 Target\n$ systemctl get-default\n\n# 设置启动时的默认 Target\n$ sudo systemctl set-default multi-user.target\n\n# 切换 Target 时，默认不关闭前一个 Target 启动的进程，\n# systemctl isolate 命令改变这种行为，\n# 关闭前一个 Target 里面所有不属于后一个 Target 的进程\n$ sudo systemctl isolate multi-user.target\n```\nTarget 与 传统 RunLevel 的对应关系如下。\n\n```\nTraditional runlevel      New target name     Symbolically linked to...\n\nRunlevel 0           |    runlevel0.target -> poweroff.target\nRunlevel 1           |    runlevel1.target -> rescue.target\nRunlevel 2           |    runlevel2.target -> multi-user.target\nRunlevel 3           |    runlevel3.target -> multi-user.target\nRunlevel 4           |    runlevel4.target -> multi-user.target\nRunlevel 5           |    runlevel5.target -> graphical.target\nRunlevel 6           |    runlevel6.target -> reboot.target\n```\n它与init进程的主要差别如下。\n\n```\n（1）默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。\n（2）启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。\n（3）配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。\n```\n# 日志管理\nSystemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用journalctl一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是/etc/systemd/journald.conf。\njournalctl功能强大，用法非常多。\n\n```\n# 查看所有日志（默认情况下 ，只保存本次启动的日志）\n$ sudo journalctl\n\n# 查看内核日志（不显示应用日志）\n$ sudo journalctl -k\n\n# 查看系统本次启动的日志\n$ sudo journalctl -b\n$ sudo journalctl -b -0\n\n# 查看上一次启动的日志（需更改设置）\n$ sudo journalctl -b -1\n\n# 查看指定时间的日志\n$ sudo journalctl --since=\"2012-10-30 18:17:16\"\n$ sudo journalctl --since \"20 min ago\"\n$ sudo journalctl --since yesterday\n$ sudo journalctl --since \"2015-01-10\" --until \"2015-01-11 03:00\"\n$ sudo journalctl --since 09:00 --until \"1 hour ago\"\n\n# 显示尾部的最新10行日志\n$ sudo journalctl -n\n\n# 显示尾部指定行数的日志\n$ sudo journalctl -n 20\n\n# 实时滚动显示最新日志\n$ sudo journalctl -f\n\n# 查看指定服务的日志\n$ sudo journalctl /usr/lib/systemd/systemd\n\n# 查看指定进程的日志\n$ sudo journalctl _PID=1\n\n# 查看某个路径的脚本的日志\n$ sudo journalctl /usr/bin/bash\n\n# 查看指定用户的日志\n$ sudo journalctl _UID=33 --since today\n\n# 查看某个 Unit 的日志\n$ sudo journalctl -u nginx.service\n$ sudo journalctl -u nginx.service --since today\n\n# 实时滚动显示某个 Unit 的最新日志\n$ sudo journalctl -u nginx.service -f\n\n# 合并显示多个 Unit 的日志\n$ journalctl -u nginx.service -u php-fpm.service --since today\n\n# 查看指定优先级（及其以上级别）的日志，共有8级\n# 0: emerg\n# 1: alert\n# 2: crit\n# 3: err\n# 4: warning\n# 5: notice\n# 6: info\n# 7: debug\n$ sudo journalctl -p err -b\n\n# 日志默认分页输出，--no-pager 改为正常的标准输出\n$ sudo journalctl --no-pager\n\n# 以 JSON 格式（单行）输出\n$ sudo journalctl -b -u nginx.service -o json\n\n# 以 JSON 格式（多行）输出，可读性更好\n$ sudo journalctl -b -u nginx.serviceqq\n -o json-pretty\n\n# 显示日志占据的硬盘空间\n$ sudo journalctl --disk-usage\n\n# 指定日志文件占据的最大空间\n$ sudo journalctl --vacuum-size=1G\n\n# 指定日志文件保存多久\n$ sudo journalctl --vacuum-time=1years\n```","slug":"Systemd","published":1,"updated":"2016-06-28T11:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzgzek10007egfynihe2tkp","content":"<p>Systemd 是 Linux 系统工具，用来启动守护进程，已成为大多数发行版的标准配置。<br><a id=\"more\"></a></p>\n<h1 id=\"由来\"><a href=\"#由来\" class=\"headerlink\" title=\"由来\"></a>由来</h1><p>历史上，Linux 的启动一直采用<code>init</code>进程。<br>下面的命令用来启动服务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo /etc/init.d/apache2 start</span><br><span class=\"line\"># 或者</span><br><span class=\"line\">$ service apache2 start</span><br></pre></td></tr></table></figure>\n<p>这种方法有两个缺点。<br>一是启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。<br>二是启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。</p>\n<h1 id=\"Systemd概述\"><a href=\"#Systemd概述\" class=\"headerlink\" title=\"Systemd概述\"></a>Systemd概述</h1><p>Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。<br>根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。<br>使用了 Systemd，就不需要再用init了。Systemd 取代了initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ systemctl --version</span><br></pre></td></tr></table></figure>\n<p>上面的命令查看 Systemd 的版本。<br>Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反”keep simple, keep stupid”的Unix 哲学。<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2016/bg2016030703.png\" alt=\"\"><br>（上图为 Systemd 架构图）</p>\n<h1 id=\"系统管理\"><a href=\"#系统管理\" class=\"headerlink\" title=\"系统管理\"></a>系统管理</h1><p>Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。</p>\n<h2 id=\"systemctl\"><a href=\"#systemctl\" class=\"headerlink\" title=\"systemctl\"></a>systemctl</h2><p>systemctl是 Systemd 的主命令，用于管理系统。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 重启系统</span><br><span class=\"line\">$ sudo systemctl reboot</span><br><span class=\"line\"></span><br><span class=\"line\"># 关闭系统，切断电源</span><br><span class=\"line\">$ sudo systemctl poweroff</span><br><span class=\"line\"></span><br><span class=\"line\"># CPU停止工作</span><br><span class=\"line\">$ sudo systemctl halt</span><br><span class=\"line\"></span><br><span class=\"line\"># 暂停系统</span><br><span class=\"line\">$ sudo systemctl suspend</span><br><span class=\"line\"></span><br><span class=\"line\"># 让系统进入冬眠状态</span><br><span class=\"line\">$ sudo systemctl hibernate</span><br><span class=\"line\"></span><br><span class=\"line\"># 让系统进入交互式休眠状态</span><br><span class=\"line\">$ sudo systemctl hybrid-sleep</span><br><span class=\"line\"></span><br><span class=\"line\"># 启动进入救援状态（单用户状态）</span><br><span class=\"line\">$ sudo systemctl rescue</span><br></pre></td></tr></table></figure>\n<h2 id=\"systemd-analyze\"><a href=\"#systemd-analyze\" class=\"headerlink\" title=\"systemd-analyze\"></a>systemd-analyze</h2><p>systemd-analyze命令用于查看启动耗时。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看启动耗时</span><br><span class=\"line\">$ systemd-analyze                                                                                       </span><br><span class=\"line\"></span><br><span class=\"line\"># 查看每个服务的启动耗时</span><br><span class=\"line\">$ systemd-analyze blame</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示瀑布状的启动过程流</span><br><span class=\"line\">$ systemd-analyze critical-chain</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示指定服务的启动流</span><br><span class=\"line\">$ systemd-analyze critical-chain atd.service</span><br></pre></td></tr></table></figure>\n<h2 id=\"hostnamectl\"><a href=\"#hostnamectl\" class=\"headerlink\" title=\"hostnamectl\"></a>hostnamectl</h2><p>hostnamectl命令用于查看当前主机的信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示当前主机的信息</span><br><span class=\"line\">$ hostnamectl</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置主机名。</span><br><span class=\"line\">$ sudo hostnamectl set-hostname rhel7</span><br></pre></td></tr></table></figure>\n<h2 id=\"localectl\"><a href=\"#localectl\" class=\"headerlink\" title=\"localectl\"></a>localectl</h2><p>localectl命令用于查看本地化设置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看本地化设置</span><br><span class=\"line\">$ localectl</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置本地化参数。</span><br><span class=\"line\">$ sudo localectl set-locale LANG=en_GB.utf8</span><br><span class=\"line\">$ sudo localectl set-keymap en_GB</span><br></pre></td></tr></table></figure>\n<h2 id=\"timedatectl\"><a href=\"#timedatectl\" class=\"headerlink\" title=\"timedatectl\"></a>timedatectl</h2><p>timedatectl命令用于查看当前时区设置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看当前时区设置</span><br><span class=\"line\">$ timedatectl</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示所有可用的时区</span><br><span class=\"line\">$ timedatectl list-timezones                                                                                   </span><br><span class=\"line\"></span><br><span class=\"line\"># 设置当前时区</span><br><span class=\"line\">$ sudo timedatectl set-timezone America/New_York</span><br><span class=\"line\">$ sudo timedatectl set-time YYYY-MM-DD</span><br><span class=\"line\">$ sudo timedatectl set-time HH:MM:SS</span><br></pre></td></tr></table></figure>\n<h2 id=\"loginctl\"><a href=\"#loginctl\" class=\"headerlink\" title=\"loginctl\"></a>loginctl</h2><p>loginctl命令用于查看当前登录的用户。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列出当前session</span><br><span class=\"line\">$ loginctl list-sessions</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出当前登录用户</span><br><span class=\"line\">$ loginctl list-users</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出显示指定用户的信息</span><br><span class=\"line\">$ loginctl show-user ruanyf</span><br></pre></td></tr></table></figure>\n<h1 id=\"Until\"><a href=\"#Until\" class=\"headerlink\" title=\"Until\"></a>Until</h1><h2 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h2><p>Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。<br>Unit 一共分成12种。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Service unit：系统服务</span><br><span class=\"line\">Target unit：多个 Unit 构成的一个组</span><br><span class=\"line\">Device Unit：硬件设备</span><br><span class=\"line\">Mount Unit：文件系统的挂载点</span><br><span class=\"line\">Automount Unit：自动挂载点</span><br><span class=\"line\">Path Unit：文件或路径</span><br><span class=\"line\">Scope Unit：不是由 Systemd 启动的外部进程</span><br><span class=\"line\">Slice Unit：进程组</span><br><span class=\"line\">Snapshot Unit：Systemd 快照，可以切回某个快照</span><br><span class=\"line\">Socket Unit：进程间通信的 socket</span><br><span class=\"line\">Swap Unit：swap 文件</span><br><span class=\"line\">Timer Unit：定时器</span><br></pre></td></tr></table></figure>\n<p><code>systemctl list-units</code>命令可以查看当前系统的所有 Unit 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列出正在运行的 Unit</span><br><span class=\"line\">$ systemctl list-units</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有Unit，包括没有找到配置文件的或者启动失败的</span><br><span class=\"line\">$ systemctl list-units --all</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有没有运行的 Unit</span><br><span class=\"line\">$ systemctl list-units --all --state=inactive</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有加载失败的 Unit</span><br><span class=\"line\">$ systemctl list-units --failed</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有正在运行的、类型为 service 的 Unit</span><br><span class=\"line\">$ systemctl list-units --type=service</span><br></pre></td></tr></table></figure>\n<h2 id=\"Unit的状态\"><a href=\"#Unit的状态\" class=\"headerlink\" title=\"Unit的状态\"></a>Unit的状态</h2><p><code>systemctl status</code>命令用于查看系统状态和单个 Unit 的状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示系统状态</span><br><span class=\"line\">$ systemctl status</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示单个 Unit 的状态</span><br><span class=\"line\">$ sysystemctl status bluetooth.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示远程主机的某个 Unit 的状态</span><br><span class=\"line\">$ systemctl -H root@rhel7.example.com status httpd.service</span><br></pre></td></tr></table></figure>\n<p>除了<code>status</code>命令，<code>systemctl</code>还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示某个 Unit 是否正在运行</span><br><span class=\"line\">$ systemctl is-active application.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个 Unit 是否处于启动失败状态</span><br><span class=\"line\">$ systemctl is-failed application.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个 Unit 服务是否建立了启动链接</span><br><span class=\"line\">$ systemctl is-enabled application.service</span><br></pre></td></tr></table></figure>\n<h2 id=\"Unit管理\"><a href=\"#Unit管理\" class=\"headerlink\" title=\"Unit管理\"></a>Unit管理</h2><p>对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 立即启动一个服务</span><br><span class=\"line\">$ sudo systemctl start apache.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 立即停止一个服务</span><br><span class=\"line\">$ sudo systemctl stop apache.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 重启一个服务</span><br><span class=\"line\">$ sudo systemctl restart apache.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 杀死一个服务的所有子进程</span><br><span class=\"line\">$ sudo systemctl kill apache.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 重新加载一个服务的配置文件</span><br><span class=\"line\">$ sudo systemctl reload apache.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 重载所有修改过的配置文件</span><br><span class=\"line\">$ sudo systemctl daemon-reload</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个 Unit 的所有底层参数</span><br><span class=\"line\">$ systemctl show httpd.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个 Unit 的指定属性的值</span><br><span class=\"line\">$ systemctl show -p CPUShares httpd.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置某个 Unit 的指定属性</span><br><span class=\"line\">$ sudo systemctl set-property httpd.service CPUShares=500</span><br></pre></td></tr></table></figure>\n<h2 id=\"依赖关系\"><a href=\"#依赖关系\" class=\"headerlink\" title=\"依赖关系\"></a>依赖关系</h2><p>Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。<br><code>systemctl list-dependencies</code>命令列出一个 Unit 的所有依赖。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ systemctl list-dependencies nginx.service</span><br></pre></td></tr></table></figure>\n<p>上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用<code>--all</code>参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ systemctl list-dependencies --all nginx.service</span><br></pre></td></tr></table></figure>\n<h1 id=\"Unit配置文件\"><a href=\"#Unit配置文件\" class=\"headerlink\" title=\"Unit配置文件\"></a>Unit配置文件</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。<br>Systemd 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的配置文件存放在那个目录。<br><code>systemctl enable</code>命令用于在上面两个目录之间，建立符号链接关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo systemctl enable clamd@scan.service</span><br><span class=\"line\"># 等同于</span><br><span class=\"line\">$ sudo ln -s &apos;/usr/lib/systemd/system/clamd@scan.service&apos; &apos;/etc/systemd/system/m</span><br></pre></td></tr></table></figure>\n<p>如果配置文件里面设置了开机启动，<code>systemctl enable</code>命令相当于激活开机启动。<br>与之对应的，<code>systemctl disable</code>命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo systemctl disable clamd@scan.service</span><br></pre></td></tr></table></figure>\n<p>配置文件的后缀名，就是该 Unit 的种类，比如sshd.socket。如果省略，Systemd 默认后缀名为.service，所以sshd会被理解成sshd.service。</p>\n<h2 id=\"配置文件的状态\"><a href=\"#配置文件的状态\" class=\"headerlink\" title=\"配置文件的状态\"></a>配置文件的状态</h2><p><code>systemctl list-unit-files</code>命令用于列出所有配置文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列出所有配置文件</span><br><span class=\"line\">$ systemctl list-unit-files</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出指定类型的配置文件</span><br><span class=\"line\">$ systemctl list-unit-files --type=service</span><br></pre></td></tr></table></figure>\n<p>这个命令会输出一个列表。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ systemctl list-unit-files</span><br><span class=\"line\"></span><br><span class=\"line\">UNIT FILE              STATE</span><br><span class=\"line\">chronyd.service        enabled</span><br><span class=\"line\">clamd@.service         static</span><br><span class=\"line\">clamd@scan.service     disabled</span><br></pre></td></tr></table></figure>\n<p>这个列表显示每个配置文件的状态，一共有四种。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enabled：已建立启动链接</span><br><span class=\"line\">disabled：没建立启动链接</span><br><span class=\"line\">static：该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖</span><br><span class=\"line\">masked：该配置文件被禁止建立启动链接</span><br></pre></td></tr></table></figure>\n<p>注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的<code>systemctl status</code>命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ systemctl status bluetooth.service</span><br></pre></td></tr></table></figure>\n<p>一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo systemctl daemon-reload</span><br><span class=\"line\">$ sudo systemctl restart httpd.service</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置文件的格式\"><a href=\"#配置文件的格式\" class=\"headerlink\" title=\"配置文件的格式\"></a>配置文件的格式</h2><p>配置文件就是普通的文本文件，可以用文本编辑器打开。<br><code>systemctl cat</code>命令可以查看配置文件的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ systemctl cat atd.service</span><br><span class=\"line\"></span><br><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=ATD daemon</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=forking</span><br><span class=\"line\">ExecStart=/usr/bin/atd</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n<p>从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如[Unit]。注意，配置文件的区块名和字段名，都是大小写敏感的。<br>每个区块内部是一些等号连接的键值对。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Section]</span><br><span class=\"line\">Directive1=value</span><br><span class=\"line\">Directive2=value</span><br><span class=\"line\"></span><br><span class=\"line\">. . .</span><br></pre></td></tr></table></figure>\n<p>注意，键值对的等号两侧不能有空格。</p>\n<h2 id=\"配置文件的区块\"><a href=\"#配置文件的区块\" class=\"headerlink\" title=\"配置文件的区块\"></a>配置文件的区块</h2><p>[Unit]区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Description：简短描述</span><br><span class=\"line\">Documentation：文档地址</span><br><span class=\"line\">Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败</span><br><span class=\"line\">Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败</span><br><span class=\"line\">BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行</span><br><span class=\"line\">Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动</span><br><span class=\"line\">After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动</span><br><span class=\"line\">Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行</span><br><span class=\"line\">Condition...：当前 Unit 运行必须满足的条件，否则不会运行</span><br><span class=\"line\">Assert...：当前 Unit 运行必须满足的条件，否则会报启动失败</span><br></pre></td></tr></table></figure>\n<p>[Install]通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中</span><br><span class=\"line\">RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中</span><br><span class=\"line\">Alias：当前 Unit 可用于启动的别名</span><br><span class=\"line\">Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit</span><br></pre></td></tr></table></figure>\n<p>[Service]区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Type：定义启动时的进程行为。它有以下几种值。</span><br><span class=\"line\">Type=simple：默认值，执行ExecStart指定的命令，启动主进程</span><br><span class=\"line\">Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</span><br><span class=\"line\">Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行</span><br><span class=\"line\">Type=dbus：当前服务通过D-Bus启动</span><br><span class=\"line\">Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行</span><br><span class=\"line\">Type=idle：若有其他任务执行完毕，当前服务才会运行</span><br><span class=\"line\">ExecStart：启动当前服务的命令</span><br><span class=\"line\">ExecStartPre：启动当前服务之前执行的命令</span><br><span class=\"line\">ExecStartPost：启动当前服务之后执行的命令</span><br><span class=\"line\">ExecReload：重启当前服务时执行的命令</span><br><span class=\"line\">ExecStop：停止当前服务时执行的命令</span><br><span class=\"line\">ExecStopPost：停止当其服务之后执行的命令</span><br><span class=\"line\">RestartSec：自动重启当前服务间隔的秒数</span><br><span class=\"line\">Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog</span><br><span class=\"line\">TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数</span><br><span class=\"line\">Environment：指定环境变量</span><br></pre></td></tr></table></figure>\n<p>Unit 配置文件的完整字段清单，请参考<a href=\"https://www.freedesktop.org/software/systemd/man/systemd.unit.html\" target=\"_blank\" rel=\"external\">官方文档</a>。</p>\n<h1 id=\"Target\"><a href=\"#Target\" class=\"headerlink\" title=\"Target\"></a>Target</h1><p>启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。<br>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。<br>传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看当前系统的所有 Target</span><br><span class=\"line\">$ systemctl list-unit-files --type=target</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看一个 Target 包含的所有 Unit</span><br><span class=\"line\">$ systemctl list-dependencies multi-user.target</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看启动时的默认 Target</span><br><span class=\"line\">$ systemctl get-default</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置启动时的默认 Target</span><br><span class=\"line\">$ sudo systemctl set-default multi-user.target</span><br><span class=\"line\"></span><br><span class=\"line\"># 切换 Target 时，默认不关闭前一个 Target 启动的进程，</span><br><span class=\"line\"># systemctl isolate 命令改变这种行为，</span><br><span class=\"line\"># 关闭前一个 Target 里面所有不属于后一个 Target 的进程</span><br><span class=\"line\">$ sudo systemctl isolate multi-user.target</span><br></pre></td></tr></table></figure>\n<p>Target 与 传统 RunLevel 的对应关系如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Traditional runlevel      New target name     Symbolically linked to...</span><br><span class=\"line\"></span><br><span class=\"line\">Runlevel 0           |    runlevel0.target -&gt; poweroff.target</span><br><span class=\"line\">Runlevel 1           |    runlevel1.target -&gt; rescue.target</span><br><span class=\"line\">Runlevel 2           |    runlevel2.target -&gt; multi-user.target</span><br><span class=\"line\">Runlevel 3           |    runlevel3.target -&gt; multi-user.target</span><br><span class=\"line\">Runlevel 4           |    runlevel4.target -&gt; multi-user.target</span><br><span class=\"line\">Runlevel 5           |    runlevel5.target -&gt; graphical.target</span><br><span class=\"line\">Runlevel 6           |    runlevel6.target -&gt; reboot.target</span><br></pre></td></tr></table></figure>\n<p>它与init进程的主要差别如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</span><br><span class=\"line\">（2）启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。</span><br><span class=\"line\">（3）配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。</span><br></pre></td></tr></table></figure>\n<h1 id=\"日志管理\"><a href=\"#日志管理\" class=\"headerlink\" title=\"日志管理\"></a>日志管理</h1><p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用journalctl一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是/etc/systemd/journald.conf。<br>journalctl功能强大，用法非常多。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看所有日志（默认情况下 ，只保存本次启动的日志）</span><br><span class=\"line\">$ sudo journalctl</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看内核日志（不显示应用日志）</span><br><span class=\"line\">$ sudo journalctl -k</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看系统本次启动的日志</span><br><span class=\"line\">$ sudo journalctl -b</span><br><span class=\"line\">$ sudo journalctl -b -0</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看上一次启动的日志（需更改设置）</span><br><span class=\"line\">$ sudo journalctl -b -1</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定时间的日志</span><br><span class=\"line\">$ sudo journalctl --since=&quot;2012-10-30 18:17:16&quot;</span><br><span class=\"line\">$ sudo journalctl --since &quot;20 min ago&quot;</span><br><span class=\"line\">$ sudo journalctl --since yesterday</span><br><span class=\"line\">$ sudo journalctl --since &quot;2015-01-10&quot; --until &quot;2015-01-11 03:00&quot;</span><br><span class=\"line\">$ sudo journalctl --since 09:00 --until &quot;1 hour ago&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示尾部的最新10行日志</span><br><span class=\"line\">$ sudo journalctl -n</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示尾部指定行数的日志</span><br><span class=\"line\">$ sudo journalctl -n 20</span><br><span class=\"line\"></span><br><span class=\"line\"># 实时滚动显示最新日志</span><br><span class=\"line\">$ sudo journalctl -f</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定服务的日志</span><br><span class=\"line\">$ sudo journalctl /usr/lib/systemd/systemd</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定进程的日志</span><br><span class=\"line\">$ sudo journalctl _PID=1</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看某个路径的脚本的日志</span><br><span class=\"line\">$ sudo journalctl /usr/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定用户的日志</span><br><span class=\"line\">$ sudo journalctl _UID=33 --since today</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看某个 Unit 的日志</span><br><span class=\"line\">$ sudo journalctl -u nginx.service</span><br><span class=\"line\">$ sudo journalctl -u nginx.service --since today</span><br><span class=\"line\"></span><br><span class=\"line\"># 实时滚动显示某个 Unit 的最新日志</span><br><span class=\"line\">$ sudo journalctl -u nginx.service -f</span><br><span class=\"line\"></span><br><span class=\"line\"># 合并显示多个 Unit 的日志</span><br><span class=\"line\">$ journalctl -u nginx.service -u php-fpm.service --since today</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定优先级（及其以上级别）的日志，共有8级</span><br><span class=\"line\"># 0: emerg</span><br><span class=\"line\"># 1: alert</span><br><span class=\"line\"># 2: crit</span><br><span class=\"line\"># 3: err</span><br><span class=\"line\"># 4: warning</span><br><span class=\"line\"># 5: notice</span><br><span class=\"line\"># 6: info</span><br><span class=\"line\"># 7: debug</span><br><span class=\"line\">$ sudo journalctl -p err -b</span><br><span class=\"line\"></span><br><span class=\"line\"># 日志默认分页输出，--no-pager 改为正常的标准输出</span><br><span class=\"line\">$ sudo journalctl --no-pager</span><br><span class=\"line\"></span><br><span class=\"line\"># 以 JSON 格式（单行）输出</span><br><span class=\"line\">$ sudo journalctl -b -u nginx.service -o json</span><br><span class=\"line\"></span><br><span class=\"line\"># 以 JSON 格式（多行）输出，可读性更好</span><br><span class=\"line\">$ sudo journalctl -b -u nginx.serviceqq</span><br><span class=\"line\"> -o json-pretty</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示日志占据的硬盘空间</span><br><span class=\"line\">$ sudo journalctl --disk-usage</span><br><span class=\"line\"></span><br><span class=\"line\"># 指定日志文件占据的最大空间</span><br><span class=\"line\">$ sudo journalctl --vacuum-size=1G</span><br><span class=\"line\"></span><br><span class=\"line\"># 指定日志文件保存多久</span><br><span class=\"line\">$ sudo journalctl --vacuum-time=1years</span><br></pre></td></tr></table></figure>","excerpt":"<p>Systemd 是 Linux 系统工具，用来启动守护进程，已成为大多数发行版的标准配置。<br>","more":"</p>\n<h1 id=\"由来\"><a href=\"#由来\" class=\"headerlink\" title=\"由来\"></a>由来</h1><p>历史上，Linux 的启动一直采用<code>init</code>进程。<br>下面的命令用来启动服务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo /etc/init.d/apache2 start</span><br><span class=\"line\"># 或者</span><br><span class=\"line\">$ service apache2 start</span><br></pre></td></tr></table></figure>\n<p>这种方法有两个缺点。<br>一是启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。<br>二是启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。</p>\n<h1 id=\"Systemd概述\"><a href=\"#Systemd概述\" class=\"headerlink\" title=\"Systemd概述\"></a>Systemd概述</h1><p>Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。<br>根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。<br>使用了 Systemd，就不需要再用init了。Systemd 取代了initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ systemctl --version</span><br></pre></td></tr></table></figure>\n<p>上面的命令查看 Systemd 的版本。<br>Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反”keep simple, keep stupid”的Unix 哲学。<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2016/bg2016030703.png\" alt=\"\"><br>（上图为 Systemd 架构图）</p>\n<h1 id=\"系统管理\"><a href=\"#系统管理\" class=\"headerlink\" title=\"系统管理\"></a>系统管理</h1><p>Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。</p>\n<h2 id=\"systemctl\"><a href=\"#systemctl\" class=\"headerlink\" title=\"systemctl\"></a>systemctl</h2><p>systemctl是 Systemd 的主命令，用于管理系统。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 重启系统</span><br><span class=\"line\">$ sudo systemctl reboot</span><br><span class=\"line\"></span><br><span class=\"line\"># 关闭系统，切断电源</span><br><span class=\"line\">$ sudo systemctl poweroff</span><br><span class=\"line\"></span><br><span class=\"line\"># CPU停止工作</span><br><span class=\"line\">$ sudo systemctl halt</span><br><span class=\"line\"></span><br><span class=\"line\"># 暂停系统</span><br><span class=\"line\">$ sudo systemctl suspend</span><br><span class=\"line\"></span><br><span class=\"line\"># 让系统进入冬眠状态</span><br><span class=\"line\">$ sudo systemctl hibernate</span><br><span class=\"line\"></span><br><span class=\"line\"># 让系统进入交互式休眠状态</span><br><span class=\"line\">$ sudo systemctl hybrid-sleep</span><br><span class=\"line\"></span><br><span class=\"line\"># 启动进入救援状态（单用户状态）</span><br><span class=\"line\">$ sudo systemctl rescue</span><br></pre></td></tr></table></figure>\n<h2 id=\"systemd-analyze\"><a href=\"#systemd-analyze\" class=\"headerlink\" title=\"systemd-analyze\"></a>systemd-analyze</h2><p>systemd-analyze命令用于查看启动耗时。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看启动耗时</span><br><span class=\"line\">$ systemd-analyze                                                                                       </span><br><span class=\"line\"></span><br><span class=\"line\"># 查看每个服务的启动耗时</span><br><span class=\"line\">$ systemd-analyze blame</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示瀑布状的启动过程流</span><br><span class=\"line\">$ systemd-analyze critical-chain</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示指定服务的启动流</span><br><span class=\"line\">$ systemd-analyze critical-chain atd.service</span><br></pre></td></tr></table></figure>\n<h2 id=\"hostnamectl\"><a href=\"#hostnamectl\" class=\"headerlink\" title=\"hostnamectl\"></a>hostnamectl</h2><p>hostnamectl命令用于查看当前主机的信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示当前主机的信息</span><br><span class=\"line\">$ hostnamectl</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置主机名。</span><br><span class=\"line\">$ sudo hostnamectl set-hostname rhel7</span><br></pre></td></tr></table></figure>\n<h2 id=\"localectl\"><a href=\"#localectl\" class=\"headerlink\" title=\"localectl\"></a>localectl</h2><p>localectl命令用于查看本地化设置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看本地化设置</span><br><span class=\"line\">$ localectl</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置本地化参数。</span><br><span class=\"line\">$ sudo localectl set-locale LANG=en_GB.utf8</span><br><span class=\"line\">$ sudo localectl set-keymap en_GB</span><br></pre></td></tr></table></figure>\n<h2 id=\"timedatectl\"><a href=\"#timedatectl\" class=\"headerlink\" title=\"timedatectl\"></a>timedatectl</h2><p>timedatectl命令用于查看当前时区设置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看当前时区设置</span><br><span class=\"line\">$ timedatectl</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示所有可用的时区</span><br><span class=\"line\">$ timedatectl list-timezones                                                                                   </span><br><span class=\"line\"></span><br><span class=\"line\"># 设置当前时区</span><br><span class=\"line\">$ sudo timedatectl set-timezone America/New_York</span><br><span class=\"line\">$ sudo timedatectl set-time YYYY-MM-DD</span><br><span class=\"line\">$ sudo timedatectl set-time HH:MM:SS</span><br></pre></td></tr></table></figure>\n<h2 id=\"loginctl\"><a href=\"#loginctl\" class=\"headerlink\" title=\"loginctl\"></a>loginctl</h2><p>loginctl命令用于查看当前登录的用户。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列出当前session</span><br><span class=\"line\">$ loginctl list-sessions</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出当前登录用户</span><br><span class=\"line\">$ loginctl list-users</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出显示指定用户的信息</span><br><span class=\"line\">$ loginctl show-user ruanyf</span><br></pre></td></tr></table></figure>\n<h1 id=\"Until\"><a href=\"#Until\" class=\"headerlink\" title=\"Until\"></a>Until</h1><h2 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h2><p>Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。<br>Unit 一共分成12种。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Service unit：系统服务</span><br><span class=\"line\">Target unit：多个 Unit 构成的一个组</span><br><span class=\"line\">Device Unit：硬件设备</span><br><span class=\"line\">Mount Unit：文件系统的挂载点</span><br><span class=\"line\">Automount Unit：自动挂载点</span><br><span class=\"line\">Path Unit：文件或路径</span><br><span class=\"line\">Scope Unit：不是由 Systemd 启动的外部进程</span><br><span class=\"line\">Slice Unit：进程组</span><br><span class=\"line\">Snapshot Unit：Systemd 快照，可以切回某个快照</span><br><span class=\"line\">Socket Unit：进程间通信的 socket</span><br><span class=\"line\">Swap Unit：swap 文件</span><br><span class=\"line\">Timer Unit：定时器</span><br></pre></td></tr></table></figure>\n<p><code>systemctl list-units</code>命令可以查看当前系统的所有 Unit 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列出正在运行的 Unit</span><br><span class=\"line\">$ systemctl list-units</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有Unit，包括没有找到配置文件的或者启动失败的</span><br><span class=\"line\">$ systemctl list-units --all</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有没有运行的 Unit</span><br><span class=\"line\">$ systemctl list-units --all --state=inactive</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有加载失败的 Unit</span><br><span class=\"line\">$ systemctl list-units --failed</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有正在运行的、类型为 service 的 Unit</span><br><span class=\"line\">$ systemctl list-units --type=service</span><br></pre></td></tr></table></figure>\n<h2 id=\"Unit的状态\"><a href=\"#Unit的状态\" class=\"headerlink\" title=\"Unit的状态\"></a>Unit的状态</h2><p><code>systemctl status</code>命令用于查看系统状态和单个 Unit 的状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示系统状态</span><br><span class=\"line\">$ systemctl status</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示单个 Unit 的状态</span><br><span class=\"line\">$ sysystemctl status bluetooth.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示远程主机的某个 Unit 的状态</span><br><span class=\"line\">$ systemctl -H root@rhel7.example.com status httpd.service</span><br></pre></td></tr></table></figure>\n<p>除了<code>status</code>命令，<code>systemctl</code>还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示某个 Unit 是否正在运行</span><br><span class=\"line\">$ systemctl is-active application.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个 Unit 是否处于启动失败状态</span><br><span class=\"line\">$ systemctl is-failed application.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个 Unit 服务是否建立了启动链接</span><br><span class=\"line\">$ systemctl is-enabled application.service</span><br></pre></td></tr></table></figure>\n<h2 id=\"Unit管理\"><a href=\"#Unit管理\" class=\"headerlink\" title=\"Unit管理\"></a>Unit管理</h2><p>对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 立即启动一个服务</span><br><span class=\"line\">$ sudo systemctl start apache.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 立即停止一个服务</span><br><span class=\"line\">$ sudo systemctl stop apache.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 重启一个服务</span><br><span class=\"line\">$ sudo systemctl restart apache.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 杀死一个服务的所有子进程</span><br><span class=\"line\">$ sudo systemctl kill apache.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 重新加载一个服务的配置文件</span><br><span class=\"line\">$ sudo systemctl reload apache.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 重载所有修改过的配置文件</span><br><span class=\"line\">$ sudo systemctl daemon-reload</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个 Unit 的所有底层参数</span><br><span class=\"line\">$ systemctl show httpd.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个 Unit 的指定属性的值</span><br><span class=\"line\">$ systemctl show -p CPUShares httpd.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置某个 Unit 的指定属性</span><br><span class=\"line\">$ sudo systemctl set-property httpd.service CPUShares=500</span><br></pre></td></tr></table></figure>\n<h2 id=\"依赖关系\"><a href=\"#依赖关系\" class=\"headerlink\" title=\"依赖关系\"></a>依赖关系</h2><p>Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。<br><code>systemctl list-dependencies</code>命令列出一个 Unit 的所有依赖。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ systemctl list-dependencies nginx.service</span><br></pre></td></tr></table></figure>\n<p>上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用<code>--all</code>参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ systemctl list-dependencies --all nginx.service</span><br></pre></td></tr></table></figure>\n<h1 id=\"Unit配置文件\"><a href=\"#Unit配置文件\" class=\"headerlink\" title=\"Unit配置文件\"></a>Unit配置文件</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。<br>Systemd 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的配置文件存放在那个目录。<br><code>systemctl enable</code>命令用于在上面两个目录之间，建立符号链接关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo systemctl enable clamd@scan.service</span><br><span class=\"line\"># 等同于</span><br><span class=\"line\">$ sudo ln -s &apos;/usr/lib/systemd/system/clamd@scan.service&apos; &apos;/etc/systemd/system/m</span><br></pre></td></tr></table></figure>\n<p>如果配置文件里面设置了开机启动，<code>systemctl enable</code>命令相当于激活开机启动。<br>与之对应的，<code>systemctl disable</code>命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo systemctl disable clamd@scan.service</span><br></pre></td></tr></table></figure>\n<p>配置文件的后缀名，就是该 Unit 的种类，比如sshd.socket。如果省略，Systemd 默认后缀名为.service，所以sshd会被理解成sshd.service。</p>\n<h2 id=\"配置文件的状态\"><a href=\"#配置文件的状态\" class=\"headerlink\" title=\"配置文件的状态\"></a>配置文件的状态</h2><p><code>systemctl list-unit-files</code>命令用于列出所有配置文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列出所有配置文件</span><br><span class=\"line\">$ systemctl list-unit-files</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出指定类型的配置文件</span><br><span class=\"line\">$ systemctl list-unit-files --type=service</span><br></pre></td></tr></table></figure>\n<p>这个命令会输出一个列表。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ systemctl list-unit-files</span><br><span class=\"line\"></span><br><span class=\"line\">UNIT FILE              STATE</span><br><span class=\"line\">chronyd.service        enabled</span><br><span class=\"line\">clamd@.service         static</span><br><span class=\"line\">clamd@scan.service     disabled</span><br></pre></td></tr></table></figure>\n<p>这个列表显示每个配置文件的状态，一共有四种。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enabled：已建立启动链接</span><br><span class=\"line\">disabled：没建立启动链接</span><br><span class=\"line\">static：该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖</span><br><span class=\"line\">masked：该配置文件被禁止建立启动链接</span><br></pre></td></tr></table></figure>\n<p>注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的<code>systemctl status</code>命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ systemctl status bluetooth.service</span><br></pre></td></tr></table></figure>\n<p>一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo systemctl daemon-reload</span><br><span class=\"line\">$ sudo systemctl restart httpd.service</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置文件的格式\"><a href=\"#配置文件的格式\" class=\"headerlink\" title=\"配置文件的格式\"></a>配置文件的格式</h2><p>配置文件就是普通的文本文件，可以用文本编辑器打开。<br><code>systemctl cat</code>命令可以查看配置文件的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ systemctl cat atd.service</span><br><span class=\"line\"></span><br><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=ATD daemon</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=forking</span><br><span class=\"line\">ExecStart=/usr/bin/atd</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n<p>从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如[Unit]。注意，配置文件的区块名和字段名，都是大小写敏感的。<br>每个区块内部是一些等号连接的键值对。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Section]</span><br><span class=\"line\">Directive1=value</span><br><span class=\"line\">Directive2=value</span><br><span class=\"line\"></span><br><span class=\"line\">. . .</span><br></pre></td></tr></table></figure>\n<p>注意，键值对的等号两侧不能有空格。</p>\n<h2 id=\"配置文件的区块\"><a href=\"#配置文件的区块\" class=\"headerlink\" title=\"配置文件的区块\"></a>配置文件的区块</h2><p>[Unit]区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Description：简短描述</span><br><span class=\"line\">Documentation：文档地址</span><br><span class=\"line\">Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败</span><br><span class=\"line\">Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败</span><br><span class=\"line\">BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行</span><br><span class=\"line\">Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动</span><br><span class=\"line\">After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动</span><br><span class=\"line\">Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行</span><br><span class=\"line\">Condition...：当前 Unit 运行必须满足的条件，否则不会运行</span><br><span class=\"line\">Assert...：当前 Unit 运行必须满足的条件，否则会报启动失败</span><br></pre></td></tr></table></figure>\n<p>[Install]通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中</span><br><span class=\"line\">RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中</span><br><span class=\"line\">Alias：当前 Unit 可用于启动的别名</span><br><span class=\"line\">Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit</span><br></pre></td></tr></table></figure>\n<p>[Service]区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Type：定义启动时的进程行为。它有以下几种值。</span><br><span class=\"line\">Type=simple：默认值，执行ExecStart指定的命令，启动主进程</span><br><span class=\"line\">Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</span><br><span class=\"line\">Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行</span><br><span class=\"line\">Type=dbus：当前服务通过D-Bus启动</span><br><span class=\"line\">Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行</span><br><span class=\"line\">Type=idle：若有其他任务执行完毕，当前服务才会运行</span><br><span class=\"line\">ExecStart：启动当前服务的命令</span><br><span class=\"line\">ExecStartPre：启动当前服务之前执行的命令</span><br><span class=\"line\">ExecStartPost：启动当前服务之后执行的命令</span><br><span class=\"line\">ExecReload：重启当前服务时执行的命令</span><br><span class=\"line\">ExecStop：停止当前服务时执行的命令</span><br><span class=\"line\">ExecStopPost：停止当其服务之后执行的命令</span><br><span class=\"line\">RestartSec：自动重启当前服务间隔的秒数</span><br><span class=\"line\">Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog</span><br><span class=\"line\">TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数</span><br><span class=\"line\">Environment：指定环境变量</span><br></pre></td></tr></table></figure>\n<p>Unit 配置文件的完整字段清单，请参考<a href=\"https://www.freedesktop.org/software/systemd/man/systemd.unit.html\">官方文档</a>。</p>\n<h1 id=\"Target\"><a href=\"#Target\" class=\"headerlink\" title=\"Target\"></a>Target</h1><p>启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。<br>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。<br>传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看当前系统的所有 Target</span><br><span class=\"line\">$ systemctl list-unit-files --type=target</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看一个 Target 包含的所有 Unit</span><br><span class=\"line\">$ systemctl list-dependencies multi-user.target</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看启动时的默认 Target</span><br><span class=\"line\">$ systemctl get-default</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置启动时的默认 Target</span><br><span class=\"line\">$ sudo systemctl set-default multi-user.target</span><br><span class=\"line\"></span><br><span class=\"line\"># 切换 Target 时，默认不关闭前一个 Target 启动的进程，</span><br><span class=\"line\"># systemctl isolate 命令改变这种行为，</span><br><span class=\"line\"># 关闭前一个 Target 里面所有不属于后一个 Target 的进程</span><br><span class=\"line\">$ sudo systemctl isolate multi-user.target</span><br></pre></td></tr></table></figure>\n<p>Target 与 传统 RunLevel 的对应关系如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Traditional runlevel      New target name     Symbolically linked to...</span><br><span class=\"line\"></span><br><span class=\"line\">Runlevel 0           |    runlevel0.target -&gt; poweroff.target</span><br><span class=\"line\">Runlevel 1           |    runlevel1.target -&gt; rescue.target</span><br><span class=\"line\">Runlevel 2           |    runlevel2.target -&gt; multi-user.target</span><br><span class=\"line\">Runlevel 3           |    runlevel3.target -&gt; multi-user.target</span><br><span class=\"line\">Runlevel 4           |    runlevel4.target -&gt; multi-user.target</span><br><span class=\"line\">Runlevel 5           |    runlevel5.target -&gt; graphical.target</span><br><span class=\"line\">Runlevel 6           |    runlevel6.target -&gt; reboot.target</span><br></pre></td></tr></table></figure>\n<p>它与init进程的主要差别如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</span><br><span class=\"line\">（2）启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。</span><br><span class=\"line\">（3）配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。</span><br></pre></td></tr></table></figure>\n<h1 id=\"日志管理\"><a href=\"#日志管理\" class=\"headerlink\" title=\"日志管理\"></a>日志管理</h1><p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用journalctl一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是/etc/systemd/journald.conf。<br>journalctl功能强大，用法非常多。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看所有日志（默认情况下 ，只保存本次启动的日志）</span><br><span class=\"line\">$ sudo journalctl</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看内核日志（不显示应用日志）</span><br><span class=\"line\">$ sudo journalctl -k</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看系统本次启动的日志</span><br><span class=\"line\">$ sudo journalctl -b</span><br><span class=\"line\">$ sudo journalctl -b -0</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看上一次启动的日志（需更改设置）</span><br><span class=\"line\">$ sudo journalctl -b -1</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定时间的日志</span><br><span class=\"line\">$ sudo journalctl --since=&quot;2012-10-30 18:17:16&quot;</span><br><span class=\"line\">$ sudo journalctl --since &quot;20 min ago&quot;</span><br><span class=\"line\">$ sudo journalctl --since yesterday</span><br><span class=\"line\">$ sudo journalctl --since &quot;2015-01-10&quot; --until &quot;2015-01-11 03:00&quot;</span><br><span class=\"line\">$ sudo journalctl --since 09:00 --until &quot;1 hour ago&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示尾部的最新10行日志</span><br><span class=\"line\">$ sudo journalctl -n</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示尾部指定行数的日志</span><br><span class=\"line\">$ sudo journalctl -n 20</span><br><span class=\"line\"></span><br><span class=\"line\"># 实时滚动显示最新日志</span><br><span class=\"line\">$ sudo journalctl -f</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定服务的日志</span><br><span class=\"line\">$ sudo journalctl /usr/lib/systemd/systemd</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定进程的日志</span><br><span class=\"line\">$ sudo journalctl _PID=1</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看某个路径的脚本的日志</span><br><span class=\"line\">$ sudo journalctl /usr/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定用户的日志</span><br><span class=\"line\">$ sudo journalctl _UID=33 --since today</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看某个 Unit 的日志</span><br><span class=\"line\">$ sudo journalctl -u nginx.service</span><br><span class=\"line\">$ sudo journalctl -u nginx.service --since today</span><br><span class=\"line\"></span><br><span class=\"line\"># 实时滚动显示某个 Unit 的最新日志</span><br><span class=\"line\">$ sudo journalctl -u nginx.service -f</span><br><span class=\"line\"></span><br><span class=\"line\"># 合并显示多个 Unit 的日志</span><br><span class=\"line\">$ journalctl -u nginx.service -u php-fpm.service --since today</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定优先级（及其以上级别）的日志，共有8级</span><br><span class=\"line\"># 0: emerg</span><br><span class=\"line\"># 1: alert</span><br><span class=\"line\"># 2: crit</span><br><span class=\"line\"># 3: err</span><br><span class=\"line\"># 4: warning</span><br><span class=\"line\"># 5: notice</span><br><span class=\"line\"># 6: info</span><br><span class=\"line\"># 7: debug</span><br><span class=\"line\">$ sudo journalctl -p err -b</span><br><span class=\"line\"></span><br><span class=\"line\"># 日志默认分页输出，--no-pager 改为正常的标准输出</span><br><span class=\"line\">$ sudo journalctl --no-pager</span><br><span class=\"line\"></span><br><span class=\"line\"># 以 JSON 格式（单行）输出</span><br><span class=\"line\">$ sudo journalctl -b -u nginx.service -o json</span><br><span class=\"line\"></span><br><span class=\"line\"># 以 JSON 格式（多行）输出，可读性更好</span><br><span class=\"line\">$ sudo journalctl -b -u nginx.serviceqq</span><br><span class=\"line\"> -o json-pretty</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示日志占据的硬盘空间</span><br><span class=\"line\">$ sudo journalctl --disk-usage</span><br><span class=\"line\"></span><br><span class=\"line\"># 指定日志文件占据的最大空间</span><br><span class=\"line\">$ sudo journalctl --vacuum-size=1G</span><br><span class=\"line\"></span><br><span class=\"line\"># 指定日志文件保存多久</span><br><span class=\"line\">$ sudo journalctl --vacuum-time=1years</span><br></pre></td></tr></table></figure>"},{"title":"ThoughtWorks第一周学习总结","date":"2016-05-24T13:44:57.000Z","_content":"\n# 关于一周来学习情况总结\n\n不知不觉进入TW已经一周了，深感自己离成为一个合格的TWer还有很长的距离。在学习的过程中离不开总结和分享，在TW最棒的就是可以随时和身边的技术牛人们分享自己的学习心得，时时总结，有助于梳理自己的知识体系，巩固自己的学习方法。正所谓“时时勤拂拭，莫使惹尘埃”。\n<!-- more -->\n\n下面就几个关键词进行一个小结：\n\n## 我所除的环境\n\n### ThouhgtWorks显而易见的工作习惯\n\n\n \n  1.Email 轰炸\n  2.Stand metting\n  \t就像Align Development里面提到的一样，Stand up, Aline Comstomer 在TW被很好地执行，每日站会是必不可少的\n  3.频繁的沟通\n  \t之前的工作经验告诉我，你只需要写得一手好代码就可以在公司站稳脚跟，但是这点认知在TW被彻底推翻，与代码同样重要的是你的沟通能力，在实际开发过程中，沟通消耗的资源甚至会大于写代码的消耗。\n  4.Pair-Programming  \n  \t这也是Align Deployment的重要一环，在TW几乎每一件事都是pair的，这中工作方式可以有效地解决掉“个人英雄”的问题，一段代码出了问题，至少有两个人可以来改这段代码。同时加强了程序员之间的交流，也有利于代码规范的实施。\n  5.代码洁癖\n  \t由于每一段代码都会有人review,这使很多TWer养成了代码洁癖，代码不但要实现功能，还要写得好看，这一点我个人认为也是极好的。\n  6.频繁的workshop和session\n  7.无处不在的敏捷\n\t在TW，敏捷已经超越一种开发方式而成为一种文化存在，步步为营，小步前进，似乎是每一个工程师低调而又自信的工作方式。这很好，值得学习：）\n\n\n## 我面临的问题\n\n工作方式上的问题是很容易适应的，TW有宽松的工作环境和乐于助人的同事。让我吃惊的是我接触到的每一个同事都是健谈而友好的，其中不乏很多大神，所以我一点都不担心自己成长。目前只需要找到自己的短板，针对性的进行一些加强性训练：\n\n\n\t1.英文能力\n\t\t从进公司到现在，已经从几乎听不懂同事们在说什么到可以看英文文档了，但是英文交流还存在严重的问题，主要表现在无法用英语表达自己所想的内容，另外英文阅读和听力速度还有些跟不上\n\t2.DevOps专业能力\n\t\t目前我接触到的DevOps能力主要落实到几个工具的使用上：Jenkins,AWS,ansible,另外还需要掌握vagrant,git,shell,yaml，Linux命令（Vi编辑器命令）对工具来讲，整体不难，拿下英文文档，实际需要的只是操作，后面几个更倾向于需要具备的基本素质才是我目前最需要达到的目标。\n\t3.习惯的建立\n\t\t习惯主要分为工作习惯，学习习惯，和生活习惯，这几点在过去的一周几乎是混乱的，这几个习惯应该有一定的准则，概括来说，工作习惯应该是高效可靠，随时可以再session和当前的work中切换自己的状态，那么设计到的内容主要是calendar的管理和mind.txt的优化，我还没有上手公司正式项目，所以目前工作效率优化仅仅停留在自己的事情备忘和计划这个层面。生活习惯，目前来讲主要是健身和游泳，羽毛球视club活动参加，生活应该规律，保证健康的身体和工作时间有一个清醒的大脑。学习习惯是所有习惯中最重要的，主要是根据学习时间，blog时间和阅读时间是每天不可少的内容，希望这些习惯可以再TW贯彻下去.\n\n\n## 我的应对\n\n\n\t1.关于英语问题，目前的解决方式是阅读MartinFlower的博客，以及每天用英语进行工作总结，尽可能熟悉英文语境以求更好表达自己想表达的东西。\n\t2.DevOps专业能力\n\t\tworkshop基本只适用于还没有建立起自己学习习惯的人和对一个东西建立初步认识，session也不能对技术提高起到决定性的帮助，频繁的沟通带来的缺点是时间的碎片化，我需要随时跟进自己的一个进程进展到什么程度，有效挂起和有效恢复，才能保证工作和学习同步有效地进行。\n\t\t具体来说专业能力的提高除了被动在工作中使用需要用到的技术，跟以前一样，还是要在工作之余对在工作中遇到的问题进行挖掘，弄清楚背后的原理，才能应对同样的问题以及问题的变种。\n\t3.习惯的建立\n\t\t工作上和生活上不用花太大心思，生活上只要保证每天早晚各半个小时的锻炼整个人的精气神就会大不一样。周末游泳，这个不用我说自然会有的。\t\n\n\n## 我的决定\n\n基于以上现状以及分析，我的个人时间计划表初步安排如下：\n\n\n\t7：00 起床\n\t~7：30洗漱，锻炼\n\t~8：00阅读英语，内容为随机选取技术博客活着计划任务一篇\n\t9：00~12：00工作\n\t12：00~13：00阅读一小时\n\t13：00~13：30可以适当午休\n\t14：00~19:00工作，汇报一天的工作\n\t20：00成功降落\n\t晚上：整理白天产生的mind.txt，选取一个技术点blog\n\t\t英文能力训练二十分钟，阅读一小时，锻炼半小时\n\t23:00睡觉\t\n","source":"_posts/ThoughtWorks第一周学习总结.md","raw":"---\ntitle: ThoughtWorks第一周学习总结\ndate: 2016-05-24 21:44:57\ncategories: ThoughtWorker\ntags: [敏捷, ThoughtWorks]\n\n---\n\n# 关于一周来学习情况总结\n\n不知不觉进入TW已经一周了，深感自己离成为一个合格的TWer还有很长的距离。在学习的过程中离不开总结和分享，在TW最棒的就是可以随时和身边的技术牛人们分享自己的学习心得，时时总结，有助于梳理自己的知识体系，巩固自己的学习方法。正所谓“时时勤拂拭，莫使惹尘埃”。\n<!-- more -->\n\n下面就几个关键词进行一个小结：\n\n## 我所除的环境\n\n### ThouhgtWorks显而易见的工作习惯\n\n\n \n  1.Email 轰炸\n  2.Stand metting\n  \t就像Align Development里面提到的一样，Stand up, Aline Comstomer 在TW被很好地执行，每日站会是必不可少的\n  3.频繁的沟通\n  \t之前的工作经验告诉我，你只需要写得一手好代码就可以在公司站稳脚跟，但是这点认知在TW被彻底推翻，与代码同样重要的是你的沟通能力，在实际开发过程中，沟通消耗的资源甚至会大于写代码的消耗。\n  4.Pair-Programming  \n  \t这也是Align Deployment的重要一环，在TW几乎每一件事都是pair的，这中工作方式可以有效地解决掉“个人英雄”的问题，一段代码出了问题，至少有两个人可以来改这段代码。同时加强了程序员之间的交流，也有利于代码规范的实施。\n  5.代码洁癖\n  \t由于每一段代码都会有人review,这使很多TWer养成了代码洁癖，代码不但要实现功能，还要写得好看，这一点我个人认为也是极好的。\n  6.频繁的workshop和session\n  7.无处不在的敏捷\n\t在TW，敏捷已经超越一种开发方式而成为一种文化存在，步步为营，小步前进，似乎是每一个工程师低调而又自信的工作方式。这很好，值得学习：）\n\n\n## 我面临的问题\n\n工作方式上的问题是很容易适应的，TW有宽松的工作环境和乐于助人的同事。让我吃惊的是我接触到的每一个同事都是健谈而友好的，其中不乏很多大神，所以我一点都不担心自己成长。目前只需要找到自己的短板，针对性的进行一些加强性训练：\n\n\n\t1.英文能力\n\t\t从进公司到现在，已经从几乎听不懂同事们在说什么到可以看英文文档了，但是英文交流还存在严重的问题，主要表现在无法用英语表达自己所想的内容，另外英文阅读和听力速度还有些跟不上\n\t2.DevOps专业能力\n\t\t目前我接触到的DevOps能力主要落实到几个工具的使用上：Jenkins,AWS,ansible,另外还需要掌握vagrant,git,shell,yaml，Linux命令（Vi编辑器命令）对工具来讲，整体不难，拿下英文文档，实际需要的只是操作，后面几个更倾向于需要具备的基本素质才是我目前最需要达到的目标。\n\t3.习惯的建立\n\t\t习惯主要分为工作习惯，学习习惯，和生活习惯，这几点在过去的一周几乎是混乱的，这几个习惯应该有一定的准则，概括来说，工作习惯应该是高效可靠，随时可以再session和当前的work中切换自己的状态，那么设计到的内容主要是calendar的管理和mind.txt的优化，我还没有上手公司正式项目，所以目前工作效率优化仅仅停留在自己的事情备忘和计划这个层面。生活习惯，目前来讲主要是健身和游泳，羽毛球视club活动参加，生活应该规律，保证健康的身体和工作时间有一个清醒的大脑。学习习惯是所有习惯中最重要的，主要是根据学习时间，blog时间和阅读时间是每天不可少的内容，希望这些习惯可以再TW贯彻下去.\n\n\n## 我的应对\n\n\n\t1.关于英语问题，目前的解决方式是阅读MartinFlower的博客，以及每天用英语进行工作总结，尽可能熟悉英文语境以求更好表达自己想表达的东西。\n\t2.DevOps专业能力\n\t\tworkshop基本只适用于还没有建立起自己学习习惯的人和对一个东西建立初步认识，session也不能对技术提高起到决定性的帮助，频繁的沟通带来的缺点是时间的碎片化，我需要随时跟进自己的一个进程进展到什么程度，有效挂起和有效恢复，才能保证工作和学习同步有效地进行。\n\t\t具体来说专业能力的提高除了被动在工作中使用需要用到的技术，跟以前一样，还是要在工作之余对在工作中遇到的问题进行挖掘，弄清楚背后的原理，才能应对同样的问题以及问题的变种。\n\t3.习惯的建立\n\t\t工作上和生活上不用花太大心思，生活上只要保证每天早晚各半个小时的锻炼整个人的精气神就会大不一样。周末游泳，这个不用我说自然会有的。\t\n\n\n## 我的决定\n\n基于以上现状以及分析，我的个人时间计划表初步安排如下：\n\n\n\t7：00 起床\n\t~7：30洗漱，锻炼\n\t~8：00阅读英语，内容为随机选取技术博客活着计划任务一篇\n\t9：00~12：00工作\n\t12：00~13：00阅读一小时\n\t13：00~13：30可以适当午休\n\t14：00~19:00工作，汇报一天的工作\n\t20：00成功降落\n\t晚上：整理白天产生的mind.txt，选取一个技术点blog\n\t\t英文能力训练二十分钟，阅读一小时，锻炼半小时\n\t23:00睡觉\t\n","slug":"ThoughtWorks第一周学习总结","published":1,"updated":"2016-06-28T11:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzgzek20009egfytyab4iq8","content":"<h1 id=\"关于一周来学习情况总结\"><a href=\"#关于一周来学习情况总结\" class=\"headerlink\" title=\"关于一周来学习情况总结\"></a>关于一周来学习情况总结</h1><p>不知不觉进入TW已经一周了，深感自己离成为一个合格的TWer还有很长的距离。在学习的过程中离不开总结和分享，在TW最棒的就是可以随时和身边的技术牛人们分享自己的学习心得，时时总结，有助于梳理自己的知识体系，巩固自己的学习方法。正所谓“时时勤拂拭，莫使惹尘埃”。<br><a id=\"more\"></a></p>\n<p>下面就几个关键词进行一个小结：</p>\n<h2 id=\"我所除的环境\"><a href=\"#我所除的环境\" class=\"headerlink\" title=\"我所除的环境\"></a>我所除的环境</h2><h3 id=\"ThouhgtWorks显而易见的工作习惯\"><a href=\"#ThouhgtWorks显而易见的工作习惯\" class=\"headerlink\" title=\"ThouhgtWorks显而易见的工作习惯\"></a>ThouhgtWorks显而易见的工作习惯</h3><p>  1.Email 轰炸<br>  2.Stand metting<br>      就像Align Development里面提到的一样，Stand up, Aline Comstomer 在TW被很好地执行，每日站会是必不可少的<br>  3.频繁的沟通<br>      之前的工作经验告诉我，你只需要写得一手好代码就可以在公司站稳脚跟，但是这点认知在TW被彻底推翻，与代码同样重要的是你的沟通能力，在实际开发过程中，沟通消耗的资源甚至会大于写代码的消耗。<br>  4.Pair-Programming<br>      这也是Align Deployment的重要一环，在TW几乎每一件事都是pair的，这中工作方式可以有效地解决掉“个人英雄”的问题，一段代码出了问题，至少有两个人可以来改这段代码。同时加强了程序员之间的交流，也有利于代码规范的实施。<br>  5.代码洁癖<br>      由于每一段代码都会有人review,这使很多TWer养成了代码洁癖，代码不但要实现功能，还要写得好看，这一点我个人认为也是极好的。<br>  6.频繁的workshop和session<br>  7.无处不在的敏捷<br>    在TW，敏捷已经超越一种开发方式而成为一种文化存在，步步为营，小步前进，似乎是每一个工程师低调而又自信的工作方式。这很好，值得学习：）</p>\n<h2 id=\"我面临的问题\"><a href=\"#我面临的问题\" class=\"headerlink\" title=\"我面临的问题\"></a>我面临的问题</h2><p>工作方式上的问题是很容易适应的，TW有宽松的工作环境和乐于助人的同事。让我吃惊的是我接触到的每一个同事都是健谈而友好的，其中不乏很多大神，所以我一点都不担心自己成长。目前只需要找到自己的短板，针对性的进行一些加强性训练：</p>\n<pre><code>1.英文能力\n    从进公司到现在，已经从几乎听不懂同事们在说什么到可以看英文文档了，但是英文交流还存在严重的问题，主要表现在无法用英语表达自己所想的内容，另外英文阅读和听力速度还有些跟不上\n2.DevOps专业能力\n    目前我接触到的DevOps能力主要落实到几个工具的使用上：Jenkins,AWS,ansible,另外还需要掌握vagrant,git,shell,yaml，Linux命令（Vi编辑器命令）对工具来讲，整体不难，拿下英文文档，实际需要的只是操作，后面几个更倾向于需要具备的基本素质才是我目前最需要达到的目标。\n3.习惯的建立\n    习惯主要分为工作习惯，学习习惯，和生活习惯，这几点在过去的一周几乎是混乱的，这几个习惯应该有一定的准则，概括来说，工作习惯应该是高效可靠，随时可以再session和当前的work中切换自己的状态，那么设计到的内容主要是calendar的管理和mind.txt的优化，我还没有上手公司正式项目，所以目前工作效率优化仅仅停留在自己的事情备忘和计划这个层面。生活习惯，目前来讲主要是健身和游泳，羽毛球视club活动参加，生活应该规律，保证健康的身体和工作时间有一个清醒的大脑。学习习惯是所有习惯中最重要的，主要是根据学习时间，blog时间和阅读时间是每天不可少的内容，希望这些习惯可以再TW贯彻下去.\n</code></pre><h2 id=\"我的应对\"><a href=\"#我的应对\" class=\"headerlink\" title=\"我的应对\"></a>我的应对</h2><pre><code>1.关于英语问题，目前的解决方式是阅读MartinFlower的博客，以及每天用英语进行工作总结，尽可能熟悉英文语境以求更好表达自己想表达的东西。\n2.DevOps专业能力\n    workshop基本只适用于还没有建立起自己学习习惯的人和对一个东西建立初步认识，session也不能对技术提高起到决定性的帮助，频繁的沟通带来的缺点是时间的碎片化，我需要随时跟进自己的一个进程进展到什么程度，有效挂起和有效恢复，才能保证工作和学习同步有效地进行。\n    具体来说专业能力的提高除了被动在工作中使用需要用到的技术，跟以前一样，还是要在工作之余对在工作中遇到的问题进行挖掘，弄清楚背后的原理，才能应对同样的问题以及问题的变种。\n3.习惯的建立\n    工作上和生活上不用花太大心思，生活上只要保证每天早晚各半个小时的锻炼整个人的精气神就会大不一样。周末游泳，这个不用我说自然会有的。    \n</code></pre><h2 id=\"我的决定\"><a href=\"#我的决定\" class=\"headerlink\" title=\"我的决定\"></a>我的决定</h2><p>基于以上现状以及分析，我的个人时间计划表初步安排如下：</p>\n<pre><code>7：00 起床\n~7：30洗漱，锻炼\n~8：00阅读英语，内容为随机选取技术博客活着计划任务一篇\n9：00~12：00工作\n12：00~13：00阅读一小时\n13：00~13：30可以适当午休\n14：00~19:00工作，汇报一天的工作\n20：00成功降落\n晚上：整理白天产生的mind.txt，选取一个技术点blog\n    英文能力训练二十分钟，阅读一小时，锻炼半小时\n23:00睡觉    \n</code></pre>","excerpt":"<h1 id=\"关于一周来学习情况总结\"><a href=\"#关于一周来学习情况总结\" class=\"headerlink\" title=\"关于一周来学习情况总结\"></a>关于一周来学习情况总结</h1><p>不知不觉进入TW已经一周了，深感自己离成为一个合格的TWer还有很长的距离。在学习的过程中离不开总结和分享，在TW最棒的就是可以随时和身边的技术牛人们分享自己的学习心得，时时总结，有助于梳理自己的知识体系，巩固自己的学习方法。正所谓“时时勤拂拭，莫使惹尘埃”。<br>","more":"</p>\n<p>下面就几个关键词进行一个小结：</p>\n<h2 id=\"我所除的环境\"><a href=\"#我所除的环境\" class=\"headerlink\" title=\"我所除的环境\"></a>我所除的环境</h2><h3 id=\"ThouhgtWorks显而易见的工作习惯\"><a href=\"#ThouhgtWorks显而易见的工作习惯\" class=\"headerlink\" title=\"ThouhgtWorks显而易见的工作习惯\"></a>ThouhgtWorks显而易见的工作习惯</h3><p>  1.Email 轰炸<br>  2.Stand metting<br>      就像Align Development里面提到的一样，Stand up, Aline Comstomer 在TW被很好地执行，每日站会是必不可少的<br>  3.频繁的沟通<br>      之前的工作经验告诉我，你只需要写得一手好代码就可以在公司站稳脚跟，但是这点认知在TW被彻底推翻，与代码同样重要的是你的沟通能力，在实际开发过程中，沟通消耗的资源甚至会大于写代码的消耗。<br>  4.Pair-Programming<br>      这也是Align Deployment的重要一环，在TW几乎每一件事都是pair的，这中工作方式可以有效地解决掉“个人英雄”的问题，一段代码出了问题，至少有两个人可以来改这段代码。同时加强了程序员之间的交流，也有利于代码规范的实施。<br>  5.代码洁癖<br>      由于每一段代码都会有人review,这使很多TWer养成了代码洁癖，代码不但要实现功能，还要写得好看，这一点我个人认为也是极好的。<br>  6.频繁的workshop和session<br>  7.无处不在的敏捷<br>    在TW，敏捷已经超越一种开发方式而成为一种文化存在，步步为营，小步前进，似乎是每一个工程师低调而又自信的工作方式。这很好，值得学习：）</p>\n<h2 id=\"我面临的问题\"><a href=\"#我面临的问题\" class=\"headerlink\" title=\"我面临的问题\"></a>我面临的问题</h2><p>工作方式上的问题是很容易适应的，TW有宽松的工作环境和乐于助人的同事。让我吃惊的是我接触到的每一个同事都是健谈而友好的，其中不乏很多大神，所以我一点都不担心自己成长。目前只需要找到自己的短板，针对性的进行一些加强性训练：</p>\n<pre><code>1.英文能力\n    从进公司到现在，已经从几乎听不懂同事们在说什么到可以看英文文档了，但是英文交流还存在严重的问题，主要表现在无法用英语表达自己所想的内容，另外英文阅读和听力速度还有些跟不上\n2.DevOps专业能力\n    目前我接触到的DevOps能力主要落实到几个工具的使用上：Jenkins,AWS,ansible,另外还需要掌握vagrant,git,shell,yaml，Linux命令（Vi编辑器命令）对工具来讲，整体不难，拿下英文文档，实际需要的只是操作，后面几个更倾向于需要具备的基本素质才是我目前最需要达到的目标。\n3.习惯的建立\n    习惯主要分为工作习惯，学习习惯，和生活习惯，这几点在过去的一周几乎是混乱的，这几个习惯应该有一定的准则，概括来说，工作习惯应该是高效可靠，随时可以再session和当前的work中切换自己的状态，那么设计到的内容主要是calendar的管理和mind.txt的优化，我还没有上手公司正式项目，所以目前工作效率优化仅仅停留在自己的事情备忘和计划这个层面。生活习惯，目前来讲主要是健身和游泳，羽毛球视club活动参加，生活应该规律，保证健康的身体和工作时间有一个清醒的大脑。学习习惯是所有习惯中最重要的，主要是根据学习时间，blog时间和阅读时间是每天不可少的内容，希望这些习惯可以再TW贯彻下去.\n</code></pre><h2 id=\"我的应对\"><a href=\"#我的应对\" class=\"headerlink\" title=\"我的应对\"></a>我的应对</h2><pre><code>1.关于英语问题，目前的解决方式是阅读MartinFlower的博客，以及每天用英语进行工作总结，尽可能熟悉英文语境以求更好表达自己想表达的东西。\n2.DevOps专业能力\n    workshop基本只适用于还没有建立起自己学习习惯的人和对一个东西建立初步认识，session也不能对技术提高起到决定性的帮助，频繁的沟通带来的缺点是时间的碎片化，我需要随时跟进自己的一个进程进展到什么程度，有效挂起和有效恢复，才能保证工作和学习同步有效地进行。\n    具体来说专业能力的提高除了被动在工作中使用需要用到的技术，跟以前一样，还是要在工作之余对在工作中遇到的问题进行挖掘，弄清楚背后的原理，才能应对同样的问题以及问题的变种。\n3.习惯的建立\n    工作上和生活上不用花太大心思，生活上只要保证每天早晚各半个小时的锻炼整个人的精气神就会大不一样。周末游泳，这个不用我说自然会有的。    \n</code></pre><h2 id=\"我的决定\"><a href=\"#我的决定\" class=\"headerlink\" title=\"我的决定\"></a>我的决定</h2><p>基于以上现状以及分析，我的个人时间计划表初步安排如下：</p>\n<pre><code>7：00 起床\n~7：30洗漱，锻炼\n~8：00阅读英语，内容为随机选取技术博客活着计划任务一篇\n9：00~12：00工作\n12：00~13：00阅读一小时\n13：00~13：30可以适当午休\n14：00~19:00工作，汇报一天的工作\n20：00成功降落\n晚上：整理白天产生的mind.txt，选取一个技术点blog\n    英文能力训练二十分钟，阅读一小时，锻炼半小时\n23:00睡觉    \n</code></pre>"},{"title":"ansible学习小记","date":"2016-06-15T12:30:46.000Z","_content":"# Ansible是什么\n借助官网上的一句话，ansible is a simple IT automation, 即ansible 是用于IT自动化管理的一个工具\n<!-- more -->\n## 诞生背景\n在传统小规模开发中，我们在开发机上开发，在Linux服务器上部署，整个过程只需要一个人操作，运维既是在开发机上开发，测试，然后选个凌晨两三点的时间把打包好的字节码文件复制到服务器上，这种开发生产环境用不着自动化配置管理工具。\n但当我们的开发升级到数十个人的团队，服务器多达数台，这种操作方式的弊端就会显露出来，一是多人协作带来的开发环境和生产环境不一致导致开发环境可用的代码到了生产环境（服务器）上变得不可用，二是多台服务器的重复配置带来的工作内容的冗余，一定程度上降低了我们的生产效率。这种时候运维的角色开始逐渐显现出来。\n这种级别的运维，通常只需要一些python或者bash脚本就可以实现自动化部署，配置服务器等功能。再加上规范的文档，基本可以解决团队之间的沟通问题。\n但是随着产品迭代周期的加长，团队的扩大，问题也随之而来，实践中脚本的不易维护，程序员们不愿意更新文档等问题逐渐暴露出来。于是市面上诞生了一批以”代码即文档”为核心思想的自动化配置管理工具，Ansible就是其中之一。\n\n## 操作方法\nansible主要由几个部分租成，其核心是inventory文件和yaml编写的playbook，按照[最佳实践](http://docs.ansible.com/ansible/playbooks_best_practices.html)的标准，一个完整的ansible文件应该具有以下结构：\n\n```\nproduction                # inventory file for production servers\nstaging                   # inventory file for staging environment\n\ngroup_vars/\n   group1                 # here we assign variables to particular groups\n   group2                 # \"\"\nhost_vars/\n   hostname1              # if systems need specific variables, put them here\n   hostname2              # \"\"\n\nlibrary/                  # if any custom modules, put them here (optional)\nfilter_plugins/           # if any custom filter plugins, put them here (optional)\n\nsite.yml                  # master playbook\nwebservers.yml            # playbook for webserver tier\ndbservers.yml             # playbook for dbserver tier\n\nroles/\n    common/               # this hierarchy represents a \"role\"\n        tasks/            #\n            main.yml      #  <-- tasks file can include smaller files if warranted\n        handlers/         #\n            main.yml      #  <-- handlers file\n        templates/        #  <-- files for use with the template resource\n            ntp.conf.j2   #  <------- templates end in .j2\n        files/            #\n            bar.txt       #  <-- files for use with the copy resource\n            foo.sh        #  <-- script files for use with the script resource\n        vars/             #\n            main.yml      #  <-- variables associated with this role\n        defaults/         #\n            main.yml      #  <-- default lower priority variables for this role\n        meta/             #\n            main.yml      #  <-- role dependencies\n\n    webtier/              # same kind of structure as \"common\" was above, done for the webtier role\n    monitoring/           # \"\"\n    fooapp/               # \"\"\n```\n这里我挑几个重点讲：\nsite.yml是ensile playbook的入口文件，执行该文件会依次找到inventory文件，找到hosts组，然后ssh到目标机器组的host上，开始执行task。\ntask是通过调用ansible模块的方式，在远程设备上执行命令来实现配置的，所以理论上可以通过命令行操作的操作，ansible都可以执行。\n以下为一个task:\n\n```\n-name: install npm\n sudo: yes\n yum: \n \tname: npm\n \tstate: present\n```\n该task使用了ansible的yum模块，用于检测远端设备上是否部署了nam，如果没有部署，ansible会进行yum install nam 操作进行安装，安装成功，显示ok，失败则抛出异常并中断ansible执行。\n\n\n## 几款自动化配置工具\n我没有使用过其他自动化配置管理工具，在此仅对ansible做进一步介绍\nensile的底层实现使用python，在Linux上支持较好，windows支持较弱，因为生产环境和测试环境通常都是Linux操作系统，所以这点无伤大雅。\n你可以理解成Ansible就是对一批python脚本的封装,你只需要更改一些yams文件就可以达到控制服务器配置版本信息的目的，关于yams语法：[http://www.ansible.com.cn/docs/YAMLSyntax.html](http://www.ansible.com.cn/docs/YAMLSyntax.html)\n\n\n\n# 如何使用\n# Ansible的不足之处\n\n未完待续。。","source":"_posts/ansible学习小记.md","raw":"---\ntitle: ansible学习小记\ndate: 2016-06-15 20:30:46\ncategories: Devops\ntags: [opration, ansible]\n\n---\n# Ansible是什么\n借助官网上的一句话，ansible is a simple IT automation, 即ansible 是用于IT自动化管理的一个工具\n<!-- more -->\n## 诞生背景\n在传统小规模开发中，我们在开发机上开发，在Linux服务器上部署，整个过程只需要一个人操作，运维既是在开发机上开发，测试，然后选个凌晨两三点的时间把打包好的字节码文件复制到服务器上，这种开发生产环境用不着自动化配置管理工具。\n但当我们的开发升级到数十个人的团队，服务器多达数台，这种操作方式的弊端就会显露出来，一是多人协作带来的开发环境和生产环境不一致导致开发环境可用的代码到了生产环境（服务器）上变得不可用，二是多台服务器的重复配置带来的工作内容的冗余，一定程度上降低了我们的生产效率。这种时候运维的角色开始逐渐显现出来。\n这种级别的运维，通常只需要一些python或者bash脚本就可以实现自动化部署，配置服务器等功能。再加上规范的文档，基本可以解决团队之间的沟通问题。\n但是随着产品迭代周期的加长，团队的扩大，问题也随之而来，实践中脚本的不易维护，程序员们不愿意更新文档等问题逐渐暴露出来。于是市面上诞生了一批以”代码即文档”为核心思想的自动化配置管理工具，Ansible就是其中之一。\n\n## 操作方法\nansible主要由几个部分租成，其核心是inventory文件和yaml编写的playbook，按照[最佳实践](http://docs.ansible.com/ansible/playbooks_best_practices.html)的标准，一个完整的ansible文件应该具有以下结构：\n\n```\nproduction                # inventory file for production servers\nstaging                   # inventory file for staging environment\n\ngroup_vars/\n   group1                 # here we assign variables to particular groups\n   group2                 # \"\"\nhost_vars/\n   hostname1              # if systems need specific variables, put them here\n   hostname2              # \"\"\n\nlibrary/                  # if any custom modules, put them here (optional)\nfilter_plugins/           # if any custom filter plugins, put them here (optional)\n\nsite.yml                  # master playbook\nwebservers.yml            # playbook for webserver tier\ndbservers.yml             # playbook for dbserver tier\n\nroles/\n    common/               # this hierarchy represents a \"role\"\n        tasks/            #\n            main.yml      #  <-- tasks file can include smaller files if warranted\n        handlers/         #\n            main.yml      #  <-- handlers file\n        templates/        #  <-- files for use with the template resource\n            ntp.conf.j2   #  <------- templates end in .j2\n        files/            #\n            bar.txt       #  <-- files for use with the copy resource\n            foo.sh        #  <-- script files for use with the script resource\n        vars/             #\n            main.yml      #  <-- variables associated with this role\n        defaults/         #\n            main.yml      #  <-- default lower priority variables for this role\n        meta/             #\n            main.yml      #  <-- role dependencies\n\n    webtier/              # same kind of structure as \"common\" was above, done for the webtier role\n    monitoring/           # \"\"\n    fooapp/               # \"\"\n```\n这里我挑几个重点讲：\nsite.yml是ensile playbook的入口文件，执行该文件会依次找到inventory文件，找到hosts组，然后ssh到目标机器组的host上，开始执行task。\ntask是通过调用ansible模块的方式，在远程设备上执行命令来实现配置的，所以理论上可以通过命令行操作的操作，ansible都可以执行。\n以下为一个task:\n\n```\n-name: install npm\n sudo: yes\n yum: \n \tname: npm\n \tstate: present\n```\n该task使用了ansible的yum模块，用于检测远端设备上是否部署了nam，如果没有部署，ansible会进行yum install nam 操作进行安装，安装成功，显示ok，失败则抛出异常并中断ansible执行。\n\n\n## 几款自动化配置工具\n我没有使用过其他自动化配置管理工具，在此仅对ansible做进一步介绍\nensile的底层实现使用python，在Linux上支持较好，windows支持较弱，因为生产环境和测试环境通常都是Linux操作系统，所以这点无伤大雅。\n你可以理解成Ansible就是对一批python脚本的封装,你只需要更改一些yams文件就可以达到控制服务器配置版本信息的目的，关于yams语法：[http://www.ansible.com.cn/docs/YAMLSyntax.html](http://www.ansible.com.cn/docs/YAMLSyntax.html)\n\n\n\n# 如何使用\n# Ansible的不足之处\n\n未完待续。。","slug":"ansible学习小记","published":1,"updated":"2016-06-28T11:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzgzek4000cegfyd1fnwn28","content":"<h1 id=\"Ansible是什么\"><a href=\"#Ansible是什么\" class=\"headerlink\" title=\"Ansible是什么\"></a>Ansible是什么</h1><p>借助官网上的一句话，ansible is a simple IT automation, 即ansible 是用于IT自动化管理的一个工具<br><a id=\"more\"></a></p>\n<h2 id=\"诞生背景\"><a href=\"#诞生背景\" class=\"headerlink\" title=\"诞生背景\"></a>诞生背景</h2><p>在传统小规模开发中，我们在开发机上开发，在Linux服务器上部署，整个过程只需要一个人操作，运维既是在开发机上开发，测试，然后选个凌晨两三点的时间把打包好的字节码文件复制到服务器上，这种开发生产环境用不着自动化配置管理工具。<br>但当我们的开发升级到数十个人的团队，服务器多达数台，这种操作方式的弊端就会显露出来，一是多人协作带来的开发环境和生产环境不一致导致开发环境可用的代码到了生产环境（服务器）上变得不可用，二是多台服务器的重复配置带来的工作内容的冗余，一定程度上降低了我们的生产效率。这种时候运维的角色开始逐渐显现出来。<br>这种级别的运维，通常只需要一些python或者bash脚本就可以实现自动化部署，配置服务器等功能。再加上规范的文档，基本可以解决团队之间的沟通问题。<br>但是随着产品迭代周期的加长，团队的扩大，问题也随之而来，实践中脚本的不易维护，程序员们不愿意更新文档等问题逐渐暴露出来。于是市面上诞生了一批以”代码即文档”为核心思想的自动化配置管理工具，Ansible就是其中之一。</p>\n<h2 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h2><p>ansible主要由几个部分租成，其核心是inventory文件和yaml编写的playbook，按照<a href=\"http://docs.ansible.com/ansible/playbooks_best_practices.html\" target=\"_blank\" rel=\"external\">最佳实践</a>的标准，一个完整的ansible文件应该具有以下结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">production                # inventory file for production servers</span><br><span class=\"line\">staging                   # inventory file for staging environment</span><br><span class=\"line\"></span><br><span class=\"line\">group_vars/</span><br><span class=\"line\">   group1                 # here we assign variables to particular groups</span><br><span class=\"line\">   group2                 # &quot;&quot;</span><br><span class=\"line\">host_vars/</span><br><span class=\"line\">   hostname1              # if systems need specific variables, put them here</span><br><span class=\"line\">   hostname2              # &quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">library/                  # if any custom modules, put them here (optional)</span><br><span class=\"line\">filter_plugins/           # if any custom filter plugins, put them here (optional)</span><br><span class=\"line\"></span><br><span class=\"line\">site.yml                  # master playbook</span><br><span class=\"line\">webservers.yml            # playbook for webserver tier</span><br><span class=\"line\">dbservers.yml             # playbook for dbserver tier</span><br><span class=\"line\"></span><br><span class=\"line\">roles/</span><br><span class=\"line\">    common/               # this hierarchy represents a &quot;role&quot;</span><br><span class=\"line\">        tasks/            #</span><br><span class=\"line\">            main.yml      #  &lt;-- tasks file can include smaller files if warranted</span><br><span class=\"line\">        handlers/         #</span><br><span class=\"line\">            main.yml      #  &lt;-- handlers file</span><br><span class=\"line\">        templates/        #  &lt;-- files for use with the template resource</span><br><span class=\"line\">            ntp.conf.j2   #  &lt;------- templates end in .j2</span><br><span class=\"line\">        files/            #</span><br><span class=\"line\">            bar.txt       #  &lt;-- files for use with the copy resource</span><br><span class=\"line\">            foo.sh        #  &lt;-- script files for use with the script resource</span><br><span class=\"line\">        vars/             #</span><br><span class=\"line\">            main.yml      #  &lt;-- variables associated with this role</span><br><span class=\"line\">        defaults/         #</span><br><span class=\"line\">            main.yml      #  &lt;-- default lower priority variables for this role</span><br><span class=\"line\">        meta/             #</span><br><span class=\"line\">            main.yml      #  &lt;-- role dependencies</span><br><span class=\"line\"></span><br><span class=\"line\">    webtier/              # same kind of structure as &quot;common&quot; was above, done for the webtier role</span><br><span class=\"line\">    monitoring/           # &quot;&quot;</span><br><span class=\"line\">    fooapp/               # &quot;&quot;</span><br></pre></td></tr></table></figure>\n<p>这里我挑几个重点讲：<br>site.yml是ensile playbook的入口文件，执行该文件会依次找到inventory文件，找到hosts组，然后ssh到目标机器组的host上，开始执行task。<br>task是通过调用ansible模块的方式，在远程设备上执行命令来实现配置的，所以理论上可以通过命令行操作的操作，ansible都可以执行。<br>以下为一个task:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-name: install npm</span><br><span class=\"line\"> sudo: yes</span><br><span class=\"line\"> yum: </span><br><span class=\"line\"> \tname: npm</span><br><span class=\"line\"> \tstate: present</span><br></pre></td></tr></table></figure>\n<p>该task使用了ansible的yum模块，用于检测远端设备上是否部署了nam，如果没有部署，ansible会进行yum install nam 操作进行安装，安装成功，显示ok，失败则抛出异常并中断ansible执行。</p>\n<h2 id=\"几款自动化配置工具\"><a href=\"#几款自动化配置工具\" class=\"headerlink\" title=\"几款自动化配置工具\"></a>几款自动化配置工具</h2><p>我没有使用过其他自动化配置管理工具，在此仅对ansible做进一步介绍<br>ensile的底层实现使用python，在Linux上支持较好，windows支持较弱，因为生产环境和测试环境通常都是Linux操作系统，所以这点无伤大雅。<br>你可以理解成Ansible就是对一批python脚本的封装,你只需要更改一些yams文件就可以达到控制服务器配置版本信息的目的，关于yams语法：<a href=\"http://www.ansible.com.cn/docs/YAMLSyntax.html\" target=\"_blank\" rel=\"external\">http://www.ansible.com.cn/docs/YAMLSyntax.html</a></p>\n<h1 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h1><h1 id=\"Ansible的不足之处\"><a href=\"#Ansible的不足之处\" class=\"headerlink\" title=\"Ansible的不足之处\"></a>Ansible的不足之处</h1><p>未完待续。。</p>\n","excerpt":"<h1 id=\"Ansible是什么\"><a href=\"#Ansible是什么\" class=\"headerlink\" title=\"Ansible是什么\"></a>Ansible是什么</h1><p>借助官网上的一句话，ansible is a simple IT automation, 即ansible 是用于IT自动化管理的一个工具<br>","more":"</p>\n<h2 id=\"诞生背景\"><a href=\"#诞生背景\" class=\"headerlink\" title=\"诞生背景\"></a>诞生背景</h2><p>在传统小规模开发中，我们在开发机上开发，在Linux服务器上部署，整个过程只需要一个人操作，运维既是在开发机上开发，测试，然后选个凌晨两三点的时间把打包好的字节码文件复制到服务器上，这种开发生产环境用不着自动化配置管理工具。<br>但当我们的开发升级到数十个人的团队，服务器多达数台，这种操作方式的弊端就会显露出来，一是多人协作带来的开发环境和生产环境不一致导致开发环境可用的代码到了生产环境（服务器）上变得不可用，二是多台服务器的重复配置带来的工作内容的冗余，一定程度上降低了我们的生产效率。这种时候运维的角色开始逐渐显现出来。<br>这种级别的运维，通常只需要一些python或者bash脚本就可以实现自动化部署，配置服务器等功能。再加上规范的文档，基本可以解决团队之间的沟通问题。<br>但是随着产品迭代周期的加长，团队的扩大，问题也随之而来，实践中脚本的不易维护，程序员们不愿意更新文档等问题逐渐暴露出来。于是市面上诞生了一批以”代码即文档”为核心思想的自动化配置管理工具，Ansible就是其中之一。</p>\n<h2 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h2><p>ansible主要由几个部分租成，其核心是inventory文件和yaml编写的playbook，按照<a href=\"http://docs.ansible.com/ansible/playbooks_best_practices.html\">最佳实践</a>的标准，一个完整的ansible文件应该具有以下结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">production                # inventory file for production servers</span><br><span class=\"line\">staging                   # inventory file for staging environment</span><br><span class=\"line\"></span><br><span class=\"line\">group_vars/</span><br><span class=\"line\">   group1                 # here we assign variables to particular groups</span><br><span class=\"line\">   group2                 # &quot;&quot;</span><br><span class=\"line\">host_vars/</span><br><span class=\"line\">   hostname1              # if systems need specific variables, put them here</span><br><span class=\"line\">   hostname2              # &quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">library/                  # if any custom modules, put them here (optional)</span><br><span class=\"line\">filter_plugins/           # if any custom filter plugins, put them here (optional)</span><br><span class=\"line\"></span><br><span class=\"line\">site.yml                  # master playbook</span><br><span class=\"line\">webservers.yml            # playbook for webserver tier</span><br><span class=\"line\">dbservers.yml             # playbook for dbserver tier</span><br><span class=\"line\"></span><br><span class=\"line\">roles/</span><br><span class=\"line\">    common/               # this hierarchy represents a &quot;role&quot;</span><br><span class=\"line\">        tasks/            #</span><br><span class=\"line\">            main.yml      #  &lt;-- tasks file can include smaller files if warranted</span><br><span class=\"line\">        handlers/         #</span><br><span class=\"line\">            main.yml      #  &lt;-- handlers file</span><br><span class=\"line\">        templates/        #  &lt;-- files for use with the template resource</span><br><span class=\"line\">            ntp.conf.j2   #  &lt;------- templates end in .j2</span><br><span class=\"line\">        files/            #</span><br><span class=\"line\">            bar.txt       #  &lt;-- files for use with the copy resource</span><br><span class=\"line\">            foo.sh        #  &lt;-- script files for use with the script resource</span><br><span class=\"line\">        vars/             #</span><br><span class=\"line\">            main.yml      #  &lt;-- variables associated with this role</span><br><span class=\"line\">        defaults/         #</span><br><span class=\"line\">            main.yml      #  &lt;-- default lower priority variables for this role</span><br><span class=\"line\">        meta/             #</span><br><span class=\"line\">            main.yml      #  &lt;-- role dependencies</span><br><span class=\"line\"></span><br><span class=\"line\">    webtier/              # same kind of structure as &quot;common&quot; was above, done for the webtier role</span><br><span class=\"line\">    monitoring/           # &quot;&quot;</span><br><span class=\"line\">    fooapp/               # &quot;&quot;</span><br></pre></td></tr></table></figure>\n<p>这里我挑几个重点讲：<br>site.yml是ensile playbook的入口文件，执行该文件会依次找到inventory文件，找到hosts组，然后ssh到目标机器组的host上，开始执行task。<br>task是通过调用ansible模块的方式，在远程设备上执行命令来实现配置的，所以理论上可以通过命令行操作的操作，ansible都可以执行。<br>以下为一个task:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-name: install npm</span><br><span class=\"line\"> sudo: yes</span><br><span class=\"line\"> yum: </span><br><span class=\"line\"> \tname: npm</span><br><span class=\"line\"> \tstate: present</span><br></pre></td></tr></table></figure>\n<p>该task使用了ansible的yum模块，用于检测远端设备上是否部署了nam，如果没有部署，ansible会进行yum install nam 操作进行安装，安装成功，显示ok，失败则抛出异常并中断ansible执行。</p>\n<h2 id=\"几款自动化配置工具\"><a href=\"#几款自动化配置工具\" class=\"headerlink\" title=\"几款自动化配置工具\"></a>几款自动化配置工具</h2><p>我没有使用过其他自动化配置管理工具，在此仅对ansible做进一步介绍<br>ensile的底层实现使用python，在Linux上支持较好，windows支持较弱，因为生产环境和测试环境通常都是Linux操作系统，所以这点无伤大雅。<br>你可以理解成Ansible就是对一批python脚本的封装,你只需要更改一些yams文件就可以达到控制服务器配置版本信息的目的，关于yams语法：<a href=\"http://www.ansible.com.cn/docs/YAMLSyntax.html\">http://www.ansible.com.cn/docs/YAMLSyntax.html</a></p>\n<h1 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h1><h1 id=\"Ansible的不足之处\"><a href=\"#Ansible的不足之处\" class=\"headerlink\" title=\"Ansible的不足之处\"></a>Ansible的不足之处</h1><p>未完待续。。</p>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2016-06-28T11:49:15.000Z","updated":"2016-06-28T11:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzgzek8000eegfyp7oesw6u","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.<br><a id=\"more\"></a></p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","excerpt":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.<br>","more":"</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>"},{"title":"python代码优化小技巧","date":"2016-03-29T12:26:33.000Z","_content":"# python代码优化小技巧\n一个良好的算法能够对性能起到关键作用，因此性能改进的首要点是对算法的改进。在算法的时间复杂度排序上依次是：\n\n>  O(1) -> O(lg n) -> O(n lg n) -> O(n^2) -> O(n^3) -> O(n^k) -> O(k^n) -> O(n!)\n\n因此如果能够在时间复杂度上对算法进行一定的改进，对性能的提高不言而喻。但对具体算法的改进不属于本文讨论的范围，读者可以自行参考这方面资料。下面的内容将集中讨论数据结构的选择。\n<!-- more -->\n## 字典 (dictionary) 与列表 (list)\nPython 字典中使用了 hash table，因此查找操作的复杂度为 O(1)，而 list 实际是个数组，在 list 中，查找需要遍历整个 list，其复杂度为 O(n)，因此对成员的查找访问等操作字典要比 list 更快。\n\n\n清单 1. 代码 dict.py\n\n``` python\nfrom time import time \n t = time() \n list = ['a','b','is','python','jason','hello','hill','with','phone','test', \n'dfdf','apple','pddf','ind','basic','none','baecr','var','bana','dd','wrd'] \n #list = dict.fromkeys(list,True) \n print list\n filter = [] \n for i in range (1000000): \n     for find in ['is','hat','new','list','old','.']: \n         if find not in list: \n             filter.append(find) \n print(\"total run time:\")\n print(time()-t)\n ```\n \n上述代码运行大概需要 16.09seconds。如果去掉行 #list = dict.fromkeys(list,True) 的注释，将 list 转换为字典之后再运行，时间大约为 8.375 seconds，效率大概提高了一半。因此在需要多数据成员进行频繁的查找或者访问的时候，使用 dict 而不是 list 是一个较好的选择。\n## 集合 (set) 与列表 (list)\nset 的 union， intersection，difference 操作要比 list 的迭代要快。因此如果涉及到求 list 交集，并集或者差的问题可以转换为 set 来操作。\n\n\n清单 2. 求 list 的交集：\n``` python\nfrom time import time \nt = time() \nlista=[1,2,3,4,5,6,7,8,9,13,34,53,42,44] \nlistb=[2,4,6,9,23] \nintersection=[] \nfor i in range (1000000): \n    for a in lista: \n        for b in listb: \n            if a == b: \n                intersection.append(a) \nprint(\"total run time:\")\nprint (time()-t)\n```\n上述程序的运行时间大概为：\n\n \ttotal run time: \n \t38.4070000648\n\n清单 3. 使用 set 求交集\n``` python\nfrom time import time \nt = time() \nlista=[1,2,3,4,5,6,7,8,9,13,34,53,42,44] \nlistb=[2,4,6,9,23] \nintersection=[] \nfor i in range (1000000): \n    list(set(lista)&set(listb)) \nprint(\"total run time:\")\nprint(time()-t)\n```\n改为 set 后程序的运行时间缩减为 8.75，提高了 4 倍多，运行时间大大缩短。读者可以自行使用表 1 其他的操作进行测试。 \n表 1. set 常见用法 \n语法\t操作\t说明\n\n\tset(list1) | set(list2)\tunion\t包含 list1 和 list2 所有数据的新集合\n\tset(list1) & set(list2)\tintersection\t包含 list1 和 list2 中共同元素的新集合\n\tset(list1) - set(list2)\tdifference\t在 list1 中出现但不在 list2 中出现的元素的集合\n\n清单 4. 利用 Lazy if-evaluation 的特性\n``` python\nfrom time import time \nt = time() \nabbreviations = ['cf.', 'e.g.', 'ex.', 'etc.', 'fig.', 'i.e.', 'Mr.', 'vs.'] \nfor i in range (1000000): \n    for w in ('Mr.', 'Hat', 'is', 'chasing', 'the', 'black', 'cat', '.'): \n        if w in abbreviations: \n        #if w[-1] == '.' and w in abbreviations: \n            pass\nprint(\"total run time:\")\nprint(time()-t)\n```\n在未进行优化之前程序的运行时间大概为 8.84，如果使用注释行代替第一个 if，运行的时间大概为 6.17。\n## 字符串的优化\n\npython 中的字符串对象是不可改变的，因此对任何字符串的操作如拼接，修改等都将产生一个新的字符串对象，而不是基于原字符串，因此这种持续的 copy 会在一定程度上影响 python 的性能。对字符串的优化也是改善性能的一个重要的方面，特别是在处理文本较多的情况下。字符串的优化主要集中在以下几个方面：\n\n在字符串连接的使用尽量使用 join() 而不是 +：在代码清单 7 中使用 + 进行字符串连接大概需要 0.125 s，而使用 join 缩短为 0.016s。因此在字符的操作上 join 比 + 要快，因此要尽量使用 join 而不是 +。\n\n清单 5. 使用 join 而不是 + 连接字符串\n``` python\nfrom time import time \n\nt = time() \ns = \"\"\nlist = ['a','b','b','d','e','f','g','h','i','j','k','l','m','n'] \nfor i in range (10000): \n    for substr in list: \n        s+= substr     \nprint(\"total run time:\")\nprint(time()-t)\n```\n\n同时要避免：\n``` python\ns = \"\"\nfor x in list: \n   s += func(x)\n```\n而是要使用： \n``` python\nslist = [func(elt) for elt in somelist] \ns = \"\".join(slist)\n```\n当对字符串可以使用正则表达式或者内置函数来处理的时候，选择内置函数。如 str.isalpha()，str.isdigit()，str.startswith(('x', 'yz'))，str.endswith(('x', 'yz'))\n对字符进行格式化比直接串联读取要快，因此要使用\n``` python\nout = \"<html>%s%s%s%s</html>\" % (head, prologue, query, tail)\n```\n而避免\n``` python\nout = \"<html>\" + head + prologue + query + tail + \"</html>\"\n```\n\n## 其他优化技巧\n\n如果需要交换两个变量的值使用 a,b=b,a 而不是借助中间变量 t=a;a=b;b=t；\n``` python\n>>> from timeit import Timer \n>>> Timer(\"t=a;a=b;b=t\",\"a=1;b=2\").timeit() \n0.25154118749729365\n>>> Timer(\"a,b=b,a\",\"a=1;b=2\").timeit() \n0.17156677734181258\n>>>\n```\n\n> * 使用局部变量，避免\"global\" 关键字。python 访问局部变量会比全局变量要快得多，因 此可以利用这一特性提升性能。\n> * if done is not None 比语句 if done != None 更快，读者可以自行验证；\n> * 在耗时较多的循环中，可以把函数的调用改为内联的方式；\n> * 使用级联比较 \"x < y < z\" 而不是 \"x < y and y < z\"；\n> * while 1 要比 while True 更快（当然后者的可读性更好）；\n> * build in 函数通常较快，add(a,b) 要优于 a+b。","source":"_posts/python代码优化小技巧.md","raw":"---\ntitle: python代码优化小技巧\ndate: 2016-03-29 20:26:33\ncategories: code\ntags: [代码优化, python]\n\t\n---\n# python代码优化小技巧\n一个良好的算法能够对性能起到关键作用，因此性能改进的首要点是对算法的改进。在算法的时间复杂度排序上依次是：\n\n>  O(1) -> O(lg n) -> O(n lg n) -> O(n^2) -> O(n^3) -> O(n^k) -> O(k^n) -> O(n!)\n\n因此如果能够在时间复杂度上对算法进行一定的改进，对性能的提高不言而喻。但对具体算法的改进不属于本文讨论的范围，读者可以自行参考这方面资料。下面的内容将集中讨论数据结构的选择。\n<!-- more -->\n## 字典 (dictionary) 与列表 (list)\nPython 字典中使用了 hash table，因此查找操作的复杂度为 O(1)，而 list 实际是个数组，在 list 中，查找需要遍历整个 list，其复杂度为 O(n)，因此对成员的查找访问等操作字典要比 list 更快。\n\n\n清单 1. 代码 dict.py\n\n``` python\nfrom time import time \n t = time() \n list = ['a','b','is','python','jason','hello','hill','with','phone','test', \n'dfdf','apple','pddf','ind','basic','none','baecr','var','bana','dd','wrd'] \n #list = dict.fromkeys(list,True) \n print list\n filter = [] \n for i in range (1000000): \n     for find in ['is','hat','new','list','old','.']: \n         if find not in list: \n             filter.append(find) \n print(\"total run time:\")\n print(time()-t)\n ```\n \n上述代码运行大概需要 16.09seconds。如果去掉行 #list = dict.fromkeys(list,True) 的注释，将 list 转换为字典之后再运行，时间大约为 8.375 seconds，效率大概提高了一半。因此在需要多数据成员进行频繁的查找或者访问的时候，使用 dict 而不是 list 是一个较好的选择。\n## 集合 (set) 与列表 (list)\nset 的 union， intersection，difference 操作要比 list 的迭代要快。因此如果涉及到求 list 交集，并集或者差的问题可以转换为 set 来操作。\n\n\n清单 2. 求 list 的交集：\n``` python\nfrom time import time \nt = time() \nlista=[1,2,3,4,5,6,7,8,9,13,34,53,42,44] \nlistb=[2,4,6,9,23] \nintersection=[] \nfor i in range (1000000): \n    for a in lista: \n        for b in listb: \n            if a == b: \n                intersection.append(a) \nprint(\"total run time:\")\nprint (time()-t)\n```\n上述程序的运行时间大概为：\n\n \ttotal run time: \n \t38.4070000648\n\n清单 3. 使用 set 求交集\n``` python\nfrom time import time \nt = time() \nlista=[1,2,3,4,5,6,7,8,9,13,34,53,42,44] \nlistb=[2,4,6,9,23] \nintersection=[] \nfor i in range (1000000): \n    list(set(lista)&set(listb)) \nprint(\"total run time:\")\nprint(time()-t)\n```\n改为 set 后程序的运行时间缩减为 8.75，提高了 4 倍多，运行时间大大缩短。读者可以自行使用表 1 其他的操作进行测试。 \n表 1. set 常见用法 \n语法\t操作\t说明\n\n\tset(list1) | set(list2)\tunion\t包含 list1 和 list2 所有数据的新集合\n\tset(list1) & set(list2)\tintersection\t包含 list1 和 list2 中共同元素的新集合\n\tset(list1) - set(list2)\tdifference\t在 list1 中出现但不在 list2 中出现的元素的集合\n\n清单 4. 利用 Lazy if-evaluation 的特性\n``` python\nfrom time import time \nt = time() \nabbreviations = ['cf.', 'e.g.', 'ex.', 'etc.', 'fig.', 'i.e.', 'Mr.', 'vs.'] \nfor i in range (1000000): \n    for w in ('Mr.', 'Hat', 'is', 'chasing', 'the', 'black', 'cat', '.'): \n        if w in abbreviations: \n        #if w[-1] == '.' and w in abbreviations: \n            pass\nprint(\"total run time:\")\nprint(time()-t)\n```\n在未进行优化之前程序的运行时间大概为 8.84，如果使用注释行代替第一个 if，运行的时间大概为 6.17。\n## 字符串的优化\n\npython 中的字符串对象是不可改变的，因此对任何字符串的操作如拼接，修改等都将产生一个新的字符串对象，而不是基于原字符串，因此这种持续的 copy 会在一定程度上影响 python 的性能。对字符串的优化也是改善性能的一个重要的方面，特别是在处理文本较多的情况下。字符串的优化主要集中在以下几个方面：\n\n在字符串连接的使用尽量使用 join() 而不是 +：在代码清单 7 中使用 + 进行字符串连接大概需要 0.125 s，而使用 join 缩短为 0.016s。因此在字符的操作上 join 比 + 要快，因此要尽量使用 join 而不是 +。\n\n清单 5. 使用 join 而不是 + 连接字符串\n``` python\nfrom time import time \n\nt = time() \ns = \"\"\nlist = ['a','b','b','d','e','f','g','h','i','j','k','l','m','n'] \nfor i in range (10000): \n    for substr in list: \n        s+= substr     \nprint(\"total run time:\")\nprint(time()-t)\n```\n\n同时要避免：\n``` python\ns = \"\"\nfor x in list: \n   s += func(x)\n```\n而是要使用： \n``` python\nslist = [func(elt) for elt in somelist] \ns = \"\".join(slist)\n```\n当对字符串可以使用正则表达式或者内置函数来处理的时候，选择内置函数。如 str.isalpha()，str.isdigit()，str.startswith(('x', 'yz'))，str.endswith(('x', 'yz'))\n对字符进行格式化比直接串联读取要快，因此要使用\n``` python\nout = \"<html>%s%s%s%s</html>\" % (head, prologue, query, tail)\n```\n而避免\n``` python\nout = \"<html>\" + head + prologue + query + tail + \"</html>\"\n```\n\n## 其他优化技巧\n\n如果需要交换两个变量的值使用 a,b=b,a 而不是借助中间变量 t=a;a=b;b=t；\n``` python\n>>> from timeit import Timer \n>>> Timer(\"t=a;a=b;b=t\",\"a=1;b=2\").timeit() \n0.25154118749729365\n>>> Timer(\"a,b=b,a\",\"a=1;b=2\").timeit() \n0.17156677734181258\n>>>\n```\n\n> * 使用局部变量，避免\"global\" 关键字。python 访问局部变量会比全局变量要快得多，因 此可以利用这一特性提升性能。\n> * if done is not None 比语句 if done != None 更快，读者可以自行验证；\n> * 在耗时较多的循环中，可以把函数的调用改为内联的方式；\n> * 使用级联比较 \"x < y < z\" 而不是 \"x < y and y < z\"；\n> * while 1 要比 while True 更快（当然后者的可读性更好）；\n> * build in 函数通常较快，add(a,b) 要优于 a+b。","slug":"python代码优化小技巧","published":1,"updated":"2016-06-28T11:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzgzekb000iegfyaedyb7te","content":"<h1 id=\"python代码优化小技巧\"><a href=\"#python代码优化小技巧\" class=\"headerlink\" title=\"python代码优化小技巧\"></a>python代码优化小技巧</h1><p>一个良好的算法能够对性能起到关键作用，因此性能改进的首要点是对算法的改进。在算法的时间复杂度排序上依次是：</p>\n<blockquote>\n<p> O(1) -&gt; O(lg n) -&gt; O(n lg n) -&gt; O(n^2) -&gt; O(n^3) -&gt; O(n^k) -&gt; O(k^n) -&gt; O(n!)</p>\n</blockquote>\n<p>因此如果能够在时间复杂度上对算法进行一定的改进，对性能的提高不言而喻。但对具体算法的改进不属于本文讨论的范围，读者可以自行参考这方面资料。下面的内容将集中讨论数据结构的选择。<br><a id=\"more\"></a></p>\n<h2 id=\"字典-dictionary-与列表-list\"><a href=\"#字典-dictionary-与列表-list\" class=\"headerlink\" title=\"字典 (dictionary) 与列表 (list)\"></a>字典 (dictionary) 与列表 (list)</h2><p>Python 字典中使用了 hash table，因此查找操作的复杂度为 O(1)，而 list 实际是个数组，在 list 中，查找需要遍历整个 list，其复杂度为 O(n)，因此对成员的查找访问等操作字典要比 list 更快。</p>\n<p>清单 1. 代码 dict.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> time </span><br><span class=\"line\"> t = time() </span><br><span class=\"line\"> list = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'is'</span>,<span class=\"string\">'python'</span>,<span class=\"string\">'jason'</span>,<span class=\"string\">'hello'</span>,<span class=\"string\">'hill'</span>,<span class=\"string\">'with'</span>,<span class=\"string\">'phone'</span>,<span class=\"string\">'test'</span>, </span><br><span class=\"line\"><span class=\"string\">'dfdf'</span>,<span class=\"string\">'apple'</span>,<span class=\"string\">'pddf'</span>,<span class=\"string\">'ind'</span>,<span class=\"string\">'basic'</span>,<span class=\"string\">'none'</span>,<span class=\"string\">'baecr'</span>,<span class=\"string\">'var'</span>,<span class=\"string\">'bana'</span>,<span class=\"string\">'dd'</span>,<span class=\"string\">'wrd'</span>] </span><br><span class=\"line\"> <span class=\"comment\">#list = dict.fromkeys(list,True) </span></span><br><span class=\"line\"> <span class=\"keyword\">print</span> list</span><br><span class=\"line\"> filter = [] </span><br><span class=\"line\"> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range (<span class=\"number\">1000000</span>): </span><br><span class=\"line\">     <span class=\"keyword\">for</span> find <span class=\"keyword\">in</span> [<span class=\"string\">'is'</span>,<span class=\"string\">'hat'</span>,<span class=\"string\">'new'</span>,<span class=\"string\">'list'</span>,<span class=\"string\">'old'</span>,<span class=\"string\">'.'</span>]: </span><br><span class=\"line\">         <span class=\"keyword\">if</span> find <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> list: </span><br><span class=\"line\">             filter.append(find) </span><br><span class=\"line\"> print(<span class=\"string\">\"total run time:\"</span>)</span><br><span class=\"line\"> print(time()-t)</span><br></pre></td></tr></table></figure>\n<p>上述代码运行大概需要 16.09seconds。如果去掉行 #list = dict.fromkeys(list,True) 的注释，将 list 转换为字典之后再运行，时间大约为 8.375 seconds，效率大概提高了一半。因此在需要多数据成员进行频繁的查找或者访问的时候，使用 dict 而不是 list 是一个较好的选择。</p>\n<h2 id=\"集合-set-与列表-list\"><a href=\"#集合-set-与列表-list\" class=\"headerlink\" title=\"集合 (set) 与列表 (list)\"></a>集合 (set) 与列表 (list)</h2><p>set 的 union， intersection，difference 操作要比 list 的迭代要快。因此如果涉及到求 list 交集，并集或者差的问题可以转换为 set 来操作。</p>\n<p>清单 2. 求 list 的交集：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> time </span><br><span class=\"line\">t = time() </span><br><span class=\"line\">lista=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">13</span>,<span class=\"number\">34</span>,<span class=\"number\">53</span>,<span class=\"number\">42</span>,<span class=\"number\">44</span>] </span><br><span class=\"line\">listb=[<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">23</span>] </span><br><span class=\"line\">intersection=[] </span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range (<span class=\"number\">1000000</span>): </span><br><span class=\"line\">    <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> lista: </span><br><span class=\"line\">        <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> listb: </span><br><span class=\"line\">            <span class=\"keyword\">if</span> a == b: </span><br><span class=\"line\">                intersection.append(a) </span><br><span class=\"line\">print(<span class=\"string\">\"total run time:\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> (time()-t)</span><br></pre></td></tr></table></figure></p>\n<p>上述程序的运行时间大概为：</p>\n<pre><code>total run time: \n38.4070000648\n</code></pre><p>清单 3. 使用 set 求交集<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> time </span><br><span class=\"line\">t = time() </span><br><span class=\"line\">lista=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">13</span>,<span class=\"number\">34</span>,<span class=\"number\">53</span>,<span class=\"number\">42</span>,<span class=\"number\">44</span>] </span><br><span class=\"line\">listb=[<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">23</span>] </span><br><span class=\"line\">intersection=[] </span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range (<span class=\"number\">1000000</span>): </span><br><span class=\"line\">    list(set(lista)&amp;set(listb)) </span><br><span class=\"line\">print(<span class=\"string\">\"total run time:\"</span>)</span><br><span class=\"line\">print(time()-t)</span><br></pre></td></tr></table></figure></p>\n<p>改为 set 后程序的运行时间缩减为 8.75，提高了 4 倍多，运行时间大大缩短。读者可以自行使用表 1 其他的操作进行测试。<br>表 1. set 常见用法<br>语法    操作    说明</p>\n<pre><code>set(list1) | set(list2)    union    包含 list1 和 list2 所有数据的新集合\nset(list1) &amp; set(list2)    intersection    包含 list1 和 list2 中共同元素的新集合\nset(list1) - set(list2)    difference    在 list1 中出现但不在 list2 中出现的元素的集合\n</code></pre><p>清单 4. 利用 Lazy if-evaluation 的特性<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> time </span><br><span class=\"line\">t = time() </span><br><span class=\"line\">abbreviations = [<span class=\"string\">'cf.'</span>, <span class=\"string\">'e.g.'</span>, <span class=\"string\">'ex.'</span>, <span class=\"string\">'etc.'</span>, <span class=\"string\">'fig.'</span>, <span class=\"string\">'i.e.'</span>, <span class=\"string\">'Mr.'</span>, <span class=\"string\">'vs.'</span>] </span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range (<span class=\"number\">1000000</span>): </span><br><span class=\"line\">    <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> (<span class=\"string\">'Mr.'</span>, <span class=\"string\">'Hat'</span>, <span class=\"string\">'is'</span>, <span class=\"string\">'chasing'</span>, <span class=\"string\">'the'</span>, <span class=\"string\">'black'</span>, <span class=\"string\">'cat'</span>, <span class=\"string\">'.'</span>): </span><br><span class=\"line\">        <span class=\"keyword\">if</span> w <span class=\"keyword\">in</span> abbreviations: </span><br><span class=\"line\">        <span class=\"comment\">#if w[-1] == '.' and w in abbreviations: </span></span><br><span class=\"line\">            <span class=\"keyword\">pass</span></span><br><span class=\"line\">print(<span class=\"string\">\"total run time:\"</span>)</span><br><span class=\"line\">print(time()-t)</span><br></pre></td></tr></table></figure></p>\n<p>在未进行优化之前程序的运行时间大概为 8.84，如果使用注释行代替第一个 if，运行的时间大概为 6.17。</p>\n<h2 id=\"字符串的优化\"><a href=\"#字符串的优化\" class=\"headerlink\" title=\"字符串的优化\"></a>字符串的优化</h2><p>python 中的字符串对象是不可改变的，因此对任何字符串的操作如拼接，修改等都将产生一个新的字符串对象，而不是基于原字符串，因此这种持续的 copy 会在一定程度上影响 python 的性能。对字符串的优化也是改善性能的一个重要的方面，特别是在处理文本较多的情况下。字符串的优化主要集中在以下几个方面：</p>\n<p>在字符串连接的使用尽量使用 join() 而不是 +：在代码清单 7 中使用 + 进行字符串连接大概需要 0.125 s，而使用 join 缩短为 0.016s。因此在字符的操作上 join 比 + 要快，因此要尽量使用 join 而不是 +。</p>\n<p>清单 5. 使用 join 而不是 + 连接字符串<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> time </span><br><span class=\"line\"></span><br><span class=\"line\">t = time() </span><br><span class=\"line\">s = <span class=\"string\">\"\"</span></span><br><span class=\"line\">list = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'d'</span>,<span class=\"string\">'e'</span>,<span class=\"string\">'f'</span>,<span class=\"string\">'g'</span>,<span class=\"string\">'h'</span>,<span class=\"string\">'i'</span>,<span class=\"string\">'j'</span>,<span class=\"string\">'k'</span>,<span class=\"string\">'l'</span>,<span class=\"string\">'m'</span>,<span class=\"string\">'n'</span>] </span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range (<span class=\"number\">10000</span>): </span><br><span class=\"line\">    <span class=\"keyword\">for</span> substr <span class=\"keyword\">in</span> list: </span><br><span class=\"line\">        s+= substr     </span><br><span class=\"line\">print(<span class=\"string\">\"total run time:\"</span>)</span><br><span class=\"line\">print(time()-t)</span><br></pre></td></tr></table></figure></p>\n<p>同时要避免：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">\"\"</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> list: </span><br><span class=\"line\">   s += func(x)</span><br></pre></td></tr></table></figure></p>\n<p>而是要使用：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slist = [func(elt) <span class=\"keyword\">for</span> elt <span class=\"keyword\">in</span> somelist] </span><br><span class=\"line\">s = <span class=\"string\">\"\"</span>.join(slist)</span><br></pre></td></tr></table></figure></p>\n<p>当对字符串可以使用正则表达式或者内置函数来处理的时候，选择内置函数。如 str.isalpha()，str.isdigit()，str.startswith((‘x’, ‘yz’))，str.endswith((‘x’, ‘yz’))<br>对字符进行格式化比直接串联读取要快，因此要使用<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">out = <span class=\"string\">\"&lt;html&gt;%s%s%s%s&lt;/html&gt;\"</span> % (head, prologue, query, tail)</span><br></pre></td></tr></table></figure></p>\n<p>而避免<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">out = <span class=\"string\">\"&lt;html&gt;\"</span> + head + prologue + query + tail + <span class=\"string\">\"&lt;/html&gt;\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"其他优化技巧\"><a href=\"#其他优化技巧\" class=\"headerlink\" title=\"其他优化技巧\"></a>其他优化技巧</h2><p>如果需要交换两个变量的值使用 a,b=b,a 而不是借助中间变量 t=a;a=b;b=t；<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> timeit <span class=\"keyword\">import</span> Timer </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Timer(<span class=\"string\">\"t=a;a=b;b=t\"</span>,<span class=\"string\">\"a=1;b=2\"</span>).timeit() </span><br><span class=\"line\"><span class=\"number\">0.25154118749729365</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Timer(<span class=\"string\">\"a,b=b,a\"</span>,<span class=\"string\">\"a=1;b=2\"</span>).timeit() </span><br><span class=\"line\"><span class=\"number\">0.17156677734181258</span></span><br><span class=\"line\">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<ul>\n<li>使用局部变量，避免”global” 关键字。python 访问局部变量会比全局变量要快得多，因 此可以利用这一特性提升性能。</li>\n<li>if done is not None 比语句 if done != None 更快，读者可以自行验证；</li>\n<li>在耗时较多的循环中，可以把函数的调用改为内联的方式；</li>\n<li>使用级联比较 “x &lt; y &lt; z” 而不是 “x &lt; y and y &lt; z”；</li>\n<li>while 1 要比 while True 更快（当然后者的可读性更好）；</li>\n<li>build in 函数通常较快，add(a,b) 要优于 a+b。</li>\n</ul>\n</blockquote>\n","excerpt":"<h1 id=\"python代码优化小技巧\"><a href=\"#python代码优化小技巧\" class=\"headerlink\" title=\"python代码优化小技巧\"></a>python代码优化小技巧</h1><p>一个良好的算法能够对性能起到关键作用，因此性能改进的首要点是对算法的改进。在算法的时间复杂度排序上依次是：</p>\n<blockquote>\n<p> O(1) -&gt; O(lg n) -&gt; O(n lg n) -&gt; O(n^2) -&gt; O(n^3) -&gt; O(n^k) -&gt; O(k^n) -&gt; O(n!)</p>\n</blockquote>\n<p>因此如果能够在时间复杂度上对算法进行一定的改进，对性能的提高不言而喻。但对具体算法的改进不属于本文讨论的范围，读者可以自行参考这方面资料。下面的内容将集中讨论数据结构的选择。<br>","more":"</p>\n<h2 id=\"字典-dictionary-与列表-list\"><a href=\"#字典-dictionary-与列表-list\" class=\"headerlink\" title=\"字典 (dictionary) 与列表 (list)\"></a>字典 (dictionary) 与列表 (list)</h2><p>Python 字典中使用了 hash table，因此查找操作的复杂度为 O(1)，而 list 实际是个数组，在 list 中，查找需要遍历整个 list，其复杂度为 O(n)，因此对成员的查找访问等操作字典要比 list 更快。</p>\n<p>清单 1. 代码 dict.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> time </span><br><span class=\"line\"> t = time() </span><br><span class=\"line\"> list = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'is'</span>,<span class=\"string\">'python'</span>,<span class=\"string\">'jason'</span>,<span class=\"string\">'hello'</span>,<span class=\"string\">'hill'</span>,<span class=\"string\">'with'</span>,<span class=\"string\">'phone'</span>,<span class=\"string\">'test'</span>, </span><br><span class=\"line\"><span class=\"string\">'dfdf'</span>,<span class=\"string\">'apple'</span>,<span class=\"string\">'pddf'</span>,<span class=\"string\">'ind'</span>,<span class=\"string\">'basic'</span>,<span class=\"string\">'none'</span>,<span class=\"string\">'baecr'</span>,<span class=\"string\">'var'</span>,<span class=\"string\">'bana'</span>,<span class=\"string\">'dd'</span>,<span class=\"string\">'wrd'</span>] </span><br><span class=\"line\"> <span class=\"comment\">#list = dict.fromkeys(list,True) </span></span><br><span class=\"line\"> <span class=\"keyword\">print</span> list</span><br><span class=\"line\"> filter = [] </span><br><span class=\"line\"> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range (<span class=\"number\">1000000</span>): </span><br><span class=\"line\">     <span class=\"keyword\">for</span> find <span class=\"keyword\">in</span> [<span class=\"string\">'is'</span>,<span class=\"string\">'hat'</span>,<span class=\"string\">'new'</span>,<span class=\"string\">'list'</span>,<span class=\"string\">'old'</span>,<span class=\"string\">'.'</span>]: </span><br><span class=\"line\">         <span class=\"keyword\">if</span> find <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> list: </span><br><span class=\"line\">             filter.append(find) </span><br><span class=\"line\"> print(<span class=\"string\">\"total run time:\"</span>)</span><br><span class=\"line\"> print(time()-t)</span><br></pre></td></tr></table></figure>\n<p>上述代码运行大概需要 16.09seconds。如果去掉行 #list = dict.fromkeys(list,True) 的注释，将 list 转换为字典之后再运行，时间大约为 8.375 seconds，效率大概提高了一半。因此在需要多数据成员进行频繁的查找或者访问的时候，使用 dict 而不是 list 是一个较好的选择。</p>\n<h2 id=\"集合-set-与列表-list\"><a href=\"#集合-set-与列表-list\" class=\"headerlink\" title=\"集合 (set) 与列表 (list)\"></a>集合 (set) 与列表 (list)</h2><p>set 的 union， intersection，difference 操作要比 list 的迭代要快。因此如果涉及到求 list 交集，并集或者差的问题可以转换为 set 来操作。</p>\n<p>清单 2. 求 list 的交集：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> time </span><br><span class=\"line\">t = time() </span><br><span class=\"line\">lista=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">13</span>,<span class=\"number\">34</span>,<span class=\"number\">53</span>,<span class=\"number\">42</span>,<span class=\"number\">44</span>] </span><br><span class=\"line\">listb=[<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">23</span>] </span><br><span class=\"line\">intersection=[] </span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range (<span class=\"number\">1000000</span>): </span><br><span class=\"line\">    <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> lista: </span><br><span class=\"line\">        <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> listb: </span><br><span class=\"line\">            <span class=\"keyword\">if</span> a == b: </span><br><span class=\"line\">                intersection.append(a) </span><br><span class=\"line\">print(<span class=\"string\">\"total run time:\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> (time()-t)</span><br></pre></td></tr></table></figure></p>\n<p>上述程序的运行时间大概为：</p>\n<pre><code>total run time: \n38.4070000648\n</code></pre><p>清单 3. 使用 set 求交集<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> time </span><br><span class=\"line\">t = time() </span><br><span class=\"line\">lista=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">13</span>,<span class=\"number\">34</span>,<span class=\"number\">53</span>,<span class=\"number\">42</span>,<span class=\"number\">44</span>] </span><br><span class=\"line\">listb=[<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">23</span>] </span><br><span class=\"line\">intersection=[] </span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range (<span class=\"number\">1000000</span>): </span><br><span class=\"line\">    list(set(lista)&amp;set(listb)) </span><br><span class=\"line\">print(<span class=\"string\">\"total run time:\"</span>)</span><br><span class=\"line\">print(time()-t)</span><br></pre></td></tr></table></figure></p>\n<p>改为 set 后程序的运行时间缩减为 8.75，提高了 4 倍多，运行时间大大缩短。读者可以自行使用表 1 其他的操作进行测试。<br>表 1. set 常见用法<br>语法    操作    说明</p>\n<pre><code>set(list1) | set(list2)    union    包含 list1 和 list2 所有数据的新集合\nset(list1) &amp; set(list2)    intersection    包含 list1 和 list2 中共同元素的新集合\nset(list1) - set(list2)    difference    在 list1 中出现但不在 list2 中出现的元素的集合\n</code></pre><p>清单 4. 利用 Lazy if-evaluation 的特性<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> time </span><br><span class=\"line\">t = time() </span><br><span class=\"line\">abbreviations = [<span class=\"string\">'cf.'</span>, <span class=\"string\">'e.g.'</span>, <span class=\"string\">'ex.'</span>, <span class=\"string\">'etc.'</span>, <span class=\"string\">'fig.'</span>, <span class=\"string\">'i.e.'</span>, <span class=\"string\">'Mr.'</span>, <span class=\"string\">'vs.'</span>] </span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range (<span class=\"number\">1000000</span>): </span><br><span class=\"line\">    <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> (<span class=\"string\">'Mr.'</span>, <span class=\"string\">'Hat'</span>, <span class=\"string\">'is'</span>, <span class=\"string\">'chasing'</span>, <span class=\"string\">'the'</span>, <span class=\"string\">'black'</span>, <span class=\"string\">'cat'</span>, <span class=\"string\">'.'</span>): </span><br><span class=\"line\">        <span class=\"keyword\">if</span> w <span class=\"keyword\">in</span> abbreviations: </span><br><span class=\"line\">        <span class=\"comment\">#if w[-1] == '.' and w in abbreviations: </span></span><br><span class=\"line\">            <span class=\"keyword\">pass</span></span><br><span class=\"line\">print(<span class=\"string\">\"total run time:\"</span>)</span><br><span class=\"line\">print(time()-t)</span><br></pre></td></tr></table></figure></p>\n<p>在未进行优化之前程序的运行时间大概为 8.84，如果使用注释行代替第一个 if，运行的时间大概为 6.17。</p>\n<h2 id=\"字符串的优化\"><a href=\"#字符串的优化\" class=\"headerlink\" title=\"字符串的优化\"></a>字符串的优化</h2><p>python 中的字符串对象是不可改变的，因此对任何字符串的操作如拼接，修改等都将产生一个新的字符串对象，而不是基于原字符串，因此这种持续的 copy 会在一定程度上影响 python 的性能。对字符串的优化也是改善性能的一个重要的方面，特别是在处理文本较多的情况下。字符串的优化主要集中在以下几个方面：</p>\n<p>在字符串连接的使用尽量使用 join() 而不是 +：在代码清单 7 中使用 + 进行字符串连接大概需要 0.125 s，而使用 join 缩短为 0.016s。因此在字符的操作上 join 比 + 要快，因此要尽量使用 join 而不是 +。</p>\n<p>清单 5. 使用 join 而不是 + 连接字符串<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> time </span><br><span class=\"line\"></span><br><span class=\"line\">t = time() </span><br><span class=\"line\">s = <span class=\"string\">\"\"</span></span><br><span class=\"line\">list = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'d'</span>,<span class=\"string\">'e'</span>,<span class=\"string\">'f'</span>,<span class=\"string\">'g'</span>,<span class=\"string\">'h'</span>,<span class=\"string\">'i'</span>,<span class=\"string\">'j'</span>,<span class=\"string\">'k'</span>,<span class=\"string\">'l'</span>,<span class=\"string\">'m'</span>,<span class=\"string\">'n'</span>] </span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range (<span class=\"number\">10000</span>): </span><br><span class=\"line\">    <span class=\"keyword\">for</span> substr <span class=\"keyword\">in</span> list: </span><br><span class=\"line\">        s+= substr     </span><br><span class=\"line\">print(<span class=\"string\">\"total run time:\"</span>)</span><br><span class=\"line\">print(time()-t)</span><br></pre></td></tr></table></figure></p>\n<p>同时要避免：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">\"\"</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> list: </span><br><span class=\"line\">   s += func(x)</span><br></pre></td></tr></table></figure></p>\n<p>而是要使用：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slist = [func(elt) <span class=\"keyword\">for</span> elt <span class=\"keyword\">in</span> somelist] </span><br><span class=\"line\">s = <span class=\"string\">\"\"</span>.join(slist)</span><br></pre></td></tr></table></figure></p>\n<p>当对字符串可以使用正则表达式或者内置函数来处理的时候，选择内置函数。如 str.isalpha()，str.isdigit()，str.startswith((‘x’, ‘yz’))，str.endswith((‘x’, ‘yz’))<br>对字符进行格式化比直接串联读取要快，因此要使用<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">out = <span class=\"string\">\"&lt;html&gt;%s%s%s%s&lt;/html&gt;\"</span> % (head, prologue, query, tail)</span><br></pre></td></tr></table></figure></p>\n<p>而避免<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">out = <span class=\"string\">\"&lt;html&gt;\"</span> + head + prologue + query + tail + <span class=\"string\">\"&lt;/html&gt;\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"其他优化技巧\"><a href=\"#其他优化技巧\" class=\"headerlink\" title=\"其他优化技巧\"></a>其他优化技巧</h2><p>如果需要交换两个变量的值使用 a,b=b,a 而不是借助中间变量 t=a;a=b;b=t；<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> timeit <span class=\"keyword\">import</span> Timer </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Timer(<span class=\"string\">\"t=a;a=b;b=t\"</span>,<span class=\"string\">\"a=1;b=2\"</span>).timeit() </span><br><span class=\"line\"><span class=\"number\">0.25154118749729365</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Timer(<span class=\"string\">\"a,b=b,a\"</span>,<span class=\"string\">\"a=1;b=2\"</span>).timeit() </span><br><span class=\"line\"><span class=\"number\">0.17156677734181258</span></span><br><span class=\"line\">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<ul>\n<li>使用局部变量，避免”global” 关键字。python 访问局部变量会比全局变量要快得多，因 此可以利用这一特性提升性能。</li>\n<li>if done is not None 比语句 if done != None 更快，读者可以自行验证；</li>\n<li>在耗时较多的循环中，可以把函数的调用改为内联的方式；</li>\n<li>使用级联比较 “x &lt; y &lt; z” 而不是 “x &lt; y and y &lt; z”；</li>\n<li>while 1 要比 while True 更快（当然后者的可读性更好）；</li>\n<li>build in 函数通常较快，add(a,b) 要优于 a+b。</li>\n</ul>\n</blockquote>"},{"title":"python函数式编程","date":"2016-04-13T12:01:12.000Z","_content":"# 关于python的函数\n\n这几天一直在看一些零散的东西，但是工作中用不到的东西如果不经常看很容易就忘了，我写博客的目的就是让自己可以经常复习，同时也把一些总结的东西拿出来给大家分享，废话不多说，进入正题：\n\n<!-- more -->\n \n## 关于python函数调用\n\n这里我只想说一种特殊的调用方式，yield相当于return，但是他返回的是一个生成器，是一个未被执行的函数，在web编程中可以用来处理阻塞问题。\n\n## 关于python的参数传递\n\n在定义函数的时候我们经常会用到的两个方法，一个是可变参数，一个是关键字参数。\n\n### 可变参数\n\n可变参数就是允许传入一个tuple或者list，写法是在变量前加星号，如def(*args)，于是你可以传入任意多个参数，包括0.\n\n### 关键字参数\n\n相对可变参数来说，关键字参数就是一个dict，允许传入0或任意多个带参数名的参数，写法是**kw\n\n## 下面再来说说python的函数式编程\n\n函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。\n\n而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。\n\n我们首先要搞明白计算机（Computer）和计算（Compute）的概念。\n\n在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。\n\n而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。\n\n对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。\n\n函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。\n\n函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！\n\nPython对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。\n\n在我前面的日志里已经提到过map/reduce/filter的用法\n\n<-- 未完待续-->","source":"_posts/python函数式编程.md","raw":"---\ntitle: python函数式编程\ndate: 2016-04-13 20:01:12\ncategories: code\ntags: [编程思想, python]\n\n---\n# 关于python的函数\n\n这几天一直在看一些零散的东西，但是工作中用不到的东西如果不经常看很容易就忘了，我写博客的目的就是让自己可以经常复习，同时也把一些总结的东西拿出来给大家分享，废话不多说，进入正题：\n\n<!-- more -->\n \n## 关于python函数调用\n\n这里我只想说一种特殊的调用方式，yield相当于return，但是他返回的是一个生成器，是一个未被执行的函数，在web编程中可以用来处理阻塞问题。\n\n## 关于python的参数传递\n\n在定义函数的时候我们经常会用到的两个方法，一个是可变参数，一个是关键字参数。\n\n### 可变参数\n\n可变参数就是允许传入一个tuple或者list，写法是在变量前加星号，如def(*args)，于是你可以传入任意多个参数，包括0.\n\n### 关键字参数\n\n相对可变参数来说，关键字参数就是一个dict，允许传入0或任意多个带参数名的参数，写法是**kw\n\n## 下面再来说说python的函数式编程\n\n函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。\n\n而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。\n\n我们首先要搞明白计算机（Computer）和计算（Compute）的概念。\n\n在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。\n\n而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。\n\n对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。\n\n函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。\n\n函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！\n\nPython对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。\n\n在我前面的日志里已经提到过map/reduce/filter的用法\n\n<-- 未完待续-->","slug":"python函数式编程","published":1,"updated":"2016-06-28T11:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzgzekc000jegfyy3zhoq37","content":"<h1 id=\"关于python的函数\"><a href=\"#关于python的函数\" class=\"headerlink\" title=\"关于python的函数\"></a>关于python的函数</h1><p>这几天一直在看一些零散的东西，但是工作中用不到的东西如果不经常看很容易就忘了，我写博客的目的就是让自己可以经常复习，同时也把一些总结的东西拿出来给大家分享，废话不多说，进入正题：</p>\n<a id=\"more\"></a>\n<h2 id=\"关于python函数调用\"><a href=\"#关于python函数调用\" class=\"headerlink\" title=\"关于python函数调用\"></a>关于python函数调用</h2><p>这里我只想说一种特殊的调用方式，yield相当于return，但是他返回的是一个生成器，是一个未被执行的函数，在web编程中可以用来处理阻塞问题。</p>\n<h2 id=\"关于python的参数传递\"><a href=\"#关于python的参数传递\" class=\"headerlink\" title=\"关于python的参数传递\"></a>关于python的参数传递</h2><p>在定义函数的时候我们经常会用到的两个方法，一个是可变参数，一个是关键字参数。</p>\n<h3 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h3><p>可变参数就是允许传入一个tuple或者list，写法是在变量前加星号，如def(*args)，于是你可以传入任意多个参数，包括0.</p>\n<h3 id=\"关键字参数\"><a href=\"#关键字参数\" class=\"headerlink\" title=\"关键字参数\"></a>关键字参数</h3><p>相对可变参数来说，关键字参数就是一个dict，允许传入0或任意多个带参数名的参数，写法是**kw</p>\n<h2 id=\"下面再来说说python的函数式编程\"><a href=\"#下面再来说说python的函数式编程\" class=\"headerlink\" title=\"下面再来说说python的函数式编程\"></a>下面再来说说python的函数式编程</h2><p>函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。</p>\n<p>而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。</p>\n<p>我们首先要搞明白计算机（Computer）和计算（Compute）的概念。</p>\n<p>在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。</p>\n<p>而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。</p>\n<p>对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。</p>\n<p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>\n<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>\n<p>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>\n<p>在我前面的日志里已经提到过map/reduce/filter的用法</p>\n<p>&lt;– 未完待续–&gt;</p>\n","excerpt":"<h1 id=\"关于python的函数\"><a href=\"#关于python的函数\" class=\"headerlink\" title=\"关于python的函数\"></a>关于python的函数</h1><p>这几天一直在看一些零散的东西，但是工作中用不到的东西如果不经常看很容易就忘了，我写博客的目的就是让自己可以经常复习，同时也把一些总结的东西拿出来给大家分享，废话不多说，进入正题：</p>","more":"<h2 id=\"关于python函数调用\"><a href=\"#关于python函数调用\" class=\"headerlink\" title=\"关于python函数调用\"></a>关于python函数调用</h2><p>这里我只想说一种特殊的调用方式，yield相当于return，但是他返回的是一个生成器，是一个未被执行的函数，在web编程中可以用来处理阻塞问题。</p>\n<h2 id=\"关于python的参数传递\"><a href=\"#关于python的参数传递\" class=\"headerlink\" title=\"关于python的参数传递\"></a>关于python的参数传递</h2><p>在定义函数的时候我们经常会用到的两个方法，一个是可变参数，一个是关键字参数。</p>\n<h3 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h3><p>可变参数就是允许传入一个tuple或者list，写法是在变量前加星号，如def(*args)，于是你可以传入任意多个参数，包括0.</p>\n<h3 id=\"关键字参数\"><a href=\"#关键字参数\" class=\"headerlink\" title=\"关键字参数\"></a>关键字参数</h3><p>相对可变参数来说，关键字参数就是一个dict，允许传入0或任意多个带参数名的参数，写法是**kw</p>\n<h2 id=\"下面再来说说python的函数式编程\"><a href=\"#下面再来说说python的函数式编程\" class=\"headerlink\" title=\"下面再来说说python的函数式编程\"></a>下面再来说说python的函数式编程</h2><p>函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。</p>\n<p>而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。</p>\n<p>我们首先要搞明白计算机（Computer）和计算（Compute）的概念。</p>\n<p>在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。</p>\n<p>而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。</p>\n<p>对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。</p>\n<p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>\n<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>\n<p>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>\n<p>在我前面的日志里已经提到过map/reduce/filter的用法</p>\n<p>&lt;– 未完待续–&gt;</p>"},{"title":"python函数调用小技巧","date":"2016-04-02T01:54:08.000Z","_content":"# 【python特殊用法】filter,map,reduce.lambda\n\npython的兴起其中一个不容忽视的因素就是他的简洁和易读，要想写好python代码以下几个方法你不得不知道：\n<!-- more -->\n## filter\nfilter(function, sequence):\n对sequence中的item依次执行function(item)，将执行结果为True的item组成一个List/String/Tuple(取决于sequence类型）返回，示例如下：\n``` python\n>>> def f(x): return x % 2 != 0 and x % 3 != 0\n>>> filter(f, range(2, 25))\n[5, 7, 11, 13, 17, 19, 23]\n>>> def f(x): return x != 'a'\n>>> filter(f, \"abcdef\")\n'bcdef'\n```\n\n## map\nmap(function, sequence):\n对sequence中的item依次执行function（item），将执行结果组成一个List返回\n另外map也支持多个sequence，当然这也要求function支持相应数量的参数输入，示例如下：\n\n``` python\n>>> def cube(x): return x*x*x\n>>> map(cube, range(1, 11))\n[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]\n>>> def cube(x) : return x + x\n\n>>> def add(x, y): return x+y\n>>> map(add, range(8), range(8))\n[0, 2, 4, 6, 8, 10, 12, 14]\n```\n\n## reduce\nreduce（function，sequence，starting_value):\n对sequence中的item顺序迭代调用function，如果有starting_value，还可以作为初始值调用，例如可以用来对List求和，示例如下：\n\n``` python\n>>> def add(x,y): return x + y\n >>> reduce(add, range(1, 11))\n（注：1+2+3+4+5+6+7+8+9+10）\n>>> reduce(add, range(1, 11), 20)\n（注：1+2+3+4+5+6+7+8+9+10+20）\n```\n## lambda：\n这是python支持一种有趣的语法，它允许你快速定义单行的最小函数，类似C语言中的宏，可以用在任何需要函数的地方，示例如下：\n``` python\n>>> g = lambda x: x * 2\n>>> g(3)\n6\n>>> (lambda x: x * 2)(3)\n6\n```\n\n我们也可以把filter map reduce 和lambda结合起来用，函数就可以简单的写成一行。例如\n``` python\n>>>kmpathes = filter(lambda kmpath: kmpath, map(lambda kmpath: string.strip(kmpath), string.split(l, ':')))\n```\n\n看起来麻烦，其实就像用语言来描述问题一样，非常优雅。\n对 l 中的所有元素以':'做分割，得出一个列表。对这个列表的每一个元素做字符串strip，形成一个列表。对这个列表的每一个元素做直接返回操作(这个地方可以加上过滤条件限制)，最终获得一个字符串被':'分割的列表，列表中的每一个字符串都做了strip，并可以对特殊字符串过滤。\n\n[原文链接](http://www.jianshu.com/p/81b12f4eae3a)","source":"_posts/python函数调用小技巧.md","raw":"---\ntitle: python函数调用小技巧\ndate: 2016-04-02 09:54:08\ncategories: code\ntags: [代码优化, python]\n\n---\n# 【python特殊用法】filter,map,reduce.lambda\n\npython的兴起其中一个不容忽视的因素就是他的简洁和易读，要想写好python代码以下几个方法你不得不知道：\n<!-- more -->\n## filter\nfilter(function, sequence):\n对sequence中的item依次执行function(item)，将执行结果为True的item组成一个List/String/Tuple(取决于sequence类型）返回，示例如下：\n``` python\n>>> def f(x): return x % 2 != 0 and x % 3 != 0\n>>> filter(f, range(2, 25))\n[5, 7, 11, 13, 17, 19, 23]\n>>> def f(x): return x != 'a'\n>>> filter(f, \"abcdef\")\n'bcdef'\n```\n\n## map\nmap(function, sequence):\n对sequence中的item依次执行function（item），将执行结果组成一个List返回\n另外map也支持多个sequence，当然这也要求function支持相应数量的参数输入，示例如下：\n\n``` python\n>>> def cube(x): return x*x*x\n>>> map(cube, range(1, 11))\n[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]\n>>> def cube(x) : return x + x\n\n>>> def add(x, y): return x+y\n>>> map(add, range(8), range(8))\n[0, 2, 4, 6, 8, 10, 12, 14]\n```\n\n## reduce\nreduce（function，sequence，starting_value):\n对sequence中的item顺序迭代调用function，如果有starting_value，还可以作为初始值调用，例如可以用来对List求和，示例如下：\n\n``` python\n>>> def add(x,y): return x + y\n >>> reduce(add, range(1, 11))\n（注：1+2+3+4+5+6+7+8+9+10）\n>>> reduce(add, range(1, 11), 20)\n（注：1+2+3+4+5+6+7+8+9+10+20）\n```\n## lambda：\n这是python支持一种有趣的语法，它允许你快速定义单行的最小函数，类似C语言中的宏，可以用在任何需要函数的地方，示例如下：\n``` python\n>>> g = lambda x: x * 2\n>>> g(3)\n6\n>>> (lambda x: x * 2)(3)\n6\n```\n\n我们也可以把filter map reduce 和lambda结合起来用，函数就可以简单的写成一行。例如\n``` python\n>>>kmpathes = filter(lambda kmpath: kmpath, map(lambda kmpath: string.strip(kmpath), string.split(l, ':')))\n```\n\n看起来麻烦，其实就像用语言来描述问题一样，非常优雅。\n对 l 中的所有元素以':'做分割，得出一个列表。对这个列表的每一个元素做字符串strip，形成一个列表。对这个列表的每一个元素做直接返回操作(这个地方可以加上过滤条件限制)，最终获得一个字符串被':'分割的列表，列表中的每一个字符串都做了strip，并可以对特殊字符串过滤。\n\n[原文链接](http://www.jianshu.com/p/81b12f4eae3a)","slug":"python函数调用小技巧","published":1,"updated":"2016-06-28T11:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzgzeke000negfylt2axq3k","content":"<h1 id=\"【python特殊用法】filter-map-reduce-lambda\"><a href=\"#【python特殊用法】filter-map-reduce-lambda\" class=\"headerlink\" title=\"【python特殊用法】filter,map,reduce.lambda\"></a>【python特殊用法】filter,map,reduce.lambda</h1><p>python的兴起其中一个不容忽视的因素就是他的简洁和易读，要想写好python代码以下几个方法你不得不知道：<br><a id=\"more\"></a></p>\n<h2 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h2><p>filter(function, sequence):<br>对sequence中的item依次执行function(item)，将执行结果为True的item组成一个List/String/Tuple(取决于sequence类型）返回，示例如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x)</span>:</span> <span class=\"keyword\">return</span> x % <span class=\"number\">2</span> != <span class=\"number\">0</span> <span class=\"keyword\">and</span> x % <span class=\"number\">3</span> != <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>filter(f, range(<span class=\"number\">2</span>, <span class=\"number\">25</span>))</span><br><span class=\"line\">[<span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>, <span class=\"number\">17</span>, <span class=\"number\">19</span>, <span class=\"number\">23</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x)</span>:</span> <span class=\"keyword\">return</span> x != <span class=\"string\">'a'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>filter(f, <span class=\"string\">\"abcdef\"</span>)</span><br><span class=\"line\"><span class=\"string\">'bcdef'</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2><p>map(function, sequence):<br>对sequence中的item依次执行function（item），将执行结果组成一个List返回<br>另外map也支持多个sequence，当然这也要求function支持相应数量的参数输入，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cube</span><span class=\"params\">(x)</span>:</span> <span class=\"keyword\">return</span> x*x*x</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>map(cube, range(<span class=\"number\">1</span>, <span class=\"number\">11</span>))</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">8</span>, <span class=\"number\">27</span>, <span class=\"number\">64</span>, <span class=\"number\">125</span>, <span class=\"number\">216</span>, <span class=\"number\">343</span>, <span class=\"number\">512</span>, <span class=\"number\">729</span>, <span class=\"number\">1000</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cube</span><span class=\"params\">(x)</span> :</span> <span class=\"keyword\">return</span> x + x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(x, y)</span>:</span> <span class=\"keyword\">return</span> x+y</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>map(add, range(<span class=\"number\">8</span>), range(<span class=\"number\">8</span>))</span><br><span class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">10</span>, <span class=\"number\">12</span>, <span class=\"number\">14</span>]</span><br></pre></td></tr></table></figure>\n<h2 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h2><p>reduce（function，sequence，starting_value):<br>对sequence中的item顺序迭代调用function，如果有starting_value，还可以作为初始值调用，例如可以用来对List求和，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(x,y)</span>:</span> <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\"> &gt;&gt;&gt; reduce(add, range(<span class=\"number\">1</span>, <span class=\"number\">11</span>))</span><br><span class=\"line\">（注：<span class=\"number\">1</span>+<span class=\"number\">2</span>+<span class=\"number\">3</span>+<span class=\"number\">4</span>+<span class=\"number\">5</span>+<span class=\"number\">6</span>+<span class=\"number\">7</span>+<span class=\"number\">8</span>+<span class=\"number\">9</span>+<span class=\"number\">10</span>）</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>reduce(add, range(<span class=\"number\">1</span>, <span class=\"number\">11</span>), <span class=\"number\">20</span>)</span><br><span class=\"line\">（注：<span class=\"number\">1</span>+<span class=\"number\">2</span>+<span class=\"number\">3</span>+<span class=\"number\">4</span>+<span class=\"number\">5</span>+<span class=\"number\">6</span>+<span class=\"number\">7</span>+<span class=\"number\">8</span>+<span class=\"number\">9</span>+<span class=\"number\">10</span>+<span class=\"number\">20</span>）</span><br></pre></td></tr></table></figure>\n<h2 id=\"lambda：\"><a href=\"#lambda：\" class=\"headerlink\" title=\"lambda：\"></a>lambda：</h2><p>这是python支持一种有趣的语法，它允许你快速定义单行的最小函数，类似C语言中的宏，可以用在任何需要函数的地方，示例如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>g = <span class=\"keyword\">lambda</span> x: x * <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>g(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>(<span class=\"keyword\">lambda</span> x: x * <span class=\"number\">2</span>)(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"number\">6</span></span><br></pre></td></tr></table></figure></p>\n<p>我们也可以把filter map reduce 和lambda结合起来用，函数就可以简单的写成一行。例如<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;kmpathes = filter(<span class=\"keyword\">lambda</span> kmpath: kmpath, map(<span class=\"keyword\">lambda</span> kmpath: string.strip(kmpath), string.split(l, <span class=\"string\">':'</span>)))</span><br></pre></td></tr></table></figure></p>\n<p>看起来麻烦，其实就像用语言来描述问题一样，非常优雅。<br>对 l 中的所有元素以’:’做分割，得出一个列表。对这个列表的每一个元素做字符串strip，形成一个列表。对这个列表的每一个元素做直接返回操作(这个地方可以加上过滤条件限制)，最终获得一个字符串被’:’分割的列表，列表中的每一个字符串都做了strip，并可以对特殊字符串过滤。</p>\n<p><a href=\"http://www.jianshu.com/p/81b12f4eae3a\" target=\"_blank\" rel=\"external\">原文链接</a></p>\n","excerpt":"<h1 id=\"【python特殊用法】filter-map-reduce-lambda\"><a href=\"#【python特殊用法】filter-map-reduce-lambda\" class=\"headerlink\" title=\"【python特殊用法】filter,map,reduce.lambda\"></a>【python特殊用法】filter,map,reduce.lambda</h1><p>python的兴起其中一个不容忽视的因素就是他的简洁和易读，要想写好python代码以下几个方法你不得不知道：<br>","more":"</p>\n<h2 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h2><p>filter(function, sequence):<br>对sequence中的item依次执行function(item)，将执行结果为True的item组成一个List/String/Tuple(取决于sequence类型）返回，示例如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x)</span>:</span> <span class=\"keyword\">return</span> x % <span class=\"number\">2</span> != <span class=\"number\">0</span> <span class=\"keyword\">and</span> x % <span class=\"number\">3</span> != <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>filter(f, range(<span class=\"number\">2</span>, <span class=\"number\">25</span>))</span><br><span class=\"line\">[<span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>, <span class=\"number\">17</span>, <span class=\"number\">19</span>, <span class=\"number\">23</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x)</span>:</span> <span class=\"keyword\">return</span> x != <span class=\"string\">'a'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>filter(f, <span class=\"string\">\"abcdef\"</span>)</span><br><span class=\"line\"><span class=\"string\">'bcdef'</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2><p>map(function, sequence):<br>对sequence中的item依次执行function（item），将执行结果组成一个List返回<br>另外map也支持多个sequence，当然这也要求function支持相应数量的参数输入，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cube</span><span class=\"params\">(x)</span>:</span> <span class=\"keyword\">return</span> x*x*x</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>map(cube, range(<span class=\"number\">1</span>, <span class=\"number\">11</span>))</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">8</span>, <span class=\"number\">27</span>, <span class=\"number\">64</span>, <span class=\"number\">125</span>, <span class=\"number\">216</span>, <span class=\"number\">343</span>, <span class=\"number\">512</span>, <span class=\"number\">729</span>, <span class=\"number\">1000</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cube</span><span class=\"params\">(x)</span> :</span> <span class=\"keyword\">return</span> x + x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(x, y)</span>:</span> <span class=\"keyword\">return</span> x+y</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>map(add, range(<span class=\"number\">8</span>), range(<span class=\"number\">8</span>))</span><br><span class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">10</span>, <span class=\"number\">12</span>, <span class=\"number\">14</span>]</span><br></pre></td></tr></table></figure>\n<h2 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h2><p>reduce（function，sequence，starting_value):<br>对sequence中的item顺序迭代调用function，如果有starting_value，还可以作为初始值调用，例如可以用来对List求和，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(x,y)</span>:</span> <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\"> &gt;&gt;&gt; reduce(add, range(<span class=\"number\">1</span>, <span class=\"number\">11</span>))</span><br><span class=\"line\">（注：<span class=\"number\">1</span>+<span class=\"number\">2</span>+<span class=\"number\">3</span>+<span class=\"number\">4</span>+<span class=\"number\">5</span>+<span class=\"number\">6</span>+<span class=\"number\">7</span>+<span class=\"number\">8</span>+<span class=\"number\">9</span>+<span class=\"number\">10</span>）</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>reduce(add, range(<span class=\"number\">1</span>, <span class=\"number\">11</span>), <span class=\"number\">20</span>)</span><br><span class=\"line\">（注：<span class=\"number\">1</span>+<span class=\"number\">2</span>+<span class=\"number\">3</span>+<span class=\"number\">4</span>+<span class=\"number\">5</span>+<span class=\"number\">6</span>+<span class=\"number\">7</span>+<span class=\"number\">8</span>+<span class=\"number\">9</span>+<span class=\"number\">10</span>+<span class=\"number\">20</span>）</span><br></pre></td></tr></table></figure>\n<h2 id=\"lambda：\"><a href=\"#lambda：\" class=\"headerlink\" title=\"lambda：\"></a>lambda：</h2><p>这是python支持一种有趣的语法，它允许你快速定义单行的最小函数，类似C语言中的宏，可以用在任何需要函数的地方，示例如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>g = <span class=\"keyword\">lambda</span> x: x * <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>g(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>(<span class=\"keyword\">lambda</span> x: x * <span class=\"number\">2</span>)(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"number\">6</span></span><br></pre></td></tr></table></figure></p>\n<p>我们也可以把filter map reduce 和lambda结合起来用，函数就可以简单的写成一行。例如<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;kmpathes = filter(<span class=\"keyword\">lambda</span> kmpath: kmpath, map(<span class=\"keyword\">lambda</span> kmpath: string.strip(kmpath), string.split(l, <span class=\"string\">':'</span>)))</span><br></pre></td></tr></table></figure></p>\n<p>看起来麻烦，其实就像用语言来描述问题一样，非常优雅。<br>对 l 中的所有元素以’:’做分割，得出一个列表。对这个列表的每一个元素做字符串strip，形成一个列表。对这个列表的每一个元素做直接返回操作(这个地方可以加上过滤条件限制)，最终获得一个字符串被’:’分割的列表，列表中的每一个字符串都做了strip，并可以对特殊字符串过滤。</p>\n<p><a href=\"http://www.jianshu.com/p/81b12f4eae3a\">原文链接</a></p>"},{"title":"redis、memcache、mongoDB性能总结","date":"2016-04-03T13:03:55.000Z","_content":"# redis、memcache、mongoDB有哪些区别？\n## Memcached\n### Memcached的优点：\nMemcached可以利用多核优势，单实例吞吐量极高，可以达到几十万QPS（取决于key、value的字节大小以及服务器硬件性能，日常环境中QPS高峰大约在4-6w左右）。适用于最大程度扛量。\n<!-- more -->\n支持直接配置为session handle。\n坑少。\n### Memcached的局限性：\n只支持简单的key/value数据结构，不像Redis可以支持丰富的数据类型。\n无法进行持久化，数据不能备份，只能用于缓存使用，且重启后数据全部丢失。\n无法进行数据同步，不能将MC中的数据迁移到其他MC实例中。\nMemcached内存分配采用Slab Allocation机制管理内存，value大小分布差异较大时会造成内存利用率降低，并引发低利用率时依然出现踢出等问题。需要用户注重value设计。\n\n## Redis\n### Redis的优点：\n支持多种数据结构，如 string（字符串）、 list(双向链表)、dict(hash表)、set(集合）、zset(排序set)、hyperloglog（基数估算）\n支持持久化操作，可以进行aof及rdb数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失的手段。\n支持通过Replication进行数据复制，通过master-slave机制，可以实时进行数据的同步复制，支持多级复制和增量复制，master-slave机制是Redis进行HA的重要手段。\n单线程请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。\n支持pub/sub消息订阅机制，可以用来进行消息订阅与通知。\n支持简单的事务需求，但业界使用场景很少，并不成熟。\n\n### Redis的局限性：\nRedis只能使用单线程，性能受限于CPU性能，故单实例CPU最高才可能达到5-6wQPS每秒（取决于数据结构，数据大小以及服务器硬件性能，日常环境中QPS高峰大约在1-2w左右）。\n支持简单的事务需求，但业界使用场景很少，并不成熟，既是优点也是缺点。\nRedis在string类型上会消耗较多内存，可以使用dict（hash表）压缩存储以降低内存耗用。\n\n：）以下是我个人的补充\nMc和Redis都是Key-Value类型，不适合在不同数据集之间建立关系，也不适合进行查询搜索。比如redis的keys pattern这种匹配操作，对redis的性能是灾难。\n\n## Mogodb\nmogodb是一种文档性的数据库。先解释一下文档的数据库，即可以存放xml、json、bson类型系那个的数据。这些数据具备自述性（self-describing），呈现分层的树状数据结构。redis可以用hash存放简单关系型数据。\nmogodb存放json格式数据。\n适合场景：事件记录、内容管理或者博客平台，比如评论系统。\n\n[原文链接](https://segmentfault.com/q/1010000002588088/a-1020000002589415)\n\n","source":"_posts/redis、memcache、mongoDB性能总结.md","raw":"---\ntitle: redis、memcache、mongoDB性能总结\ndate: 2016-04-03 21:03:55\ncategories: SQL\ntags: [Nosql, redis, memcache, mongoDB]\n\n---\n# redis、memcache、mongoDB有哪些区别？\n## Memcached\n### Memcached的优点：\nMemcached可以利用多核优势，单实例吞吐量极高，可以达到几十万QPS（取决于key、value的字节大小以及服务器硬件性能，日常环境中QPS高峰大约在4-6w左右）。适用于最大程度扛量。\n<!-- more -->\n支持直接配置为session handle。\n坑少。\n### Memcached的局限性：\n只支持简单的key/value数据结构，不像Redis可以支持丰富的数据类型。\n无法进行持久化，数据不能备份，只能用于缓存使用，且重启后数据全部丢失。\n无法进行数据同步，不能将MC中的数据迁移到其他MC实例中。\nMemcached内存分配采用Slab Allocation机制管理内存，value大小分布差异较大时会造成内存利用率降低，并引发低利用率时依然出现踢出等问题。需要用户注重value设计。\n\n## Redis\n### Redis的优点：\n支持多种数据结构，如 string（字符串）、 list(双向链表)、dict(hash表)、set(集合）、zset(排序set)、hyperloglog（基数估算）\n支持持久化操作，可以进行aof及rdb数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失的手段。\n支持通过Replication进行数据复制，通过master-slave机制，可以实时进行数据的同步复制，支持多级复制和增量复制，master-slave机制是Redis进行HA的重要手段。\n单线程请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。\n支持pub/sub消息订阅机制，可以用来进行消息订阅与通知。\n支持简单的事务需求，但业界使用场景很少，并不成熟。\n\n### Redis的局限性：\nRedis只能使用单线程，性能受限于CPU性能，故单实例CPU最高才可能达到5-6wQPS每秒（取决于数据结构，数据大小以及服务器硬件性能，日常环境中QPS高峰大约在1-2w左右）。\n支持简单的事务需求，但业界使用场景很少，并不成熟，既是优点也是缺点。\nRedis在string类型上会消耗较多内存，可以使用dict（hash表）压缩存储以降低内存耗用。\n\n：）以下是我个人的补充\nMc和Redis都是Key-Value类型，不适合在不同数据集之间建立关系，也不适合进行查询搜索。比如redis的keys pattern这种匹配操作，对redis的性能是灾难。\n\n## Mogodb\nmogodb是一种文档性的数据库。先解释一下文档的数据库，即可以存放xml、json、bson类型系那个的数据。这些数据具备自述性（self-describing），呈现分层的树状数据结构。redis可以用hash存放简单关系型数据。\nmogodb存放json格式数据。\n适合场景：事件记录、内容管理或者博客平台，比如评论系统。\n\n[原文链接](https://segmentfault.com/q/1010000002588088/a-1020000002589415)\n\n","slug":"redis、memcache、mongoDB性能总结","published":1,"updated":"2016-06-28T11:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzgzekf000oegfymwnxv9si","content":"<h1 id=\"redis、memcache、mongoDB有哪些区别？\"><a href=\"#redis、memcache、mongoDB有哪些区别？\" class=\"headerlink\" title=\"redis、memcache、mongoDB有哪些区别？\"></a>redis、memcache、mongoDB有哪些区别？</h1><h2 id=\"Memcached\"><a href=\"#Memcached\" class=\"headerlink\" title=\"Memcached\"></a>Memcached</h2><h3 id=\"Memcached的优点：\"><a href=\"#Memcached的优点：\" class=\"headerlink\" title=\"Memcached的优点：\"></a>Memcached的优点：</h3><p>Memcached可以利用多核优势，单实例吞吐量极高，可以达到几十万QPS（取决于key、value的字节大小以及服务器硬件性能，日常环境中QPS高峰大约在4-6w左右）。适用于最大程度扛量。<br><a id=\"more\"></a><br>支持直接配置为session handle。<br>坑少。</p>\n<h3 id=\"Memcached的局限性：\"><a href=\"#Memcached的局限性：\" class=\"headerlink\" title=\"Memcached的局限性：\"></a>Memcached的局限性：</h3><p>只支持简单的key/value数据结构，不像Redis可以支持丰富的数据类型。<br>无法进行持久化，数据不能备份，只能用于缓存使用，且重启后数据全部丢失。<br>无法进行数据同步，不能将MC中的数据迁移到其他MC实例中。<br>Memcached内存分配采用Slab Allocation机制管理内存，value大小分布差异较大时会造成内存利用率降低，并引发低利用率时依然出现踢出等问题。需要用户注重value设计。</p>\n<h2 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h2><h3 id=\"Redis的优点：\"><a href=\"#Redis的优点：\" class=\"headerlink\" title=\"Redis的优点：\"></a>Redis的优点：</h3><p>支持多种数据结构，如 string（字符串）、 list(双向链表)、dict(hash表)、set(集合）、zset(排序set)、hyperloglog（基数估算）<br>支持持久化操作，可以进行aof及rdb数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失的手段。<br>支持通过Replication进行数据复制，通过master-slave机制，可以实时进行数据的同步复制，支持多级复制和增量复制，master-slave机制是Redis进行HA的重要手段。<br>单线程请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。<br>支持pub/sub消息订阅机制，可以用来进行消息订阅与通知。<br>支持简单的事务需求，但业界使用场景很少，并不成熟。</p>\n<h3 id=\"Redis的局限性：\"><a href=\"#Redis的局限性：\" class=\"headerlink\" title=\"Redis的局限性：\"></a>Redis的局限性：</h3><p>Redis只能使用单线程，性能受限于CPU性能，故单实例CPU最高才可能达到5-6wQPS每秒（取决于数据结构，数据大小以及服务器硬件性能，日常环境中QPS高峰大约在1-2w左右）。<br>支持简单的事务需求，但业界使用场景很少，并不成熟，既是优点也是缺点。<br>Redis在string类型上会消耗较多内存，可以使用dict（hash表）压缩存储以降低内存耗用。</p>\n<p>：）以下是我个人的补充<br>Mc和Redis都是Key-Value类型，不适合在不同数据集之间建立关系，也不适合进行查询搜索。比如redis的keys pattern这种匹配操作，对redis的性能是灾难。</p>\n<h2 id=\"Mogodb\"><a href=\"#Mogodb\" class=\"headerlink\" title=\"Mogodb\"></a>Mogodb</h2><p>mogodb是一种文档性的数据库。先解释一下文档的数据库，即可以存放xml、json、bson类型系那个的数据。这些数据具备自述性（self-describing），呈现分层的树状数据结构。redis可以用hash存放简单关系型数据。<br>mogodb存放json格式数据。<br>适合场景：事件记录、内容管理或者博客平台，比如评论系统。</p>\n<p><a href=\"https://segmentfault.com/q/1010000002588088/a-1020000002589415\" target=\"_blank\" rel=\"external\">原文链接</a></p>\n","excerpt":"<h1 id=\"redis、memcache、mongoDB有哪些区别？\"><a href=\"#redis、memcache、mongoDB有哪些区别？\" class=\"headerlink\" title=\"redis、memcache、mongoDB有哪些区别？\"></a>redis、memcache、mongoDB有哪些区别？</h1><h2 id=\"Memcached\"><a href=\"#Memcached\" class=\"headerlink\" title=\"Memcached\"></a>Memcached</h2><h3 id=\"Memcached的优点：\"><a href=\"#Memcached的优点：\" class=\"headerlink\" title=\"Memcached的优点：\"></a>Memcached的优点：</h3><p>Memcached可以利用多核优势，单实例吞吐量极高，可以达到几十万QPS（取决于key、value的字节大小以及服务器硬件性能，日常环境中QPS高峰大约在4-6w左右）。适用于最大程度扛量。<br>","more":"<br>支持直接配置为session handle。<br>坑少。</p>\n<h3 id=\"Memcached的局限性：\"><a href=\"#Memcached的局限性：\" class=\"headerlink\" title=\"Memcached的局限性：\"></a>Memcached的局限性：</h3><p>只支持简单的key/value数据结构，不像Redis可以支持丰富的数据类型。<br>无法进行持久化，数据不能备份，只能用于缓存使用，且重启后数据全部丢失。<br>无法进行数据同步，不能将MC中的数据迁移到其他MC实例中。<br>Memcached内存分配采用Slab Allocation机制管理内存，value大小分布差异较大时会造成内存利用率降低，并引发低利用率时依然出现踢出等问题。需要用户注重value设计。</p>\n<h2 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h2><h3 id=\"Redis的优点：\"><a href=\"#Redis的优点：\" class=\"headerlink\" title=\"Redis的优点：\"></a>Redis的优点：</h3><p>支持多种数据结构，如 string（字符串）、 list(双向链表)、dict(hash表)、set(集合）、zset(排序set)、hyperloglog（基数估算）<br>支持持久化操作，可以进行aof及rdb数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失的手段。<br>支持通过Replication进行数据复制，通过master-slave机制，可以实时进行数据的同步复制，支持多级复制和增量复制，master-slave机制是Redis进行HA的重要手段。<br>单线程请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。<br>支持pub/sub消息订阅机制，可以用来进行消息订阅与通知。<br>支持简单的事务需求，但业界使用场景很少，并不成熟。</p>\n<h3 id=\"Redis的局限性：\"><a href=\"#Redis的局限性：\" class=\"headerlink\" title=\"Redis的局限性：\"></a>Redis的局限性：</h3><p>Redis只能使用单线程，性能受限于CPU性能，故单实例CPU最高才可能达到5-6wQPS每秒（取决于数据结构，数据大小以及服务器硬件性能，日常环境中QPS高峰大约在1-2w左右）。<br>支持简单的事务需求，但业界使用场景很少，并不成熟，既是优点也是缺点。<br>Redis在string类型上会消耗较多内存，可以使用dict（hash表）压缩存储以降低内存耗用。</p>\n<p>：）以下是我个人的补充<br>Mc和Redis都是Key-Value类型，不适合在不同数据集之间建立关系，也不适合进行查询搜索。比如redis的keys pattern这种匹配操作，对redis的性能是灾难。</p>\n<h2 id=\"Mogodb\"><a href=\"#Mogodb\" class=\"headerlink\" title=\"Mogodb\"></a>Mogodb</h2><p>mogodb是一种文档性的数据库。先解释一下文档的数据库，即可以存放xml、json、bson类型系那个的数据。这些数据具备自述性（self-describing），呈现分层的树状数据结构。redis可以用hash存放简单关系型数据。<br>mogodb存放json格式数据。<br>适合场景：事件记录、内容管理或者博客平台，比如评论系统。</p>\n<p><a href=\"https://segmentfault.com/q/1010000002588088/a-1020000002589415\">原文链接</a></p>"},{"title":"关于爬虫你不得不知道的几个库","date":"2016-04-02T02:21:33.000Z","_content":"# 关于python爬虫\n首先解释一下爬虫的原理，就是使用代码模拟浏览器动作通过HTTP协议远程和服务器进行交互，理论上只要是人能操作网站做的事情爬虫都可以做，比如登录，注册，获取信息，但是爬虫有两大壁垒，一个是IP禁止，一个是验证码，前一个基于网站的用户管理，后一个则基于高深莫测的图像识别（机器学习）。\n除此之外，爬虫的优势是高效。\n当然对于一些防御力比较低的网站是可以用爬虫进行攻击的，通过大量访问。不过这种攻击方式比较原始，而且没有技术含量。\n爬虫主要还是被人们用以获取网络上的信息，该信息来自服务器，走的是HTTP协议。\n\n关于HTTP协议我就不多说了，大家可以参考我的另一篇日志[HTTP协议详解](http://adu.404nf.cn/2016/03/30/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/)，下面我来说说实现爬虫的流程。\n<!-- more -->\n首先，爬虫要向服务器发送请求，如果请求返回200则可以提取出HTML代码，或json格式对象，或者是XML，就是我们浏览器接收到的代码（如果header配置和浏览器发出的请求header一致，返回的信息是相同的），前两种比较常见。得到服务器返回信息后我们需要进行处理，如果是json的话在python内直接用dict就可以处理了，如果是HTML则需要用到BeautifulSoup等解析工具，这里推荐使用lxml解析器，因为综合性能和易用性来看这是最优解，不要去纠结正则表达式xpath和那个什么pyQuera了，使用BeautifulSoup，支持python2和python3。\n最后，对于了解过python的朋友，推荐使用gevent协程进行一个并发处理。\n下面我一个个解释：\n## requests\n接触python的web应用不可不知的一个库，煞是强大，官方文档供参考：\n\n[Requests: HTTP for Humans](http://docs.python-requests.org/zh_CN/latest/)\n\n另外还有个高级用法：\n\n[开发者接口](http://docs.python-requests.org/zh_CN/latest/api.html)\n\n## BeautifulSoup\n同样，没有什么比文档更好的解释：\n\n[Beautiful Soup 4.2.0 文档](http://beautifulsoup.readthedocs.org/zh_CN/latest/)\n\n## gevent\n这个我没有看官方文档，我觉得这篇文章讲的就可以：\n\n[gevent程序员指南](http://xlambda.com/gevent-tutorial/)\n\n## 既然说到文档\n不可不知的一个python文档而我却最近才知道的。。\npython官方文档：\n\n[python官方文档](http://python.usyiyi.cn/)\n\npip文档，分享给大家：\n\n[pip](https://pip.pypa.io/en/stable/installing/)(可惜没有中文的)\n\n\n## 最后是不是该还有个例子\n等有空再写吧","source":"_posts/关于爬虫你不得不知道的几个库.md","raw":"---\ntitle: 关于爬虫你不得不知道的几个库\ndate: 2016-04-02 10:21:33\ncategories: crawler\ntags: [爬虫, python]\n\t\n---\n# 关于python爬虫\n首先解释一下爬虫的原理，就是使用代码模拟浏览器动作通过HTTP协议远程和服务器进行交互，理论上只要是人能操作网站做的事情爬虫都可以做，比如登录，注册，获取信息，但是爬虫有两大壁垒，一个是IP禁止，一个是验证码，前一个基于网站的用户管理，后一个则基于高深莫测的图像识别（机器学习）。\n除此之外，爬虫的优势是高效。\n当然对于一些防御力比较低的网站是可以用爬虫进行攻击的，通过大量访问。不过这种攻击方式比较原始，而且没有技术含量。\n爬虫主要还是被人们用以获取网络上的信息，该信息来自服务器，走的是HTTP协议。\n\n关于HTTP协议我就不多说了，大家可以参考我的另一篇日志[HTTP协议详解](http://adu.404nf.cn/2016/03/30/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/)，下面我来说说实现爬虫的流程。\n<!-- more -->\n首先，爬虫要向服务器发送请求，如果请求返回200则可以提取出HTML代码，或json格式对象，或者是XML，就是我们浏览器接收到的代码（如果header配置和浏览器发出的请求header一致，返回的信息是相同的），前两种比较常见。得到服务器返回信息后我们需要进行处理，如果是json的话在python内直接用dict就可以处理了，如果是HTML则需要用到BeautifulSoup等解析工具，这里推荐使用lxml解析器，因为综合性能和易用性来看这是最优解，不要去纠结正则表达式xpath和那个什么pyQuera了，使用BeautifulSoup，支持python2和python3。\n最后，对于了解过python的朋友，推荐使用gevent协程进行一个并发处理。\n下面我一个个解释：\n## requests\n接触python的web应用不可不知的一个库，煞是强大，官方文档供参考：\n\n[Requests: HTTP for Humans](http://docs.python-requests.org/zh_CN/latest/)\n\n另外还有个高级用法：\n\n[开发者接口](http://docs.python-requests.org/zh_CN/latest/api.html)\n\n## BeautifulSoup\n同样，没有什么比文档更好的解释：\n\n[Beautiful Soup 4.2.0 文档](http://beautifulsoup.readthedocs.org/zh_CN/latest/)\n\n## gevent\n这个我没有看官方文档，我觉得这篇文章讲的就可以：\n\n[gevent程序员指南](http://xlambda.com/gevent-tutorial/)\n\n## 既然说到文档\n不可不知的一个python文档而我却最近才知道的。。\npython官方文档：\n\n[python官方文档](http://python.usyiyi.cn/)\n\npip文档，分享给大家：\n\n[pip](https://pip.pypa.io/en/stable/installing/)(可惜没有中文的)\n\n\n## 最后是不是该还有个例子\n等有空再写吧","slug":"关于爬虫你不得不知道的几个库","published":1,"updated":"2016-06-28T11:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzgzekh000segfyzicnbl5q","content":"<h1 id=\"关于python爬虫\"><a href=\"#关于python爬虫\" class=\"headerlink\" title=\"关于python爬虫\"></a>关于python爬虫</h1><p>首先解释一下爬虫的原理，就是使用代码模拟浏览器动作通过HTTP协议远程和服务器进行交互，理论上只要是人能操作网站做的事情爬虫都可以做，比如登录，注册，获取信息，但是爬虫有两大壁垒，一个是IP禁止，一个是验证码，前一个基于网站的用户管理，后一个则基于高深莫测的图像识别（机器学习）。<br>除此之外，爬虫的优势是高效。<br>当然对于一些防御力比较低的网站是可以用爬虫进行攻击的，通过大量访问。不过这种攻击方式比较原始，而且没有技术含量。<br>爬虫主要还是被人们用以获取网络上的信息，该信息来自服务器，走的是HTTP协议。</p>\n<p>关于HTTP协议我就不多说了，大家可以参考我的另一篇日志<a href=\"http://adu.404nf.cn/2016/03/30/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/\">HTTP协议详解</a>，下面我来说说实现爬虫的流程。<br><a id=\"more\"></a><br>首先，爬虫要向服务器发送请求，如果请求返回200则可以提取出HTML代码，或json格式对象，或者是XML，就是我们浏览器接收到的代码（如果header配置和浏览器发出的请求header一致，返回的信息是相同的），前两种比较常见。得到服务器返回信息后我们需要进行处理，如果是json的话在python内直接用dict就可以处理了，如果是HTML则需要用到BeautifulSoup等解析工具，这里推荐使用lxml解析器，因为综合性能和易用性来看这是最优解，不要去纠结正则表达式xpath和那个什么pyQuera了，使用BeautifulSoup，支持python2和python3。<br>最后，对于了解过python的朋友，推荐使用gevent协程进行一个并发处理。<br>下面我一个个解释：</p>\n<h2 id=\"requests\"><a href=\"#requests\" class=\"headerlink\" title=\"requests\"></a>requests</h2><p>接触python的web应用不可不知的一个库，煞是强大，官方文档供参考：</p>\n<p><a href=\"http://docs.python-requests.org/zh_CN/latest/\" target=\"_blank\" rel=\"external\">Requests: HTTP for Humans</a></p>\n<p>另外还有个高级用法：</p>\n<p><a href=\"http://docs.python-requests.org/zh_CN/latest/api.html\" target=\"_blank\" rel=\"external\">开发者接口</a></p>\n<h2 id=\"BeautifulSoup\"><a href=\"#BeautifulSoup\" class=\"headerlink\" title=\"BeautifulSoup\"></a>BeautifulSoup</h2><p>同样，没有什么比文档更好的解释：</p>\n<p><a href=\"http://beautifulsoup.readthedocs.org/zh_CN/latest/\" target=\"_blank\" rel=\"external\">Beautiful Soup 4.2.0 文档</a></p>\n<h2 id=\"gevent\"><a href=\"#gevent\" class=\"headerlink\" title=\"gevent\"></a>gevent</h2><p>这个我没有看官方文档，我觉得这篇文章讲的就可以：</p>\n<p><a href=\"http://xlambda.com/gevent-tutorial/\" target=\"_blank\" rel=\"external\">gevent程序员指南</a></p>\n<h2 id=\"既然说到文档\"><a href=\"#既然说到文档\" class=\"headerlink\" title=\"既然说到文档\"></a>既然说到文档</h2><p>不可不知的一个python文档而我却最近才知道的。。<br>python官方文档：</p>\n<p><a href=\"http://python.usyiyi.cn/\" target=\"_blank\" rel=\"external\">python官方文档</a></p>\n<p>pip文档，分享给大家：</p>\n<p><a href=\"https://pip.pypa.io/en/stable/installing/\" target=\"_blank\" rel=\"external\">pip</a>(可惜没有中文的)</p>\n<h2 id=\"最后是不是该还有个例子\"><a href=\"#最后是不是该还有个例子\" class=\"headerlink\" title=\"最后是不是该还有个例子\"></a>最后是不是该还有个例子</h2><p>等有空再写吧</p>\n","excerpt":"<h1 id=\"关于python爬虫\"><a href=\"#关于python爬虫\" class=\"headerlink\" title=\"关于python爬虫\"></a>关于python爬虫</h1><p>首先解释一下爬虫的原理，就是使用代码模拟浏览器动作通过HTTP协议远程和服务器进行交互，理论上只要是人能操作网站做的事情爬虫都可以做，比如登录，注册，获取信息，但是爬虫有两大壁垒，一个是IP禁止，一个是验证码，前一个基于网站的用户管理，后一个则基于高深莫测的图像识别（机器学习）。<br>除此之外，爬虫的优势是高效。<br>当然对于一些防御力比较低的网站是可以用爬虫进行攻击的，通过大量访问。不过这种攻击方式比较原始，而且没有技术含量。<br>爬虫主要还是被人们用以获取网络上的信息，该信息来自服务器，走的是HTTP协议。</p>\n<p>关于HTTP协议我就不多说了，大家可以参考我的另一篇日志<a href=\"http://adu.404nf.cn/2016/03/30/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/\">HTTP协议详解</a>，下面我来说说实现爬虫的流程。<br>","more":"<br>首先，爬虫要向服务器发送请求，如果请求返回200则可以提取出HTML代码，或json格式对象，或者是XML，就是我们浏览器接收到的代码（如果header配置和浏览器发出的请求header一致，返回的信息是相同的），前两种比较常见。得到服务器返回信息后我们需要进行处理，如果是json的话在python内直接用dict就可以处理了，如果是HTML则需要用到BeautifulSoup等解析工具，这里推荐使用lxml解析器，因为综合性能和易用性来看这是最优解，不要去纠结正则表达式xpath和那个什么pyQuera了，使用BeautifulSoup，支持python2和python3。<br>最后，对于了解过python的朋友，推荐使用gevent协程进行一个并发处理。<br>下面我一个个解释：</p>\n<h2 id=\"requests\"><a href=\"#requests\" class=\"headerlink\" title=\"requests\"></a>requests</h2><p>接触python的web应用不可不知的一个库，煞是强大，官方文档供参考：</p>\n<p><a href=\"http://docs.python-requests.org/zh_CN/latest/\">Requests: HTTP for Humans</a></p>\n<p>另外还有个高级用法：</p>\n<p><a href=\"http://docs.python-requests.org/zh_CN/latest/api.html\">开发者接口</a></p>\n<h2 id=\"BeautifulSoup\"><a href=\"#BeautifulSoup\" class=\"headerlink\" title=\"BeautifulSoup\"></a>BeautifulSoup</h2><p>同样，没有什么比文档更好的解释：</p>\n<p><a href=\"http://beautifulsoup.readthedocs.org/zh_CN/latest/\">Beautiful Soup 4.2.0 文档</a></p>\n<h2 id=\"gevent\"><a href=\"#gevent\" class=\"headerlink\" title=\"gevent\"></a>gevent</h2><p>这个我没有看官方文档，我觉得这篇文章讲的就可以：</p>\n<p><a href=\"http://xlambda.com/gevent-tutorial/\">gevent程序员指南</a></p>\n<h2 id=\"既然说到文档\"><a href=\"#既然说到文档\" class=\"headerlink\" title=\"既然说到文档\"></a>既然说到文档</h2><p>不可不知的一个python文档而我却最近才知道的。。<br>python官方文档：</p>\n<p><a href=\"http://python.usyiyi.cn/\">python官方文档</a></p>\n<p>pip文档，分享给大家：</p>\n<p><a href=\"https://pip.pypa.io/en/stable/installing/\">pip</a>(可惜没有中文的)</p>\n<h2 id=\"最后是不是该还有个例子\"><a href=\"#最后是不是该还有个例子\" class=\"headerlink\" title=\"最后是不是该还有个例子\"></a>最后是不是该还有个例子</h2><p>等有空再写吧</p>"},{"title":"thoughtworks面试","date":"2016-04-20T13:38:11.000Z","_content":"今天是2016年4月20日\n\n地点在成都武侯区的一间电梯公寓\n<!-- more -->\n两个小时前，我的心情还无比地紧张。\n\n明天我将要面试一家最喜欢的公司。\n\n从电影院走出来，心情居然无比的放松，此刻我的能力已经不可能有太多提升，面试终于成为一场面试。\n\n好久没有像这一个月一样努力过，虽然回到成都后我一直觉得自己很努力，很努力地去生活，很努力的去忘掉不愉快的北京之行。\n\n我是为了梦想去北京的。\n\n有人告诉我，年轻就要去做想做的事，做了才不会后悔。我选择了电影。\n\n为了梦想，我住过北京三环600块一个月的地下室，和蹲点北影的群演们住在一起，我也当过群演，吃过五毛钱一顿的盒饭，拍过四十块钱一天的网络剧。那时候的我不觉得孤单，我觉得自己在梦想的起点，这些苦逼的经历都会成为未来牛逼的资本。\n\n可是未来和我呵呵了。\n\n转眼我得到了一个在剧组工作的机会，工作辛苦是我从来没做过的粗活累活儿，一个月五百块钱，我开心的像个第一次领到工钱的农民工。\n\n记得有一晚拍夜喜，从来扛不动的高台我终于抗动了，我觉得我胜任了这份工作，摄影掌机在游泳池那头喊：夜宵呢？！！这头有河南的灯光在窃窃私语，不知道为什么，吹着厦门的海风我竟然有些开心。\n\n转眼到了内蒙古，我见到了成龙大哥，说实话之前对他并没有特别喜欢，只是知道他是个了不起的文化符号，不过近距离接触确实觉得大哥是个很了不起的人，他没有教会我什么。呵呵，让你们失望了。\n\n北京回来之后，我的同学们都相继开始出去实习，偌大的校园里我每天泡图书馆，欧洲史，电影史，艺术理论。我觉得自己很充实，我觉得生活充满希望，因为北京有一份甚至很多份很好的工作等着我毕业后去做。\n\n转眼到了毕业。\n\n来到北京，我开始找工作。\n\n从两千五一个月的剪辑，我只干了三天，不知道为什么，和老总翻脸了。我至今都觉得这可能是宿命，如果不是那样，我可能现在还在北京，也许还在做剪辑。\n\n辗转之中我意识到要向做电影，必须得先学习，要学习又要做电影，唯一的路就是进入北京电影学院，在这个过程中我闭门造车，在北京度过了我最艰难的三个月。\n\n三个月里几乎没有和人说过话。\n\n那种孤独是我这辈子都会记得的。\n\n北京的雪，多美啊。一觉醒来，竟然看到了北京的初雪，那是那段日子里唯一美好的记忆。\n\n几乎没有悬念的，我回到了成都。\n\n我以为我的梦想死了。我以为我对事业不会再抱有激情了，就在这个时候，我和我的女朋友分手了。\n\n生活还得继续，我继续在一家科技公司做着不知道为什么要做的工作。\n\n在公司我觉得我是个挣钱的机器，回到家我觉得我活着就是为了活着，没有什么激情，也没有什么朋友。\n\n中间收到几个朋友的消息，得知我们很看好的一对对都分了。\n\n毕业是一个改造我们世界观的转折点。\n\n就这样过了一阵，我以为我已经死了。\n\n我以为再也不会有一份工作让我不要工资都愿意干了，\n\n我以为再也不会有一份事业是和钱无关的，\n\n我以为再也没有把碗擦肩的兄弟，一起闯荡江湖的热情了。\n\n就在这个时候，我遇到了thoughtworks。\n\nthoughtworks让我重新找回了自我。\n\n很久没有那种早上恨不得起的更早，晚上伸伸懒腰觉得又是充实的一天的日子了。\n\n从接到面试邀请，到正式进入公司面试，差不多一个月时间，我每天都在充满希望的读过，\n\n如饥似渴地学习，填满我空空如也大脑，几乎是种病态的对知识的渴望，我的身体和大脑都处于极度饥渴的状态，\n\n不断地学习计算机底层的东西，了解自己用过的东西的原理。\n\n重新翻出大学的课本，温习错过的知识。\n\n想起当年老师在台上讲的都是被我判定为无用的知识，我认定了自己以后不会做这行，我以为我会是个优秀的导演，可就像刚进剧组愿意做好一个场务，那为什么做为一个大学生，你不先学好你的本专业？\n\n我意识到这点了，还好我还年轻，我把以前的知识都翻出来看了一遍，还好不是很陌生。\n\n我又从网上找了很多资料一一阅读，我感受到了学习的快乐，有一种上天入地的感觉。\n\n现实的世界太狭窄，在知识的海洋里我们都拥有无限的可能。\n\n我感觉内心深处，自己慢慢醒来。\n\n重新开始学习，重新开始看书，重新抱起了我的吉他。\n\n生活开始有了希望，我的脸上浮现出了微笑。\n\n为了面试，我跟公司领导们撒了谎，对不起，因为我意识到我此刻有一件重要的事请要去做，他可能改变我事业的起点，\n\n然而当我做出这个决定，我已经被悄悄改变了。\n\n不管结果怎样，谢谢thoughtworks，谢谢你唤醒了我对生活的激情，有种缘分叫命中注定。","source":"_posts/thoughtworks面试.md","raw":"---\ntitle: thoughtworks面试\ndate: 2016-04-20 21:38:11\ntags: thoughtworks\n---\n今天是2016年4月20日\n\n地点在成都武侯区的一间电梯公寓\n<!-- more -->\n两个小时前，我的心情还无比地紧张。\n\n明天我将要面试一家最喜欢的公司。\n\n从电影院走出来，心情居然无比的放松，此刻我的能力已经不可能有太多提升，面试终于成为一场面试。\n\n好久没有像这一个月一样努力过，虽然回到成都后我一直觉得自己很努力，很努力地去生活，很努力的去忘掉不愉快的北京之行。\n\n我是为了梦想去北京的。\n\n有人告诉我，年轻就要去做想做的事，做了才不会后悔。我选择了电影。\n\n为了梦想，我住过北京三环600块一个月的地下室，和蹲点北影的群演们住在一起，我也当过群演，吃过五毛钱一顿的盒饭，拍过四十块钱一天的网络剧。那时候的我不觉得孤单，我觉得自己在梦想的起点，这些苦逼的经历都会成为未来牛逼的资本。\n\n可是未来和我呵呵了。\n\n转眼我得到了一个在剧组工作的机会，工作辛苦是我从来没做过的粗活累活儿，一个月五百块钱，我开心的像个第一次领到工钱的农民工。\n\n记得有一晚拍夜喜，从来扛不动的高台我终于抗动了，我觉得我胜任了这份工作，摄影掌机在游泳池那头喊：夜宵呢？！！这头有河南的灯光在窃窃私语，不知道为什么，吹着厦门的海风我竟然有些开心。\n\n转眼到了内蒙古，我见到了成龙大哥，说实话之前对他并没有特别喜欢，只是知道他是个了不起的文化符号，不过近距离接触确实觉得大哥是个很了不起的人，他没有教会我什么。呵呵，让你们失望了。\n\n北京回来之后，我的同学们都相继开始出去实习，偌大的校园里我每天泡图书馆，欧洲史，电影史，艺术理论。我觉得自己很充实，我觉得生活充满希望，因为北京有一份甚至很多份很好的工作等着我毕业后去做。\n\n转眼到了毕业。\n\n来到北京，我开始找工作。\n\n从两千五一个月的剪辑，我只干了三天，不知道为什么，和老总翻脸了。我至今都觉得这可能是宿命，如果不是那样，我可能现在还在北京，也许还在做剪辑。\n\n辗转之中我意识到要向做电影，必须得先学习，要学习又要做电影，唯一的路就是进入北京电影学院，在这个过程中我闭门造车，在北京度过了我最艰难的三个月。\n\n三个月里几乎没有和人说过话。\n\n那种孤独是我这辈子都会记得的。\n\n北京的雪，多美啊。一觉醒来，竟然看到了北京的初雪，那是那段日子里唯一美好的记忆。\n\n几乎没有悬念的，我回到了成都。\n\n我以为我的梦想死了。我以为我对事业不会再抱有激情了，就在这个时候，我和我的女朋友分手了。\n\n生活还得继续，我继续在一家科技公司做着不知道为什么要做的工作。\n\n在公司我觉得我是个挣钱的机器，回到家我觉得我活着就是为了活着，没有什么激情，也没有什么朋友。\n\n中间收到几个朋友的消息，得知我们很看好的一对对都分了。\n\n毕业是一个改造我们世界观的转折点。\n\n就这样过了一阵，我以为我已经死了。\n\n我以为再也不会有一份工作让我不要工资都愿意干了，\n\n我以为再也不会有一份事业是和钱无关的，\n\n我以为再也没有把碗擦肩的兄弟，一起闯荡江湖的热情了。\n\n就在这个时候，我遇到了thoughtworks。\n\nthoughtworks让我重新找回了自我。\n\n很久没有那种早上恨不得起的更早，晚上伸伸懒腰觉得又是充实的一天的日子了。\n\n从接到面试邀请，到正式进入公司面试，差不多一个月时间，我每天都在充满希望的读过，\n\n如饥似渴地学习，填满我空空如也大脑，几乎是种病态的对知识的渴望，我的身体和大脑都处于极度饥渴的状态，\n\n不断地学习计算机底层的东西，了解自己用过的东西的原理。\n\n重新翻出大学的课本，温习错过的知识。\n\n想起当年老师在台上讲的都是被我判定为无用的知识，我认定了自己以后不会做这行，我以为我会是个优秀的导演，可就像刚进剧组愿意做好一个场务，那为什么做为一个大学生，你不先学好你的本专业？\n\n我意识到这点了，还好我还年轻，我把以前的知识都翻出来看了一遍，还好不是很陌生。\n\n我又从网上找了很多资料一一阅读，我感受到了学习的快乐，有一种上天入地的感觉。\n\n现实的世界太狭窄，在知识的海洋里我们都拥有无限的可能。\n\n我感觉内心深处，自己慢慢醒来。\n\n重新开始学习，重新开始看书，重新抱起了我的吉他。\n\n生活开始有了希望，我的脸上浮现出了微笑。\n\n为了面试，我跟公司领导们撒了谎，对不起，因为我意识到我此刻有一件重要的事请要去做，他可能改变我事业的起点，\n\n然而当我做出这个决定，我已经被悄悄改变了。\n\n不管结果怎样，谢谢thoughtworks，谢谢你唤醒了我对生活的激情，有种缘分叫命中注定。","slug":"thoughtworks面试","published":1,"updated":"2016-06-28T11:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzgzekk000uegfy2rf93a0t","content":"<p>今天是2016年4月20日</p>\n<p>地点在成都武侯区的一间电梯公寓<br><a id=\"more\"></a><br>两个小时前，我的心情还无比地紧张。</p>\n<p>明天我将要面试一家最喜欢的公司。</p>\n<p>从电影院走出来，心情居然无比的放松，此刻我的能力已经不可能有太多提升，面试终于成为一场面试。</p>\n<p>好久没有像这一个月一样努力过，虽然回到成都后我一直觉得自己很努力，很努力地去生活，很努力的去忘掉不愉快的北京之行。</p>\n<p>我是为了梦想去北京的。</p>\n<p>有人告诉我，年轻就要去做想做的事，做了才不会后悔。我选择了电影。</p>\n<p>为了梦想，我住过北京三环600块一个月的地下室，和蹲点北影的群演们住在一起，我也当过群演，吃过五毛钱一顿的盒饭，拍过四十块钱一天的网络剧。那时候的我不觉得孤单，我觉得自己在梦想的起点，这些苦逼的经历都会成为未来牛逼的资本。</p>\n<p>可是未来和我呵呵了。</p>\n<p>转眼我得到了一个在剧组工作的机会，工作辛苦是我从来没做过的粗活累活儿，一个月五百块钱，我开心的像个第一次领到工钱的农民工。</p>\n<p>记得有一晚拍夜喜，从来扛不动的高台我终于抗动了，我觉得我胜任了这份工作，摄影掌机在游泳池那头喊：夜宵呢？！！这头有河南的灯光在窃窃私语，不知道为什么，吹着厦门的海风我竟然有些开心。</p>\n<p>转眼到了内蒙古，我见到了成龙大哥，说实话之前对他并没有特别喜欢，只是知道他是个了不起的文化符号，不过近距离接触确实觉得大哥是个很了不起的人，他没有教会我什么。呵呵，让你们失望了。</p>\n<p>北京回来之后，我的同学们都相继开始出去实习，偌大的校园里我每天泡图书馆，欧洲史，电影史，艺术理论。我觉得自己很充实，我觉得生活充满希望，因为北京有一份甚至很多份很好的工作等着我毕业后去做。</p>\n<p>转眼到了毕业。</p>\n<p>来到北京，我开始找工作。</p>\n<p>从两千五一个月的剪辑，我只干了三天，不知道为什么，和老总翻脸了。我至今都觉得这可能是宿命，如果不是那样，我可能现在还在北京，也许还在做剪辑。</p>\n<p>辗转之中我意识到要向做电影，必须得先学习，要学习又要做电影，唯一的路就是进入北京电影学院，在这个过程中我闭门造车，在北京度过了我最艰难的三个月。</p>\n<p>三个月里几乎没有和人说过话。</p>\n<p>那种孤独是我这辈子都会记得的。</p>\n<p>北京的雪，多美啊。一觉醒来，竟然看到了北京的初雪，那是那段日子里唯一美好的记忆。</p>\n<p>几乎没有悬念的，我回到了成都。</p>\n<p>我以为我的梦想死了。我以为我对事业不会再抱有激情了，就在这个时候，我和我的女朋友分手了。</p>\n<p>生活还得继续，我继续在一家科技公司做着不知道为什么要做的工作。</p>\n<p>在公司我觉得我是个挣钱的机器，回到家我觉得我活着就是为了活着，没有什么激情，也没有什么朋友。</p>\n<p>中间收到几个朋友的消息，得知我们很看好的一对对都分了。</p>\n<p>毕业是一个改造我们世界观的转折点。</p>\n<p>就这样过了一阵，我以为我已经死了。</p>\n<p>我以为再也不会有一份工作让我不要工资都愿意干了，</p>\n<p>我以为再也不会有一份事业是和钱无关的，</p>\n<p>我以为再也没有把碗擦肩的兄弟，一起闯荡江湖的热情了。</p>\n<p>就在这个时候，我遇到了thoughtworks。</p>\n<p>thoughtworks让我重新找回了自我。</p>\n<p>很久没有那种早上恨不得起的更早，晚上伸伸懒腰觉得又是充实的一天的日子了。</p>\n<p>从接到面试邀请，到正式进入公司面试，差不多一个月时间，我每天都在充满希望的读过，</p>\n<p>如饥似渴地学习，填满我空空如也大脑，几乎是种病态的对知识的渴望，我的身体和大脑都处于极度饥渴的状态，</p>\n<p>不断地学习计算机底层的东西，了解自己用过的东西的原理。</p>\n<p>重新翻出大学的课本，温习错过的知识。</p>\n<p>想起当年老师在台上讲的都是被我判定为无用的知识，我认定了自己以后不会做这行，我以为我会是个优秀的导演，可就像刚进剧组愿意做好一个场务，那为什么做为一个大学生，你不先学好你的本专业？</p>\n<p>我意识到这点了，还好我还年轻，我把以前的知识都翻出来看了一遍，还好不是很陌生。</p>\n<p>我又从网上找了很多资料一一阅读，我感受到了学习的快乐，有一种上天入地的感觉。</p>\n<p>现实的世界太狭窄，在知识的海洋里我们都拥有无限的可能。</p>\n<p>我感觉内心深处，自己慢慢醒来。</p>\n<p>重新开始学习，重新开始看书，重新抱起了我的吉他。</p>\n<p>生活开始有了希望，我的脸上浮现出了微笑。</p>\n<p>为了面试，我跟公司领导们撒了谎，对不起，因为我意识到我此刻有一件重要的事请要去做，他可能改变我事业的起点，</p>\n<p>然而当我做出这个决定，我已经被悄悄改变了。</p>\n<p>不管结果怎样，谢谢thoughtworks，谢谢你唤醒了我对生活的激情，有种缘分叫命中注定。</p>\n","excerpt":"<p>今天是2016年4月20日</p>\n<p>地点在成都武侯区的一间电梯公寓<br>","more":"<br>两个小时前，我的心情还无比地紧张。</p>\n<p>明天我将要面试一家最喜欢的公司。</p>\n<p>从电影院走出来，心情居然无比的放松，此刻我的能力已经不可能有太多提升，面试终于成为一场面试。</p>\n<p>好久没有像这一个月一样努力过，虽然回到成都后我一直觉得自己很努力，很努力地去生活，很努力的去忘掉不愉快的北京之行。</p>\n<p>我是为了梦想去北京的。</p>\n<p>有人告诉我，年轻就要去做想做的事，做了才不会后悔。我选择了电影。</p>\n<p>为了梦想，我住过北京三环600块一个月的地下室，和蹲点北影的群演们住在一起，我也当过群演，吃过五毛钱一顿的盒饭，拍过四十块钱一天的网络剧。那时候的我不觉得孤单，我觉得自己在梦想的起点，这些苦逼的经历都会成为未来牛逼的资本。</p>\n<p>可是未来和我呵呵了。</p>\n<p>转眼我得到了一个在剧组工作的机会，工作辛苦是我从来没做过的粗活累活儿，一个月五百块钱，我开心的像个第一次领到工钱的农民工。</p>\n<p>记得有一晚拍夜喜，从来扛不动的高台我终于抗动了，我觉得我胜任了这份工作，摄影掌机在游泳池那头喊：夜宵呢？！！这头有河南的灯光在窃窃私语，不知道为什么，吹着厦门的海风我竟然有些开心。</p>\n<p>转眼到了内蒙古，我见到了成龙大哥，说实话之前对他并没有特别喜欢，只是知道他是个了不起的文化符号，不过近距离接触确实觉得大哥是个很了不起的人，他没有教会我什么。呵呵，让你们失望了。</p>\n<p>北京回来之后，我的同学们都相继开始出去实习，偌大的校园里我每天泡图书馆，欧洲史，电影史，艺术理论。我觉得自己很充实，我觉得生活充满希望，因为北京有一份甚至很多份很好的工作等着我毕业后去做。</p>\n<p>转眼到了毕业。</p>\n<p>来到北京，我开始找工作。</p>\n<p>从两千五一个月的剪辑，我只干了三天，不知道为什么，和老总翻脸了。我至今都觉得这可能是宿命，如果不是那样，我可能现在还在北京，也许还在做剪辑。</p>\n<p>辗转之中我意识到要向做电影，必须得先学习，要学习又要做电影，唯一的路就是进入北京电影学院，在这个过程中我闭门造车，在北京度过了我最艰难的三个月。</p>\n<p>三个月里几乎没有和人说过话。</p>\n<p>那种孤独是我这辈子都会记得的。</p>\n<p>北京的雪，多美啊。一觉醒来，竟然看到了北京的初雪，那是那段日子里唯一美好的记忆。</p>\n<p>几乎没有悬念的，我回到了成都。</p>\n<p>我以为我的梦想死了。我以为我对事业不会再抱有激情了，就在这个时候，我和我的女朋友分手了。</p>\n<p>生活还得继续，我继续在一家科技公司做着不知道为什么要做的工作。</p>\n<p>在公司我觉得我是个挣钱的机器，回到家我觉得我活着就是为了活着，没有什么激情，也没有什么朋友。</p>\n<p>中间收到几个朋友的消息，得知我们很看好的一对对都分了。</p>\n<p>毕业是一个改造我们世界观的转折点。</p>\n<p>就这样过了一阵，我以为我已经死了。</p>\n<p>我以为再也不会有一份工作让我不要工资都愿意干了，</p>\n<p>我以为再也不会有一份事业是和钱无关的，</p>\n<p>我以为再也没有把碗擦肩的兄弟，一起闯荡江湖的热情了。</p>\n<p>就在这个时候，我遇到了thoughtworks。</p>\n<p>thoughtworks让我重新找回了自我。</p>\n<p>很久没有那种早上恨不得起的更早，晚上伸伸懒腰觉得又是充实的一天的日子了。</p>\n<p>从接到面试邀请，到正式进入公司面试，差不多一个月时间，我每天都在充满希望的读过，</p>\n<p>如饥似渴地学习，填满我空空如也大脑，几乎是种病态的对知识的渴望，我的身体和大脑都处于极度饥渴的状态，</p>\n<p>不断地学习计算机底层的东西，了解自己用过的东西的原理。</p>\n<p>重新翻出大学的课本，温习错过的知识。</p>\n<p>想起当年老师在台上讲的都是被我判定为无用的知识，我认定了自己以后不会做这行，我以为我会是个优秀的导演，可就像刚进剧组愿意做好一个场务，那为什么做为一个大学生，你不先学好你的本专业？</p>\n<p>我意识到这点了，还好我还年轻，我把以前的知识都翻出来看了一遍，还好不是很陌生。</p>\n<p>我又从网上找了很多资料一一阅读，我感受到了学习的快乐，有一种上天入地的感觉。</p>\n<p>现实的世界太狭窄，在知识的海洋里我们都拥有无限的可能。</p>\n<p>我感觉内心深处，自己慢慢醒来。</p>\n<p>重新开始学习，重新开始看书，重新抱起了我的吉他。</p>\n<p>生活开始有了希望，我的脸上浮现出了微笑。</p>\n<p>为了面试，我跟公司领导们撒了谎，对不起，因为我意识到我此刻有一件重要的事请要去做，他可能改变我事业的起点，</p>\n<p>然而当我做出这个决定，我已经被悄悄改变了。</p>\n<p>不管结果怎样，谢谢thoughtworks，谢谢你唤醒了我对生活的激情，有种缘分叫命中注定。</p>"},{"title":"推荐几个学习python还不错的网站","date":"2016-03-29T13:16:04.000Z","_content":"# 推荐几个学习python还不错的网站\n\n一开始自学python我去过慕课网和极客学院，这种学习网站比较系统化但是缺点是不便于记忆和不方便查阅，到后面我才发现文档才是最好的老师。不过还是有些个人博客，网站写的比较好的，在这里推荐两个：\n<!-- more -->\n## 廖雪峰的官方网站\n[http://www.liaoxuefeng.com/](http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000)\n\n这个主要是python3和js，git讲得也不错，通俗易懂，适合新手\n\n## 菜鸟教程\n[http://www.runoob.com/python](http://www.runoob.com/python/python-tutorial.html)\n\n菜鸟教程很多课程都不错，东西还比较多\n\n## 官方文档\n\n[https://docs.python.org/3/library/](https://docs.python.org/3/library/functions.html)\n\n另外，最好的老师，还是官方文档，这里附上python3官方文档的地址\n\n## 再来个python包下载地址\n[http://www.lfd.uci.edu/~gohlke/pythonlibs/](http://www.lfd.uci.edu/~gohlke/pythonlibs/)","source":"_posts/推荐几个学习python还不错的网站.md","raw":"---\ntitle: 推荐几个学习python还不错的网站\ndate: 2016-03-29 21:16:04\ncategories: study\ntags:\n\tpython\n---\n# 推荐几个学习python还不错的网站\n\n一开始自学python我去过慕课网和极客学院，这种学习网站比较系统化但是缺点是不便于记忆和不方便查阅，到后面我才发现文档才是最好的老师。不过还是有些个人博客，网站写的比较好的，在这里推荐两个：\n<!-- more -->\n## 廖雪峰的官方网站\n[http://www.liaoxuefeng.com/](http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000)\n\n这个主要是python3和js，git讲得也不错，通俗易懂，适合新手\n\n## 菜鸟教程\n[http://www.runoob.com/python](http://www.runoob.com/python/python-tutorial.html)\n\n菜鸟教程很多课程都不错，东西还比较多\n\n## 官方文档\n\n[https://docs.python.org/3/library/](https://docs.python.org/3/library/functions.html)\n\n另外，最好的老师，还是官方文档，这里附上python3官方文档的地址\n\n## 再来个python包下载地址\n[http://www.lfd.uci.edu/~gohlke/pythonlibs/](http://www.lfd.uci.edu/~gohlke/pythonlibs/)","slug":"推荐几个学习python还不错的网站","published":1,"updated":"2016-06-28T11:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzgzekm000yegfy0yfk3n3h","content":"<h1 id=\"推荐几个学习python还不错的网站\"><a href=\"#推荐几个学习python还不错的网站\" class=\"headerlink\" title=\"推荐几个学习python还不错的网站\"></a>推荐几个学习python还不错的网站</h1><p>一开始自学python我去过慕课网和极客学院，这种学习网站比较系统化但是缺点是不便于记忆和不方便查阅，到后面我才发现文档才是最好的老师。不过还是有些个人博客，网站写的比较好的，在这里推荐两个：<br><a id=\"more\"></a></p>\n<h2 id=\"廖雪峰的官方网站\"><a href=\"#廖雪峰的官方网站\" class=\"headerlink\" title=\"廖雪峰的官方网站\"></a>廖雪峰的官方网站</h2><p><a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000\" target=\"_blank\" rel=\"external\">http://www.liaoxuefeng.com/</a></p>\n<p>这个主要是python3和js，git讲得也不错，通俗易懂，适合新手</p>\n<h2 id=\"菜鸟教程\"><a href=\"#菜鸟教程\" class=\"headerlink\" title=\"菜鸟教程\"></a>菜鸟教程</h2><p><a href=\"http://www.runoob.com/python/python-tutorial.html\" target=\"_blank\" rel=\"external\">http://www.runoob.com/python</a></p>\n<p>菜鸟教程很多课程都不错，东西还比较多</p>\n<h2 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h2><p><a href=\"https://docs.python.org/3/library/functions.html\" target=\"_blank\" rel=\"external\">https://docs.python.org/3/library/</a></p>\n<p>另外，最好的老师，还是官方文档，这里附上python3官方文档的地址</p>\n<h2 id=\"再来个python包下载地址\"><a href=\"#再来个python包下载地址\" class=\"headerlink\" title=\"再来个python包下载地址\"></a>再来个python包下载地址</h2><p><a href=\"http://www.lfd.uci.edu/~gohlke/pythonlibs/\" target=\"_blank\" rel=\"external\">http://www.lfd.uci.edu/~gohlke/pythonlibs/</a></p>\n","excerpt":"<h1 id=\"推荐几个学习python还不错的网站\"><a href=\"#推荐几个学习python还不错的网站\" class=\"headerlink\" title=\"推荐几个学习python还不错的网站\"></a>推荐几个学习python还不错的网站</h1><p>一开始自学python我去过慕课网和极客学院，这种学习网站比较系统化但是缺点是不便于记忆和不方便查阅，到后面我才发现文档才是最好的老师。不过还是有些个人博客，网站写的比较好的，在这里推荐两个：<br>","more":"</p>\n<h2 id=\"廖雪峰的官方网站\"><a href=\"#廖雪峰的官方网站\" class=\"headerlink\" title=\"廖雪峰的官方网站\"></a>廖雪峰的官方网站</h2><p><a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000\">http://www.liaoxuefeng.com/</a></p>\n<p>这个主要是python3和js，git讲得也不错，通俗易懂，适合新手</p>\n<h2 id=\"菜鸟教程\"><a href=\"#菜鸟教程\" class=\"headerlink\" title=\"菜鸟教程\"></a>菜鸟教程</h2><p><a href=\"http://www.runoob.com/python/python-tutorial.html\">http://www.runoob.com/python</a></p>\n<p>菜鸟教程很多课程都不错，东西还比较多</p>\n<h2 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h2><p><a href=\"https://docs.python.org/3/library/functions.html\">https://docs.python.org/3/library/</a></p>\n<p>另外，最好的老师，还是官方文档，这里附上python3官方文档的地址</p>\n<h2 id=\"再来个python包下载地址\"><a href=\"#再来个python包下载地址\" class=\"headerlink\" title=\"再来个python包下载地址\"></a>再来个python包下载地址</h2><p><a href=\"http://www.lfd.uci.edu/~gohlke/pythonlibs/\">http://www.lfd.uci.edu/~gohlke/pythonlibs/</a></p>"},{"title":"一次完整的HTTP事务是怎样一个过程？","date":"2016-04-17T03:35:37.000Z","_content":"\n# 一次完整的HTTP事务是怎样一个过程\n当我们在浏览器的地址栏输入 www.linux178.com ，然后回车，回车这一瞬间到看到页面到底发生了什么呢？\n\n以下过程仅是个人理解：\n\n域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户\n\n关于HTTP协议可以参考以下：\nHTTP协议漫谈  [http://kb.cnblogs.com/page/140611/](http://kb.cnblogs.com/page/140611/)\n\nHTTP协议概览  [http://www.cnblogs.com/vamei/archive/2013/05/11/3069788.html](http://www.cnblogs.com/vamei/archive/2013/05/11/3069788.html)\n\n了解HTTP Headers的方方面面  [http://kb.cnblogs.com/page/55442/](http://kb.cnblogs.com/page/55442/)\n<!-- more -->\n\n以下就是上面过程的一一分析，我们就以Chrome浏览器为例：\n\n## 域名解析\n\n首先Chrome浏览器会解析 www.linux178.com 这个域名（准确的叫法应该是主机名）对应的IP地址。怎么解析到对应的IP地址？\n\n① Chrome浏览器 会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有www.linux178.com 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。\n\n    注：我们怎么查看Chrome自身的缓存？可以使用 chrome://net-internals/#dns 来进行查看\n\n② 如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.\n\n     注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看  \n\n③ 如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\\Windows\\System32\\drivers\\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。\n\n④ 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问www.linux178.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.linux178.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.linux178.com这个域名的IP地址，但是我知道linux178.com这个域的DNS地址，你去找它去，于是运营商的DNS又向linux178.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.linux178.com这个域名的IP地址是多少？），这个时候linux178.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.linux178.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.linux178.com  对应的IP地址，该进行一步的动作了。\n\n#### 注：一般情况下是不会进行以下步骤的\n\n如果经过以上的4个步骤，还没有解析成功，那么会进行如下步骤（以下是针对Windows操作系统）：\n\n⑤ 操作系统就会查找NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和Ip地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。\n\n⑥ 如果第⑤步也没有成功，那会查询WINS 服务器（是NETBIOS名称和IP地址对应的服务器）\n\n⑦ 如果第⑥步也没有查询成功，那么客户端就要进行广播查找\n\n⑧ 如果第⑦步也没有成功，那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样）\n\n如果第八步还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要这八步中有一步可以解析成功，那就可以成功和目标计算机进行通信。\n\n看下图抓包截图：\nLinux虚拟机测试，使用命令 wget www.linux178.com 来请求，发现直接使用chrome浏览器请求时，干扰请求比较多，所以就使用wget命令来请求，不过使用wget命令只能把index.html请求回来，并不会对index.html中包含的静态资源（js、css等文件）进行请求。\n![http://s3.51cto.com/wyfs02/M00/11/7C/wKioL1LSWzzxRParAAKbC85UJtE371.jpg](http://s3.51cto.com/wyfs02/M00/11/7C/wKioL1LSWzzxRParAAKbC85UJtE371.jpg)\n\n抓包分析：\n\n① 号包，这个是那台虚拟机在广播，要获取192.168.100.254（也就是网关）的MAC地址，因为局域网的通信靠的是MAC地址，它为什么需要跟网关进行通信是因为我们的DNS服务器IP是外围IP，要出去必须要依靠网关帮我们出去才行。\n② 号包，这个是网关收到了虚拟机的广播之后，回应给虚拟机的回应，告诉虚拟机自己的MAC地址，于是客户端找到了路由出口。\n\n③ 号包，这个包是wget命令向系统配置的DNS服务器提出域名解析请求（准确的说应该是wget发起了一个DNS解析的系统调用），请求的域名www.linux178.com,期望得到的是IP6的地址（AAAA代表的是IPv6地址）\n④ 号包，这个DNS服务器给系统的响应，很显然目前使用IPv6的还是极少数，所以得不到AAAA记录的\n⑤ 号包，这个还是请求解析IPv6地址，但是www.linux178.com.leo.com这个主机名是不存在的，所以得到结果就是no such name\n\n⑥ 号包，这个才是请求的域名对应的IPv4地址（A记录）\n⑦ 号包，DNS服务器不管是从缓存里面，还是进行迭代查询最终得到了域名的IP地址，响应给了系统，系统再给了wget命令，wget于是得到了www.linux178.com的IP地址，这里也可以看出客户端和本地的DNS服务器是递归的查询（也就是服务器必须给客户端一个结果）这就可以开始下一步了，进行TCP的三次握手。\n\n## 发起TCP的3次握手\n\n拿到域名对应的IP地址之后，User-Agent（一般是指浏览器）会以一个随机端口（1024 < 端口 < 65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求（原始的http请求经过TCP/IP4层模型的层层封包）到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序（本文就以Nginx为例），最终建立了TCP/IP的连接。\n如下图：\n![wKioL1LSW6rjI1nhAAE63Uv8ZRY731.jpg](http://s3.51cto.com/wyfs02/M01/11/7C/wKioL1LSW6rjI1nhAAE63Uv8ZRY731.jpg)\n1） Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复\n2） Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。\n3） Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。\n看抓包截图：\n![wKiom1LSW9-BWZw6AAD7FV3OfS4963.jpg](http://s3.51cto.com/wyfs02/M00/11/7D/wKiom1LSW9-BWZw6AAD7FV3OfS4963.jpg)\n\n⑨ 号包 这个就是对应上面的步骤 1）\n⑩ 号包 这个对应的上面的步骤 2）\n号包 这个对应的上面的步骤 3）\n\nTCP 为什么需要3次握手？\n\n举个例子：\n\n假设一个老外在故宫里面迷路了，看到了小明，于是就有下面的对话：\n\n\t老外： Excuse me，Can you Speak English?\n\t小明： yes 。\n\t老外： OK,I want ...\n\n在问路之前，老外先问小明是否会说英语，小明回答是的，这时老外才开始问路\n\n2个计算机通信是靠协议（目前流行的TCP/IP协议）来实现,如果2个计算机使用的协议不一样，那是不能进行通信的，所以这个3次握手就相当于试探一下对方是否遵循TCP/IP协议，协商完成后就可以进行通信了，当然这样理解不是那么准确。\n\n为什么HTTP协议要基于TCP来实现？\n\n目前在Internet中所有的传输都是通过TCP/IP进行的，HTTP协议作为TCP/IP模型中应用层的协议也不例外，TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。\n\n## 建立TCP连接后发起http请求\n\n进过TCP3次握手之后，浏览器发起了http的请求（看第包），使用的http的方法 GET 方法，请求的URL是 / ,协议是HTTP/1.0\n\n![wKioL1LSXDmgmVT_AAFUErYF2ys832.jpg](http://s3.51cto.com/wyfs02/M00/11/7C/wKioL1LSXDmgmVT_AAFUErYF2ys832.jpg)\n下面是第12号包的详细内容：\n![wKiom1LSXHiCgHkBAAKtTT2l-Ac152.jpg](http://s3.51cto.com/wyfs02/M02/11/7D/wKiom1LSXHiCgHkBAAKtTT2l-Ac152.jpg)\n\n以上的报文是HTTP请求报文。\n\n那么HTTP请求报文和响应报文会是什么格式呢？\n\n起始行：如 GET / HTTP/1.0 （请求的方法  请求的URL 请求所使用的协议）\n头部信息：User-Agent  Host等成对出现的值\n主体\n\n不管是请求报文还是响应报文都会遵循以上的格式。\n\n\n那么起始行中的请求方法有哪些种呢？\n\n```\n  GET: 完整请求一个资源 （常用）\n  HEAD: 仅请求响应首部\n  POST：提交表单  （常用）\n  PUT: (webdav) 上传文件（但是浏览器不支持该方法）\n  DELETE：(webdav) 删除\n  OPTIONS：返回请求的资源所支持的方法的方法\n  TRACE: 追求一个资源请求中间所经过的代理（该方法不能由浏览器发出）\n```\n那什么是URL、URI、URN？\n\n```\nURI  Uniform Resource Identifier 统一资源标识符\nURL  Uniform Resource Locator 统一资源定位符\n    格式如下：  scheme://[username:password@]HOST:port/path/to/source\n                http://www.magedu.com/downloads/nginx-1.5.tar.gz\n\nURN  Uniform Resource Name 统一资源名称\n\nURL和URN 都属于 URI\n```\n为了方便就把URL和URI暂时都通指一个东西\n\n\n## 请求的协议有哪些种？\n\n有以下几种：\n\nhttp/0.9: stateless\nhttp/1.0: MIME, keep-alive (保持连接), 缓存\nhttp/1.1: 更多的请求方法，更精细的缓存控制，持久连接(persistent connection) 比较常用\n\n下面是Chrome发起的http请求报文头部信息\n\n![wKioL1LSXMqCjyIQAAESKm-mkV8876.jpg](http://s3.51cto.com/wyfs02/M01/11/7C/wKioL1LSXMqCjyIQAAESKm-mkV8876.jpg)\n\n其中\n\n```\nAccept  就是告诉服务器端，我接受那些MIME类型\nAccept-Encoding  这个看起来是接受那些压缩方式的文件\nAccept-Lanague   告诉服务器能够发送哪些语言\nConnection       告诉服务器支持keep-alive特性\nCookie           每次请求时都会携带上Cookie以方便服务器端识别是否是同一个客户端\nHost             用来标识请求服务器上的那个虚拟主机，比如Nginx里面可以定义很多\n个虚拟主机\n                那这里就是用来标识要访问那个虚拟主机。\nUser-Agent       用户代理，一般情况是浏览器，也有其他类型，如：wget curl 搜索引擎的蜘蛛等    \n```\n\n条件请求首部：\n\n```\nIf-Modified-Since 是浏览器向服务器端询问某个资源文件如果自从什么时间修改过，那么重新发给我，这样就保证服务器端资源文件更新时，浏览器再次去请求，而不是使用缓存中的文件\n```\n安全请求首部：\n\n```\nAuthorization: 客户端提供给服务器的认证信息；\n```\n## 什么是MIME？\n\nMIME（Multipurpose Internet Mail Extesions 多用途互联网邮件扩展）是一个互联网标准，它扩展了电子邮件标准，使其能够支持非ASCII字符、二进制格式附件等多种格式的邮件消息，这个标准被定义在RFC 2045、RFC 2046、RFC 2047、RFC 2048、RFC 2049等RFC中。 由RFC 822转变而来的RFC 2822，规定电子邮件标准并不允许在邮件消息中使用7位ASCII字符集以外的字符。正因如此，一些非英语字符消息和二进制文件，图像，声音等非文字消息都不能在电子邮件中传输。MIME规定了用于表示各种各样的数据类型的符号化方法。 此外，在万维网中使用的HTTP协议中也使用了MIME的框架，标准被扩展为互联网媒体类型。\n\nMIME 遵循以下格式：major/minor 主类型/次类型 例如：\n\n\n```\nimage/jpg\nimage/gif\ntext/html\nvideo/quicktime\nappliation/x-httpd-php\n```\n4.服务器端响应http请求，浏览器得到html代码\n\n看下图 第12号包是http请求包，第32包是http响应包\n\n服务器端WEB程序接收到http请求以后，就开始处理该请求，处理之后就返回给浏览器html文件。\n\n![wKiom1LSXVeQETJrAAaV9VlbbBo896.jpg](http://s3.51cto.com/wyfs02/M00/11/7D/wKiom1LSXVeQETJrAAaV9VlbbBo896.jpg)\n\n第32号包 是服务器返回给客户端http响应包（200 ok 响应的MIME类型是text/html），代表这一次客户端发起的http请求已成功响应。200 代表是的 响应成功的状态码，还有其他的状态码如下：\n\n```\n1xx: 信息性状态码\n    100, 101\n2xx: 成功状态码\n    200：OK\n3xx: 重定向状态码\n    301: 永久重定向, Location响应首部的值仍为当前URL，因此为隐藏重定向;\n    302: 临时重定向，显式重定向, Location响应首部的值为新的URL\n    304：Not Modified  未修改，比如本地缓存的资源文件和服务器上比较时，发现并没有修改，服务器返回一个304状态码，\n                        告诉浏览器，你不用请求该资源，直接使用本地的资源即可。\n4xx: 客户端错误状态码\n    404: Not Found  请求的URL资源并不存在\n5xx: 服务器端错误状态码\n    500: Internal Server Error  服务器内部错误\n    502: Bad Gateway  前面代理服务器联系不到后端的服务器时出现\n    504：Gateway Timeout  这个是代理能联系到后端的服务器，但是后端的服务器在规定的时间内没有给代理服务器响应\n```\n用Chrome浏览器看到的响应头信息：\n\n![wKioL1LSXgCDWDvyAADfe7wzmKk795.jpg](http://s3.51cto.com/wyfs02/M02/11/7C/wKioL1LSXgCDWDvyAADfe7wzmKk795.jpg)\n\n```\nConnection            使用keep-alive特性\nContent-Encoding      使用gzip方式对资源压缩\nContent-type          MIME类型为html类型，字符集是 UTF-8\nDate                  响应的日期\nServer                使用的WEB服务器\nTransfer-Encoding:chunked   分块传输编码 是http中的一种数据传输机制，允许HTTP由网页服务器发送给客户端应用（通常是网页浏览器）的数据可以分成多个部分，分块传输编码只在HTTP协议1.1版本（HTTP/1.1）中提供\nVary  这个可以参考（http://blog.csdn.net/tenfyguo/article/details/5939000）\nX-Pingback  参考（http://blog.sina.com.cn/s/blog_bb80041c0101fmfz.html）\n```\n## 那到底服务器端接收到http请求后是怎么样生成html文件？\n\n假设服务器端使用nginx+php(fastcgi)架构提供服务\n\n① nginx读取配置文件\n\n我们在浏览器的地址栏里面输入的是 http://www.linux178.com （http://可以不用输入，浏览器会自动帮我们添加），其实完整的应该是http://www.linux178.com./ 后面还有个点（这个点代表就是根域，一般情况下我们不用输入，也不显示）,后面的/也是不用添加，浏览器会自动帮我们添加（且看第3部那个图里面的URL），那么实际请求的URL是http://www.linux178.com/，那么好了Nginx在收到 浏览器 GET / 请求时，会读取http请求里面的头部信息，根据Host来匹配 自己的所有的虚拟主机的配置文件的server_name,看看有没有匹配的，有匹配那么就读取该虚拟主机的配置，发现如下配置：\n\n\n```\nroot /web/echo\n```\n通过这个就知道所有网页文件的就在这个目录下 这个目录就是/ 当我们http://www.linux178.com/时就是访问这个目录下面的文件，例如访问http://www.linux178.com/index.html,那么代表/web/echo下面有个文件叫index.html\n\n\n```\nindex index.html index.htm index.php\n```\n通过这个就能得知网站的首页文件是那个文件，也就是我们在入http://www.linux178.com/ ，nginx就会自动帮我们把index.html（假设首页是index.php 当然是会尝试的去找到该文件，如果没有找到该文件就依次往下找，如果这3个文件都没有找到，那么就抛出一个404错误）加到后面，那么添加之后的URL是/index.php,然后根据后面的配置进行处理\n\n\n``` \nlocation ~ .*\\.php(\\/.*)*$ {\n   root /web/echo;\n   fastcgi_pass   127.0.0.1:9000;\n   fastcgi_index  index.php;\n   astcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\n   include        fastcgi_params;\n}\n```\n这一段配置指明凡是请求的URL中匹配（这里是启用了正则表达式进行匹配） *.php后缀的（后面跟的参数）都交给后端的fastcgi进程进行处理。\n\n② 把php文件交给fastcgi进程去处理\n\n于是nginx把/index.php这个URL交给了后端的fastcgi进程处理，等待fastcgi处理完成后（结合数据库查询出数据，填充模板生成html文件）返回给nginx一个index.html文档，Nginx再把这个index.html返回给浏览器，于是乎浏览器就拿到了首页的html代码，同时nginx写一条访问日志到日志文件中去。\n\n### 注1：nginx是怎么找index.php文件的？\n\n当nginx发现需要/web/echo/index.php文件时，就会向内核发起IO系统调用(因为要跟硬件打交道，这里的硬件是指硬盘，通常需要靠内核来操作，而内核提供的这些功能是通过系统调用来实现的)，告诉内核，我需要这个文件,内核从/开始找到web目录，再在web目录下找到echo目录，最后在echo目录下找到index.php文件，于是把这个index.php从硬盘上读取到内核自身的内存空间，然后再把这个文件复制到nginx进程所在的内存空间，于是乎nginx就得到了自己想要的文件了。\n\n### 注2：寻找文件在文件系统层面是怎么操作的？\n\n比如nginx需要得到/web/echo/index.php这个文件\n\n每个分区（像ext3 ext3等文件系统，block块是文件存储的最小单元 默认是4096字节）都是包含元数据区和数据区，每一个文件在元数据区都有元数据条目（一般是128字节大小），每一个条目都有一个编号，我们称之为inode（index node 索引节点），这个inode里面包含 文件类型、权限、连接次数、属主和数组的ID、时间戳、这个文件占据了那些磁盘块也就是块的编号（block，每个文件可以占用多个block,并且block不一定是连续的，每个block是有编号的），如下图所示：\n\n![wKiom1LSXwWRzx75AACjRCdIYcI778.jpg](http://s3.51cto.com/wyfs02/M01/11/7D/wKiom1LSXwWRzx75AACjRCdIYcI778.jpg)\n\n还有一个要点：目录其实也普通是文件，也需要占用磁盘块，目录不是一个容器。你看默认创建的目录就是4096字节，也就说只需要占用一个磁盘块，但这是不确定的。所以要找到目录也是需要到元数据区里面找到对应的条目，只有找到对应的inode就可找到目录所占用的磁盘块。\n\n那到底目录里面存放着什么，难道不是文件或者其他目录吗？\n\n其实目录存着这么一张表（姑且这么理解），里面放着 目录或者文件的名称和对应的inode号（暂时称之为映射表）,如下图：\n![wKiom1LSX3KATYWYAAAx2GkMEO4103.jpg](http://s3.51cto.com/wyfs02/M02/11/7D/wKiom1LSX3KATYWYAAAx2GkMEO4103.jpg)\n\n假设\n```\n/           在数据区占据 1、2号block ，/其实也是一个目录 里面有3个目录  web 111\nweb         占据 5号block  是目录 里面有2个目录 echo data\necho        占据 11号 block  是目录  里面有1个文件 index.php\nindex.php   占据 15 16号 block  是文件\n```\n其在文件系统中分布如下图所示\n\n![wKioL1LSX6OizObEAAHJJkuxCa0943.jpg](http://s3.51cto.com/wyfs02/M01/11/7C/wKioL1LSX6OizObEAAHJJkuxCa0943.jpg)\n\n那么内核究竟是怎么找到index.php这个文件的呢？\n\n内核拿到nginx的IO系统调用要获取/web/echo/index.php这个文件请求之后\n\n① 内核读取元数据区 / 的inode，从inode里面读取/所对应的数据块的编号，然后在数据区找到其对应的块（1 2号块），读取1号块上的映射表找到web这个名称在元数据区对应的inode号\n\n② 内核读取web对应的inode（3号），从中得知web在数据区对应的块是5号块，于是到数据区找到5号块，从中读取映射表，知道echo对应的inode是5号，于是到元数据区找到5号inode\n\n③ 内核读取5号inode，得到echo在数据区对应的是11号块，于是到数据区读取11号块得到映射表，得到index.php对应的inode是9号\n\n④ 内核到元数据区读取9号inode，得到index.php对应的是15和16号数据块，于是就到数据区域找到15 16号块，读取其中的内容，得到index.php的完整内容\n\n##  浏览器解析html代码，并请求html代码中的资源\n\n浏览器拿到index.html文件后，就开始解析其中的html代码，遇到js/css/image等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上keep-alive特性了，建立一次HTTP连接，可以请求多个资源，下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源，所以从下图看出，这里显示的顺序并不一定是代码里面的顺序。\n\n浏览器在请求静态资源时（在未过期的情况下），向服务器端发起一个http请求（询问自从上一次修改时间到现在有没有对资源进行修改），如果服务器端返回304状态码（告诉浏览器服务器端没有修改），那么浏览器会直接读取本地的该资源的缓存文件。\n![wKiom1LSX_PT06f3AAF_5iS18UA331.jpg](http://s3.51cto.com/wyfs02/M00/11/7D/wKiom1LSX_PT06f3AAF_5iS18UA331.jpg)\n\n详细的浏览器工作原理请看：[http://kb.cnblogs.com/page/129756/](http://kb.cnblogs.com/page/129756/)\n\n\n6.浏览器对页面进行渲染呈现给用户\n\n最后，浏览器利用自己内部的工作机制，把请求到的静态资源和html代码进行渲染，渲染之后呈现给用户。\n\n\n自此一次完整的HTTP事务宣告完成.\n\n\n本文出自 “雷纳科斯的博客” 博客，请务必保留此出处[http://linux5588.blog.51cto.com/65280/1351007](http://linux5588.blog.51cto.com/65280/1351007)","source":"_posts/一次完整的HTTP事务是怎样一个过程？.md","raw":"---\ntitle: 一次完整的HTTP事务是怎样一个过程？\ndate: 2016-04-17 11:35:37\ncategories: web\ntags: [HTTP]\n\n---\n\n# 一次完整的HTTP事务是怎样一个过程\n当我们在浏览器的地址栏输入 www.linux178.com ，然后回车，回车这一瞬间到看到页面到底发生了什么呢？\n\n以下过程仅是个人理解：\n\n域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户\n\n关于HTTP协议可以参考以下：\nHTTP协议漫谈  [http://kb.cnblogs.com/page/140611/](http://kb.cnblogs.com/page/140611/)\n\nHTTP协议概览  [http://www.cnblogs.com/vamei/archive/2013/05/11/3069788.html](http://www.cnblogs.com/vamei/archive/2013/05/11/3069788.html)\n\n了解HTTP Headers的方方面面  [http://kb.cnblogs.com/page/55442/](http://kb.cnblogs.com/page/55442/)\n<!-- more -->\n\n以下就是上面过程的一一分析，我们就以Chrome浏览器为例：\n\n## 域名解析\n\n首先Chrome浏览器会解析 www.linux178.com 这个域名（准确的叫法应该是主机名）对应的IP地址。怎么解析到对应的IP地址？\n\n① Chrome浏览器 会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有www.linux178.com 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。\n\n    注：我们怎么查看Chrome自身的缓存？可以使用 chrome://net-internals/#dns 来进行查看\n\n② 如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.\n\n     注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看  \n\n③ 如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\\Windows\\System32\\drivers\\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。\n\n④ 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问www.linux178.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.linux178.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.linux178.com这个域名的IP地址，但是我知道linux178.com这个域的DNS地址，你去找它去，于是运营商的DNS又向linux178.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.linux178.com这个域名的IP地址是多少？），这个时候linux178.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.linux178.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.linux178.com  对应的IP地址，该进行一步的动作了。\n\n#### 注：一般情况下是不会进行以下步骤的\n\n如果经过以上的4个步骤，还没有解析成功，那么会进行如下步骤（以下是针对Windows操作系统）：\n\n⑤ 操作系统就会查找NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和Ip地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。\n\n⑥ 如果第⑤步也没有成功，那会查询WINS 服务器（是NETBIOS名称和IP地址对应的服务器）\n\n⑦ 如果第⑥步也没有查询成功，那么客户端就要进行广播查找\n\n⑧ 如果第⑦步也没有成功，那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样）\n\n如果第八步还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要这八步中有一步可以解析成功，那就可以成功和目标计算机进行通信。\n\n看下图抓包截图：\nLinux虚拟机测试，使用命令 wget www.linux178.com 来请求，发现直接使用chrome浏览器请求时，干扰请求比较多，所以就使用wget命令来请求，不过使用wget命令只能把index.html请求回来，并不会对index.html中包含的静态资源（js、css等文件）进行请求。\n![http://s3.51cto.com/wyfs02/M00/11/7C/wKioL1LSWzzxRParAAKbC85UJtE371.jpg](http://s3.51cto.com/wyfs02/M00/11/7C/wKioL1LSWzzxRParAAKbC85UJtE371.jpg)\n\n抓包分析：\n\n① 号包，这个是那台虚拟机在广播，要获取192.168.100.254（也就是网关）的MAC地址，因为局域网的通信靠的是MAC地址，它为什么需要跟网关进行通信是因为我们的DNS服务器IP是外围IP，要出去必须要依靠网关帮我们出去才行。\n② 号包，这个是网关收到了虚拟机的广播之后，回应给虚拟机的回应，告诉虚拟机自己的MAC地址，于是客户端找到了路由出口。\n\n③ 号包，这个包是wget命令向系统配置的DNS服务器提出域名解析请求（准确的说应该是wget发起了一个DNS解析的系统调用），请求的域名www.linux178.com,期望得到的是IP6的地址（AAAA代表的是IPv6地址）\n④ 号包，这个DNS服务器给系统的响应，很显然目前使用IPv6的还是极少数，所以得不到AAAA记录的\n⑤ 号包，这个还是请求解析IPv6地址，但是www.linux178.com.leo.com这个主机名是不存在的，所以得到结果就是no such name\n\n⑥ 号包，这个才是请求的域名对应的IPv4地址（A记录）\n⑦ 号包，DNS服务器不管是从缓存里面，还是进行迭代查询最终得到了域名的IP地址，响应给了系统，系统再给了wget命令，wget于是得到了www.linux178.com的IP地址，这里也可以看出客户端和本地的DNS服务器是递归的查询（也就是服务器必须给客户端一个结果）这就可以开始下一步了，进行TCP的三次握手。\n\n## 发起TCP的3次握手\n\n拿到域名对应的IP地址之后，User-Agent（一般是指浏览器）会以一个随机端口（1024 < 端口 < 65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求（原始的http请求经过TCP/IP4层模型的层层封包）到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序（本文就以Nginx为例），最终建立了TCP/IP的连接。\n如下图：\n![wKioL1LSW6rjI1nhAAE63Uv8ZRY731.jpg](http://s3.51cto.com/wyfs02/M01/11/7C/wKioL1LSW6rjI1nhAAE63Uv8ZRY731.jpg)\n1） Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复\n2） Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。\n3） Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。\n看抓包截图：\n![wKiom1LSW9-BWZw6AAD7FV3OfS4963.jpg](http://s3.51cto.com/wyfs02/M00/11/7D/wKiom1LSW9-BWZw6AAD7FV3OfS4963.jpg)\n\n⑨ 号包 这个就是对应上面的步骤 1）\n⑩ 号包 这个对应的上面的步骤 2）\n号包 这个对应的上面的步骤 3）\n\nTCP 为什么需要3次握手？\n\n举个例子：\n\n假设一个老外在故宫里面迷路了，看到了小明，于是就有下面的对话：\n\n\t老外： Excuse me，Can you Speak English?\n\t小明： yes 。\n\t老外： OK,I want ...\n\n在问路之前，老外先问小明是否会说英语，小明回答是的，这时老外才开始问路\n\n2个计算机通信是靠协议（目前流行的TCP/IP协议）来实现,如果2个计算机使用的协议不一样，那是不能进行通信的，所以这个3次握手就相当于试探一下对方是否遵循TCP/IP协议，协商完成后就可以进行通信了，当然这样理解不是那么准确。\n\n为什么HTTP协议要基于TCP来实现？\n\n目前在Internet中所有的传输都是通过TCP/IP进行的，HTTP协议作为TCP/IP模型中应用层的协议也不例外，TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。\n\n## 建立TCP连接后发起http请求\n\n进过TCP3次握手之后，浏览器发起了http的请求（看第包），使用的http的方法 GET 方法，请求的URL是 / ,协议是HTTP/1.0\n\n![wKioL1LSXDmgmVT_AAFUErYF2ys832.jpg](http://s3.51cto.com/wyfs02/M00/11/7C/wKioL1LSXDmgmVT_AAFUErYF2ys832.jpg)\n下面是第12号包的详细内容：\n![wKiom1LSXHiCgHkBAAKtTT2l-Ac152.jpg](http://s3.51cto.com/wyfs02/M02/11/7D/wKiom1LSXHiCgHkBAAKtTT2l-Ac152.jpg)\n\n以上的报文是HTTP请求报文。\n\n那么HTTP请求报文和响应报文会是什么格式呢？\n\n起始行：如 GET / HTTP/1.0 （请求的方法  请求的URL 请求所使用的协议）\n头部信息：User-Agent  Host等成对出现的值\n主体\n\n不管是请求报文还是响应报文都会遵循以上的格式。\n\n\n那么起始行中的请求方法有哪些种呢？\n\n```\n  GET: 完整请求一个资源 （常用）\n  HEAD: 仅请求响应首部\n  POST：提交表单  （常用）\n  PUT: (webdav) 上传文件（但是浏览器不支持该方法）\n  DELETE：(webdav) 删除\n  OPTIONS：返回请求的资源所支持的方法的方法\n  TRACE: 追求一个资源请求中间所经过的代理（该方法不能由浏览器发出）\n```\n那什么是URL、URI、URN？\n\n```\nURI  Uniform Resource Identifier 统一资源标识符\nURL  Uniform Resource Locator 统一资源定位符\n    格式如下：  scheme://[username:password@]HOST:port/path/to/source\n                http://www.magedu.com/downloads/nginx-1.5.tar.gz\n\nURN  Uniform Resource Name 统一资源名称\n\nURL和URN 都属于 URI\n```\n为了方便就把URL和URI暂时都通指一个东西\n\n\n## 请求的协议有哪些种？\n\n有以下几种：\n\nhttp/0.9: stateless\nhttp/1.0: MIME, keep-alive (保持连接), 缓存\nhttp/1.1: 更多的请求方法，更精细的缓存控制，持久连接(persistent connection) 比较常用\n\n下面是Chrome发起的http请求报文头部信息\n\n![wKioL1LSXMqCjyIQAAESKm-mkV8876.jpg](http://s3.51cto.com/wyfs02/M01/11/7C/wKioL1LSXMqCjyIQAAESKm-mkV8876.jpg)\n\n其中\n\n```\nAccept  就是告诉服务器端，我接受那些MIME类型\nAccept-Encoding  这个看起来是接受那些压缩方式的文件\nAccept-Lanague   告诉服务器能够发送哪些语言\nConnection       告诉服务器支持keep-alive特性\nCookie           每次请求时都会携带上Cookie以方便服务器端识别是否是同一个客户端\nHost             用来标识请求服务器上的那个虚拟主机，比如Nginx里面可以定义很多\n个虚拟主机\n                那这里就是用来标识要访问那个虚拟主机。\nUser-Agent       用户代理，一般情况是浏览器，也有其他类型，如：wget curl 搜索引擎的蜘蛛等    \n```\n\n条件请求首部：\n\n```\nIf-Modified-Since 是浏览器向服务器端询问某个资源文件如果自从什么时间修改过，那么重新发给我，这样就保证服务器端资源文件更新时，浏览器再次去请求，而不是使用缓存中的文件\n```\n安全请求首部：\n\n```\nAuthorization: 客户端提供给服务器的认证信息；\n```\n## 什么是MIME？\n\nMIME（Multipurpose Internet Mail Extesions 多用途互联网邮件扩展）是一个互联网标准，它扩展了电子邮件标准，使其能够支持非ASCII字符、二进制格式附件等多种格式的邮件消息，这个标准被定义在RFC 2045、RFC 2046、RFC 2047、RFC 2048、RFC 2049等RFC中。 由RFC 822转变而来的RFC 2822，规定电子邮件标准并不允许在邮件消息中使用7位ASCII字符集以外的字符。正因如此，一些非英语字符消息和二进制文件，图像，声音等非文字消息都不能在电子邮件中传输。MIME规定了用于表示各种各样的数据类型的符号化方法。 此外，在万维网中使用的HTTP协议中也使用了MIME的框架，标准被扩展为互联网媒体类型。\n\nMIME 遵循以下格式：major/minor 主类型/次类型 例如：\n\n\n```\nimage/jpg\nimage/gif\ntext/html\nvideo/quicktime\nappliation/x-httpd-php\n```\n4.服务器端响应http请求，浏览器得到html代码\n\n看下图 第12号包是http请求包，第32包是http响应包\n\n服务器端WEB程序接收到http请求以后，就开始处理该请求，处理之后就返回给浏览器html文件。\n\n![wKiom1LSXVeQETJrAAaV9VlbbBo896.jpg](http://s3.51cto.com/wyfs02/M00/11/7D/wKiom1LSXVeQETJrAAaV9VlbbBo896.jpg)\n\n第32号包 是服务器返回给客户端http响应包（200 ok 响应的MIME类型是text/html），代表这一次客户端发起的http请求已成功响应。200 代表是的 响应成功的状态码，还有其他的状态码如下：\n\n```\n1xx: 信息性状态码\n    100, 101\n2xx: 成功状态码\n    200：OK\n3xx: 重定向状态码\n    301: 永久重定向, Location响应首部的值仍为当前URL，因此为隐藏重定向;\n    302: 临时重定向，显式重定向, Location响应首部的值为新的URL\n    304：Not Modified  未修改，比如本地缓存的资源文件和服务器上比较时，发现并没有修改，服务器返回一个304状态码，\n                        告诉浏览器，你不用请求该资源，直接使用本地的资源即可。\n4xx: 客户端错误状态码\n    404: Not Found  请求的URL资源并不存在\n5xx: 服务器端错误状态码\n    500: Internal Server Error  服务器内部错误\n    502: Bad Gateway  前面代理服务器联系不到后端的服务器时出现\n    504：Gateway Timeout  这个是代理能联系到后端的服务器，但是后端的服务器在规定的时间内没有给代理服务器响应\n```\n用Chrome浏览器看到的响应头信息：\n\n![wKioL1LSXgCDWDvyAADfe7wzmKk795.jpg](http://s3.51cto.com/wyfs02/M02/11/7C/wKioL1LSXgCDWDvyAADfe7wzmKk795.jpg)\n\n```\nConnection            使用keep-alive特性\nContent-Encoding      使用gzip方式对资源压缩\nContent-type          MIME类型为html类型，字符集是 UTF-8\nDate                  响应的日期\nServer                使用的WEB服务器\nTransfer-Encoding:chunked   分块传输编码 是http中的一种数据传输机制，允许HTTP由网页服务器发送给客户端应用（通常是网页浏览器）的数据可以分成多个部分，分块传输编码只在HTTP协议1.1版本（HTTP/1.1）中提供\nVary  这个可以参考（http://blog.csdn.net/tenfyguo/article/details/5939000）\nX-Pingback  参考（http://blog.sina.com.cn/s/blog_bb80041c0101fmfz.html）\n```\n## 那到底服务器端接收到http请求后是怎么样生成html文件？\n\n假设服务器端使用nginx+php(fastcgi)架构提供服务\n\n① nginx读取配置文件\n\n我们在浏览器的地址栏里面输入的是 http://www.linux178.com （http://可以不用输入，浏览器会自动帮我们添加），其实完整的应该是http://www.linux178.com./ 后面还有个点（这个点代表就是根域，一般情况下我们不用输入，也不显示）,后面的/也是不用添加，浏览器会自动帮我们添加（且看第3部那个图里面的URL），那么实际请求的URL是http://www.linux178.com/，那么好了Nginx在收到 浏览器 GET / 请求时，会读取http请求里面的头部信息，根据Host来匹配 自己的所有的虚拟主机的配置文件的server_name,看看有没有匹配的，有匹配那么就读取该虚拟主机的配置，发现如下配置：\n\n\n```\nroot /web/echo\n```\n通过这个就知道所有网页文件的就在这个目录下 这个目录就是/ 当我们http://www.linux178.com/时就是访问这个目录下面的文件，例如访问http://www.linux178.com/index.html,那么代表/web/echo下面有个文件叫index.html\n\n\n```\nindex index.html index.htm index.php\n```\n通过这个就能得知网站的首页文件是那个文件，也就是我们在入http://www.linux178.com/ ，nginx就会自动帮我们把index.html（假设首页是index.php 当然是会尝试的去找到该文件，如果没有找到该文件就依次往下找，如果这3个文件都没有找到，那么就抛出一个404错误）加到后面，那么添加之后的URL是/index.php,然后根据后面的配置进行处理\n\n\n``` \nlocation ~ .*\\.php(\\/.*)*$ {\n   root /web/echo;\n   fastcgi_pass   127.0.0.1:9000;\n   fastcgi_index  index.php;\n   astcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\n   include        fastcgi_params;\n}\n```\n这一段配置指明凡是请求的URL中匹配（这里是启用了正则表达式进行匹配） *.php后缀的（后面跟的参数）都交给后端的fastcgi进程进行处理。\n\n② 把php文件交给fastcgi进程去处理\n\n于是nginx把/index.php这个URL交给了后端的fastcgi进程处理，等待fastcgi处理完成后（结合数据库查询出数据，填充模板生成html文件）返回给nginx一个index.html文档，Nginx再把这个index.html返回给浏览器，于是乎浏览器就拿到了首页的html代码，同时nginx写一条访问日志到日志文件中去。\n\n### 注1：nginx是怎么找index.php文件的？\n\n当nginx发现需要/web/echo/index.php文件时，就会向内核发起IO系统调用(因为要跟硬件打交道，这里的硬件是指硬盘，通常需要靠内核来操作，而内核提供的这些功能是通过系统调用来实现的)，告诉内核，我需要这个文件,内核从/开始找到web目录，再在web目录下找到echo目录，最后在echo目录下找到index.php文件，于是把这个index.php从硬盘上读取到内核自身的内存空间，然后再把这个文件复制到nginx进程所在的内存空间，于是乎nginx就得到了自己想要的文件了。\n\n### 注2：寻找文件在文件系统层面是怎么操作的？\n\n比如nginx需要得到/web/echo/index.php这个文件\n\n每个分区（像ext3 ext3等文件系统，block块是文件存储的最小单元 默认是4096字节）都是包含元数据区和数据区，每一个文件在元数据区都有元数据条目（一般是128字节大小），每一个条目都有一个编号，我们称之为inode（index node 索引节点），这个inode里面包含 文件类型、权限、连接次数、属主和数组的ID、时间戳、这个文件占据了那些磁盘块也就是块的编号（block，每个文件可以占用多个block,并且block不一定是连续的，每个block是有编号的），如下图所示：\n\n![wKiom1LSXwWRzx75AACjRCdIYcI778.jpg](http://s3.51cto.com/wyfs02/M01/11/7D/wKiom1LSXwWRzx75AACjRCdIYcI778.jpg)\n\n还有一个要点：目录其实也普通是文件，也需要占用磁盘块，目录不是一个容器。你看默认创建的目录就是4096字节，也就说只需要占用一个磁盘块，但这是不确定的。所以要找到目录也是需要到元数据区里面找到对应的条目，只有找到对应的inode就可找到目录所占用的磁盘块。\n\n那到底目录里面存放着什么，难道不是文件或者其他目录吗？\n\n其实目录存着这么一张表（姑且这么理解），里面放着 目录或者文件的名称和对应的inode号（暂时称之为映射表）,如下图：\n![wKiom1LSX3KATYWYAAAx2GkMEO4103.jpg](http://s3.51cto.com/wyfs02/M02/11/7D/wKiom1LSX3KATYWYAAAx2GkMEO4103.jpg)\n\n假设\n```\n/           在数据区占据 1、2号block ，/其实也是一个目录 里面有3个目录  web 111\nweb         占据 5号block  是目录 里面有2个目录 echo data\necho        占据 11号 block  是目录  里面有1个文件 index.php\nindex.php   占据 15 16号 block  是文件\n```\n其在文件系统中分布如下图所示\n\n![wKioL1LSX6OizObEAAHJJkuxCa0943.jpg](http://s3.51cto.com/wyfs02/M01/11/7C/wKioL1LSX6OizObEAAHJJkuxCa0943.jpg)\n\n那么内核究竟是怎么找到index.php这个文件的呢？\n\n内核拿到nginx的IO系统调用要获取/web/echo/index.php这个文件请求之后\n\n① 内核读取元数据区 / 的inode，从inode里面读取/所对应的数据块的编号，然后在数据区找到其对应的块（1 2号块），读取1号块上的映射表找到web这个名称在元数据区对应的inode号\n\n② 内核读取web对应的inode（3号），从中得知web在数据区对应的块是5号块，于是到数据区找到5号块，从中读取映射表，知道echo对应的inode是5号，于是到元数据区找到5号inode\n\n③ 内核读取5号inode，得到echo在数据区对应的是11号块，于是到数据区读取11号块得到映射表，得到index.php对应的inode是9号\n\n④ 内核到元数据区读取9号inode，得到index.php对应的是15和16号数据块，于是就到数据区域找到15 16号块，读取其中的内容，得到index.php的完整内容\n\n##  浏览器解析html代码，并请求html代码中的资源\n\n浏览器拿到index.html文件后，就开始解析其中的html代码，遇到js/css/image等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上keep-alive特性了，建立一次HTTP连接，可以请求多个资源，下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源，所以从下图看出，这里显示的顺序并不一定是代码里面的顺序。\n\n浏览器在请求静态资源时（在未过期的情况下），向服务器端发起一个http请求（询问自从上一次修改时间到现在有没有对资源进行修改），如果服务器端返回304状态码（告诉浏览器服务器端没有修改），那么浏览器会直接读取本地的该资源的缓存文件。\n![wKiom1LSX_PT06f3AAF_5iS18UA331.jpg](http://s3.51cto.com/wyfs02/M00/11/7D/wKiom1LSX_PT06f3AAF_5iS18UA331.jpg)\n\n详细的浏览器工作原理请看：[http://kb.cnblogs.com/page/129756/](http://kb.cnblogs.com/page/129756/)\n\n\n6.浏览器对页面进行渲染呈现给用户\n\n最后，浏览器利用自己内部的工作机制，把请求到的静态资源和html代码进行渲染，渲染之后呈现给用户。\n\n\n自此一次完整的HTTP事务宣告完成.\n\n\n本文出自 “雷纳科斯的博客” 博客，请务必保留此出处[http://linux5588.blog.51cto.com/65280/1351007](http://linux5588.blog.51cto.com/65280/1351007)","slug":"一次完整的HTTP事务是怎样一个过程？","published":1,"updated":"2016-06-28T11:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzgzekn0012egfy4peosndw","content":"<h1 id=\"一次完整的HTTP事务是怎样一个过程\"><a href=\"#一次完整的HTTP事务是怎样一个过程\" class=\"headerlink\" title=\"一次完整的HTTP事务是怎样一个过程\"></a>一次完整的HTTP事务是怎样一个过程</h1><p>当我们在浏览器的地址栏输入 www.linux178.com ，然后回车，回车这一瞬间到看到页面到底发生了什么呢？</p>\n<p>以下过程仅是个人理解：</p>\n<p>域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户</p>\n<p>关于HTTP协议可以参考以下：<br>HTTP协议漫谈  <a href=\"http://kb.cnblogs.com/page/140611/\" target=\"_blank\" rel=\"external\">http://kb.cnblogs.com/page/140611/</a></p>\n<p>HTTP协议概览  <a href=\"http://www.cnblogs.com/vamei/archive/2013/05/11/3069788.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/vamei/archive/2013/05/11/3069788.html</a></p>\n<p>了解HTTP Headers的方方面面  <a href=\"http://kb.cnblogs.com/page/55442/\" target=\"_blank\" rel=\"external\">http://kb.cnblogs.com/page/55442/</a><br><a id=\"more\"></a></p>\n<p>以下就是上面过程的一一分析，我们就以Chrome浏览器为例：</p>\n<h2 id=\"域名解析\"><a href=\"#域名解析\" class=\"headerlink\" title=\"域名解析\"></a>域名解析</h2><p>首先Chrome浏览器会解析 www.linux178.com 这个域名（准确的叫法应该是主机名）对应的IP地址。怎么解析到对应的IP地址？</p>\n<p>① Chrome浏览器 会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有www.linux178.com 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。</p>\n<pre><code>注：我们怎么查看Chrome自身的缓存？可以使用 chrome://net-internals/#dns 来进行查看\n</code></pre><p>② 如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.</p>\n<pre><code>注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看  \n</code></pre><p>③ 如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\\Windows\\System32\\drivers\\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。</p>\n<p>④ 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问www.linux178.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.linux178.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.linux178.com这个域名的IP地址，但是我知道linux178.com这个域的DNS地址，你去找它去，于是运营商的DNS又向linux178.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.linux178.com这个域名的IP地址是多少？），这个时候linux178.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.linux178.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.linux178.com  对应的IP地址，该进行一步的动作了。</p>\n<h4 id=\"注：一般情况下是不会进行以下步骤的\"><a href=\"#注：一般情况下是不会进行以下步骤的\" class=\"headerlink\" title=\"注：一般情况下是不会进行以下步骤的\"></a>注：一般情况下是不会进行以下步骤的</h4><p>如果经过以上的4个步骤，还没有解析成功，那么会进行如下步骤（以下是针对Windows操作系统）：</p>\n<p>⑤ 操作系统就会查找NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和Ip地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。</p>\n<p>⑥ 如果第⑤步也没有成功，那会查询WINS 服务器（是NETBIOS名称和IP地址对应的服务器）</p>\n<p>⑦ 如果第⑥步也没有查询成功，那么客户端就要进行广播查找</p>\n<p>⑧ 如果第⑦步也没有成功，那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样）</p>\n<p>如果第八步还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要这八步中有一步可以解析成功，那就可以成功和目标计算机进行通信。</p>\n<p>看下图抓包截图：<br>Linux虚拟机测试，使用命令 wget www.linux178.com 来请求，发现直接使用chrome浏览器请求时，干扰请求比较多，所以就使用wget命令来请求，不过使用wget命令只能把index.html请求回来，并不会对index.html中包含的静态资源（js、css等文件）进行请求。<br><img src=\"http://s3.51cto.com/wyfs02/M00/11/7C/wKioL1LSWzzxRParAAKbC85UJtE371.jpg\" alt=\"http://s3.51cto.com/wyfs02/M00/11/7C/wKioL1LSWzzxRParAAKbC85UJtE371.jpg\"></p>\n<p>抓包分析：</p>\n<p>① 号包，这个是那台虚拟机在广播，要获取192.168.100.254（也就是网关）的MAC地址，因为局域网的通信靠的是MAC地址，它为什么需要跟网关进行通信是因为我们的DNS服务器IP是外围IP，要出去必须要依靠网关帮我们出去才行。<br>② 号包，这个是网关收到了虚拟机的广播之后，回应给虚拟机的回应，告诉虚拟机自己的MAC地址，于是客户端找到了路由出口。</p>\n<p>③ 号包，这个包是wget命令向系统配置的DNS服务器提出域名解析请求（准确的说应该是wget发起了一个DNS解析的系统调用），请求的域名www.linux178.com,期望得到的是IP6的地址（AAAA代表的是IPv6地址）<br>④ 号包，这个DNS服务器给系统的响应，很显然目前使用IPv6的还是极少数，所以得不到AAAA记录的<br>⑤ 号包，这个还是请求解析IPv6地址，但是www.linux178.com.leo.com这个主机名是不存在的，所以得到结果就是no such name</p>\n<p>⑥ 号包，这个才是请求的域名对应的IPv4地址（A记录）<br>⑦ 号包，DNS服务器不管是从缓存里面，还是进行迭代查询最终得到了域名的IP地址，响应给了系统，系统再给了wget命令，wget于是得到了www.linux178.com的IP地址，这里也可以看出客户端和本地的DNS服务器是递归的查询（也就是服务器必须给客户端一个结果）这就可以开始下一步了，进行TCP的三次握手。</p>\n<h2 id=\"发起TCP的3次握手\"><a href=\"#发起TCP的3次握手\" class=\"headerlink\" title=\"发起TCP的3次握手\"></a>发起TCP的3次握手</h2><p>拿到域名对应的IP地址之后，User-Agent（一般是指浏览器）会以一个随机端口（1024 &lt; 端口 &lt; 65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求（原始的http请求经过TCP/IP4层模型的层层封包）到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序（本文就以Nginx为例），最终建立了TCP/IP的连接。<br>如下图：<br><img src=\"http://s3.51cto.com/wyfs02/M01/11/7C/wKioL1LSW6rjI1nhAAE63Uv8ZRY731.jpg\" alt=\"wKioL1LSW6rjI1nhAAE63Uv8ZRY731.jpg\"><br>1） Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复<br>2） Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。<br>3） Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。<br>看抓包截图：<br><img src=\"http://s3.51cto.com/wyfs02/M00/11/7D/wKiom1LSW9-BWZw6AAD7FV3OfS4963.jpg\" alt=\"wKiom1LSW9-BWZw6AAD7FV3OfS4963.jpg\"></p>\n<p>⑨ 号包 这个就是对应上面的步骤 1）<br>⑩ 号包 这个对应的上面的步骤 2）<br>号包 这个对应的上面的步骤 3）</p>\n<p>TCP 为什么需要3次握手？</p>\n<p>举个例子：</p>\n<p>假设一个老外在故宫里面迷路了，看到了小明，于是就有下面的对话：</p>\n<pre><code>老外： Excuse me，Can you Speak English?\n小明： yes 。\n老外： OK,I want ...\n</code></pre><p>在问路之前，老外先问小明是否会说英语，小明回答是的，这时老外才开始问路</p>\n<p>2个计算机通信是靠协议（目前流行的TCP/IP协议）来实现,如果2个计算机使用的协议不一样，那是不能进行通信的，所以这个3次握手就相当于试探一下对方是否遵循TCP/IP协议，协商完成后就可以进行通信了，当然这样理解不是那么准确。</p>\n<p>为什么HTTP协议要基于TCP来实现？</p>\n<p>目前在Internet中所有的传输都是通过TCP/IP进行的，HTTP协议作为TCP/IP模型中应用层的协议也不例外，TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。</p>\n<h2 id=\"建立TCP连接后发起http请求\"><a href=\"#建立TCP连接后发起http请求\" class=\"headerlink\" title=\"建立TCP连接后发起http请求\"></a>建立TCP连接后发起http请求</h2><p>进过TCP3次握手之后，浏览器发起了http的请求（看第包），使用的http的方法 GET 方法，请求的URL是 / ,协议是HTTP/1.0</p>\n<p><img src=\"http://s3.51cto.com/wyfs02/M00/11/7C/wKioL1LSXDmgmVT_AAFUErYF2ys832.jpg\" alt=\"wKioL1LSXDmgmVT_AAFUErYF2ys832.jpg\"><br>下面是第12号包的详细内容：<br><img src=\"http://s3.51cto.com/wyfs02/M02/11/7D/wKiom1LSXHiCgHkBAAKtTT2l-Ac152.jpg\" alt=\"wKiom1LSXHiCgHkBAAKtTT2l-Ac152.jpg\"></p>\n<p>以上的报文是HTTP请求报文。</p>\n<p>那么HTTP请求报文和响应报文会是什么格式呢？</p>\n<p>起始行：如 GET / HTTP/1.0 （请求的方法  请求的URL 请求所使用的协议）<br>头部信息：User-Agent  Host等成对出现的值<br>主体</p>\n<p>不管是请求报文还是响应报文都会遵循以上的格式。</p>\n<p>那么起始行中的请求方法有哪些种呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET: 完整请求一个资源 （常用）</span><br><span class=\"line\">HEAD: 仅请求响应首部</span><br><span class=\"line\">POST：提交表单  （常用）</span><br><span class=\"line\">PUT: (webdav) 上传文件（但是浏览器不支持该方法）</span><br><span class=\"line\">DELETE：(webdav) 删除</span><br><span class=\"line\">OPTIONS：返回请求的资源所支持的方法的方法</span><br><span class=\"line\">TRACE: 追求一个资源请求中间所经过的代理（该方法不能由浏览器发出）</span><br></pre></td></tr></table></figure>\n<p>那什么是URL、URI、URN？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">URI  Uniform Resource Identifier 统一资源标识符</span><br><span class=\"line\">URL  Uniform Resource Locator 统一资源定位符</span><br><span class=\"line\">    格式如下：  scheme://[username:password@]HOST:port/path/to/source</span><br><span class=\"line\">                http://www.magedu.com/downloads/nginx-1.5.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">URN  Uniform Resource Name 统一资源名称</span><br><span class=\"line\"></span><br><span class=\"line\">URL和URN 都属于 URI</span><br></pre></td></tr></table></figure>\n<p>为了方便就把URL和URI暂时都通指一个东西</p>\n<h2 id=\"请求的协议有哪些种？\"><a href=\"#请求的协议有哪些种？\" class=\"headerlink\" title=\"请求的协议有哪些种？\"></a>请求的协议有哪些种？</h2><p>有以下几种：</p>\n<p>http/0.9: stateless<br>http/1.0: MIME, keep-alive (保持连接), 缓存<br>http/1.1: 更多的请求方法，更精细的缓存控制，持久连接(persistent connection) 比较常用</p>\n<p>下面是Chrome发起的http请求报文头部信息</p>\n<p><img src=\"http://s3.51cto.com/wyfs02/M01/11/7C/wKioL1LSXMqCjyIQAAESKm-mkV8876.jpg\" alt=\"wKioL1LSXMqCjyIQAAESKm-mkV8876.jpg\"></p>\n<p>其中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Accept  就是告诉服务器端，我接受那些MIME类型</span><br><span class=\"line\">Accept-Encoding  这个看起来是接受那些压缩方式的文件</span><br><span class=\"line\">Accept-Lanague   告诉服务器能够发送哪些语言</span><br><span class=\"line\">Connection       告诉服务器支持keep-alive特性</span><br><span class=\"line\">Cookie           每次请求时都会携带上Cookie以方便服务器端识别是否是同一个客户端</span><br><span class=\"line\">Host             用来标识请求服务器上的那个虚拟主机，比如Nginx里面可以定义很多</span><br><span class=\"line\">个虚拟主机</span><br><span class=\"line\">                那这里就是用来标识要访问那个虚拟主机。</span><br><span class=\"line\">User-Agent       用户代理，一般情况是浏览器，也有其他类型，如：wget curl 搜索引擎的蜘蛛等</span><br></pre></td></tr></table></figure>\n<p>条件请求首部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">If-Modified-Since 是浏览器向服务器端询问某个资源文件如果自从什么时间修改过，那么重新发给我，这样就保证服务器端资源文件更新时，浏览器再次去请求，而不是使用缓存中的文件</span><br></pre></td></tr></table></figure>\n<p>安全请求首部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Authorization: 客户端提供给服务器的认证信息；</span><br></pre></td></tr></table></figure>\n<h2 id=\"什么是MIME？\"><a href=\"#什么是MIME？\" class=\"headerlink\" title=\"什么是MIME？\"></a>什么是MIME？</h2><p>MIME（Multipurpose Internet Mail Extesions 多用途互联网邮件扩展）是一个互联网标准，它扩展了电子邮件标准，使其能够支持非ASCII字符、二进制格式附件等多种格式的邮件消息，这个标准被定义在RFC 2045、RFC 2046、RFC 2047、RFC 2048、RFC 2049等RFC中。 由RFC 822转变而来的RFC 2822，规定电子邮件标准并不允许在邮件消息中使用7位ASCII字符集以外的字符。正因如此，一些非英语字符消息和二进制文件，图像，声音等非文字消息都不能在电子邮件中传输。MIME规定了用于表示各种各样的数据类型的符号化方法。 此外，在万维网中使用的HTTP协议中也使用了MIME的框架，标准被扩展为互联网媒体类型。</p>\n<p>MIME 遵循以下格式：major/minor 主类型/次类型 例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">image/jpg</span><br><span class=\"line\">image/gif</span><br><span class=\"line\">text/html</span><br><span class=\"line\">video/quicktime</span><br><span class=\"line\">appliation/x-httpd-php</span><br></pre></td></tr></table></figure>\n<p>4.服务器端响应http请求，浏览器得到html代码</p>\n<p>看下图 第12号包是http请求包，第32包是http响应包</p>\n<p>服务器端WEB程序接收到http请求以后，就开始处理该请求，处理之后就返回给浏览器html文件。</p>\n<p><img src=\"http://s3.51cto.com/wyfs02/M00/11/7D/wKiom1LSXVeQETJrAAaV9VlbbBo896.jpg\" alt=\"wKiom1LSXVeQETJrAAaV9VlbbBo896.jpg\"></p>\n<p>第32号包 是服务器返回给客户端http响应包（200 ok 响应的MIME类型是text/html），代表这一次客户端发起的http请求已成功响应。200 代表是的 响应成功的状态码，还有其他的状态码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1xx: 信息性状态码</span><br><span class=\"line\">    100, 101</span><br><span class=\"line\">2xx: 成功状态码</span><br><span class=\"line\">    200：OK</span><br><span class=\"line\">3xx: 重定向状态码</span><br><span class=\"line\">    301: 永久重定向, Location响应首部的值仍为当前URL，因此为隐藏重定向;</span><br><span class=\"line\">    302: 临时重定向，显式重定向, Location响应首部的值为新的URL</span><br><span class=\"line\">    304：Not Modified  未修改，比如本地缓存的资源文件和服务器上比较时，发现并没有修改，服务器返回一个304状态码，</span><br><span class=\"line\">                        告诉浏览器，你不用请求该资源，直接使用本地的资源即可。</span><br><span class=\"line\">4xx: 客户端错误状态码</span><br><span class=\"line\">    404: Not Found  请求的URL资源并不存在</span><br><span class=\"line\">5xx: 服务器端错误状态码</span><br><span class=\"line\">    500: Internal Server Error  服务器内部错误</span><br><span class=\"line\">    502: Bad Gateway  前面代理服务器联系不到后端的服务器时出现</span><br><span class=\"line\">    504：Gateway Timeout  这个是代理能联系到后端的服务器，但是后端的服务器在规定的时间内没有给代理服务器响应</span><br></pre></td></tr></table></figure>\n<p>用Chrome浏览器看到的响应头信息：</p>\n<p><img src=\"http://s3.51cto.com/wyfs02/M02/11/7C/wKioL1LSXgCDWDvyAADfe7wzmKk795.jpg\" alt=\"wKioL1LSXgCDWDvyAADfe7wzmKk795.jpg\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Connection            使用keep-alive特性</span><br><span class=\"line\">Content-Encoding      使用gzip方式对资源压缩</span><br><span class=\"line\">Content-type          MIME类型为html类型，字符集是 UTF-8</span><br><span class=\"line\">Date                  响应的日期</span><br><span class=\"line\">Server                使用的WEB服务器</span><br><span class=\"line\">Transfer-Encoding:chunked   分块传输编码 是http中的一种数据传输机制，允许HTTP由网页服务器发送给客户端应用（通常是网页浏览器）的数据可以分成多个部分，分块传输编码只在HTTP协议1.1版本（HTTP/1.1）中提供</span><br><span class=\"line\">Vary  这个可以参考（http://blog.csdn.net/tenfyguo/article/details/5939000）</span><br><span class=\"line\">X-Pingback  参考（http://blog.sina.com.cn/s/blog_bb80041c0101fmfz.html）</span><br></pre></td></tr></table></figure>\n<h2 id=\"那到底服务器端接收到http请求后是怎么样生成html文件？\"><a href=\"#那到底服务器端接收到http请求后是怎么样生成html文件？\" class=\"headerlink\" title=\"那到底服务器端接收到http请求后是怎么样生成html文件？\"></a>那到底服务器端接收到http请求后是怎么样生成html文件？</h2><p>假设服务器端使用nginx+php(fastcgi)架构提供服务</p>\n<p>① nginx读取配置文件</p>\n<p>我们在浏览器的地址栏里面输入的是 <a href=\"http://www.linux178.com\" target=\"_blank\" rel=\"external\">http://www.linux178.com</a> （<a href=\"http://可以不用输入，浏览器会自动帮我们添加），其实完整的应该是http://www.linux178.com./\" target=\"_blank\" rel=\"external\">http://可以不用输入，浏览器会自动帮我们添加），其实完整的应该是http://www.linux178.com./</a> 后面还有个点（这个点代表就是根域，一般情况下我们不用输入，也不显示）,后面的/也是不用添加，浏览器会自动帮我们添加（且看第3部那个图里面的URL），那么实际请求的URL是<a href=\"http://www.linux178.com/，那么好了Nginx在收到\" target=\"_blank\" rel=\"external\">http://www.linux178.com/，那么好了Nginx在收到</a> 浏览器 GET / 请求时，会读取http请求里面的头部信息，根据Host来匹配 自己的所有的虚拟主机的配置文件的server_name,看看有没有匹配的，有匹配那么就读取该虚拟主机的配置，发现如下配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root /web/echo</span><br></pre></td></tr></table></figure>\n<p>通过这个就知道所有网页文件的就在这个目录下 这个目录就是/ 当我们<a href=\"http://www.linux178.com/时就是访问这个目录下面的文件，例如访问http://www.linux178.com/index.html,那么代表/web/echo下面有个文件叫index.html\" target=\"_blank\" rel=\"external\">http://www.linux178.com/时就是访问这个目录下面的文件，例如访问http://www.linux178.com/index.html,那么代表/web/echo下面有个文件叫index.html</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">index index.html index.htm index.php</span><br></pre></td></tr></table></figure>\n<p>通过这个就能得知网站的首页文件是那个文件，也就是我们在入<a href=\"http://www.linux178.com/\" target=\"_blank\" rel=\"external\">http://www.linux178.com/</a> ，nginx就会自动帮我们把index.html（假设首页是index.php 当然是会尝试的去找到该文件，如果没有找到该文件就依次往下找，如果这3个文件都没有找到，那么就抛出一个404错误）加到后面，那么添加之后的URL是/index.php,然后根据后面的配置进行处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ~ .*\\.php(\\/.*)*$ &#123;</span><br><span class=\"line\">   root /web/echo;</span><br><span class=\"line\">   fastcgi_pass   127.0.0.1:9000;</span><br><span class=\"line\">   fastcgi_index  index.php;</span><br><span class=\"line\">   astcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class=\"line\">   include        fastcgi_params;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这一段配置指明凡是请求的URL中匹配（这里是启用了正则表达式进行匹配） *.php后缀的（后面跟的参数）都交给后端的fastcgi进程进行处理。</p>\n<p>② 把php文件交给fastcgi进程去处理</p>\n<p>于是nginx把/index.php这个URL交给了后端的fastcgi进程处理，等待fastcgi处理完成后（结合数据库查询出数据，填充模板生成html文件）返回给nginx一个index.html文档，Nginx再把这个index.html返回给浏览器，于是乎浏览器就拿到了首页的html代码，同时nginx写一条访问日志到日志文件中去。</p>\n<h3 id=\"注1：nginx是怎么找index-php文件的？\"><a href=\"#注1：nginx是怎么找index-php文件的？\" class=\"headerlink\" title=\"注1：nginx是怎么找index.php文件的？\"></a>注1：nginx是怎么找index.php文件的？</h3><p>当nginx发现需要/web/echo/index.php文件时，就会向内核发起IO系统调用(因为要跟硬件打交道，这里的硬件是指硬盘，通常需要靠内核来操作，而内核提供的这些功能是通过系统调用来实现的)，告诉内核，我需要这个文件,内核从/开始找到web目录，再在web目录下找到echo目录，最后在echo目录下找到index.php文件，于是把这个index.php从硬盘上读取到内核自身的内存空间，然后再把这个文件复制到nginx进程所在的内存空间，于是乎nginx就得到了自己想要的文件了。</p>\n<h3 id=\"注2：寻找文件在文件系统层面是怎么操作的？\"><a href=\"#注2：寻找文件在文件系统层面是怎么操作的？\" class=\"headerlink\" title=\"注2：寻找文件在文件系统层面是怎么操作的？\"></a>注2：寻找文件在文件系统层面是怎么操作的？</h3><p>比如nginx需要得到/web/echo/index.php这个文件</p>\n<p>每个分区（像ext3 ext3等文件系统，block块是文件存储的最小单元 默认是4096字节）都是包含元数据区和数据区，每一个文件在元数据区都有元数据条目（一般是128字节大小），每一个条目都有一个编号，我们称之为inode（index node 索引节点），这个inode里面包含 文件类型、权限、连接次数、属主和数组的ID、时间戳、这个文件占据了那些磁盘块也就是块的编号（block，每个文件可以占用多个block,并且block不一定是连续的，每个block是有编号的），如下图所示：</p>\n<p><img src=\"http://s3.51cto.com/wyfs02/M01/11/7D/wKiom1LSXwWRzx75AACjRCdIYcI778.jpg\" alt=\"wKiom1LSXwWRzx75AACjRCdIYcI778.jpg\"></p>\n<p>还有一个要点：目录其实也普通是文件，也需要占用磁盘块，目录不是一个容器。你看默认创建的目录就是4096字节，也就说只需要占用一个磁盘块，但这是不确定的。所以要找到目录也是需要到元数据区里面找到对应的条目，只有找到对应的inode就可找到目录所占用的磁盘块。</p>\n<p>那到底目录里面存放着什么，难道不是文件或者其他目录吗？</p>\n<p>其实目录存着这么一张表（姑且这么理解），里面放着 目录或者文件的名称和对应的inode号（暂时称之为映射表）,如下图：<br><img src=\"http://s3.51cto.com/wyfs02/M02/11/7D/wKiom1LSX3KATYWYAAAx2GkMEO4103.jpg\" alt=\"wKiom1LSX3KATYWYAAAx2GkMEO4103.jpg\"></p>\n<p>假设<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/           在数据区占据 1、2号block ，/其实也是一个目录 里面有3个目录  web 111</span><br><span class=\"line\">web         占据 5号block  是目录 里面有2个目录 echo data</span><br><span class=\"line\">echo        占据 11号 block  是目录  里面有1个文件 index.php</span><br><span class=\"line\">index.php   占据 15 16号 block  是文件</span><br></pre></td></tr></table></figure></p>\n<p>其在文件系统中分布如下图所示</p>\n<p><img src=\"http://s3.51cto.com/wyfs02/M01/11/7C/wKioL1LSX6OizObEAAHJJkuxCa0943.jpg\" alt=\"wKioL1LSX6OizObEAAHJJkuxCa0943.jpg\"></p>\n<p>那么内核究竟是怎么找到index.php这个文件的呢？</p>\n<p>内核拿到nginx的IO系统调用要获取/web/echo/index.php这个文件请求之后</p>\n<p>① 内核读取元数据区 / 的inode，从inode里面读取/所对应的数据块的编号，然后在数据区找到其对应的块（1 2号块），读取1号块上的映射表找到web这个名称在元数据区对应的inode号</p>\n<p>② 内核读取web对应的inode（3号），从中得知web在数据区对应的块是5号块，于是到数据区找到5号块，从中读取映射表，知道echo对应的inode是5号，于是到元数据区找到5号inode</p>\n<p>③ 内核读取5号inode，得到echo在数据区对应的是11号块，于是到数据区读取11号块得到映射表，得到index.php对应的inode是9号</p>\n<p>④ 内核到元数据区读取9号inode，得到index.php对应的是15和16号数据块，于是就到数据区域找到15 16号块，读取其中的内容，得到index.php的完整内容</p>\n<h2 id=\"浏览器解析html代码，并请求html代码中的资源\"><a href=\"#浏览器解析html代码，并请求html代码中的资源\" class=\"headerlink\" title=\"浏览器解析html代码，并请求html代码中的资源\"></a>浏览器解析html代码，并请求html代码中的资源</h2><p>浏览器拿到index.html文件后，就开始解析其中的html代码，遇到js/css/image等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上keep-alive特性了，建立一次HTTP连接，可以请求多个资源，下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源，所以从下图看出，这里显示的顺序并不一定是代码里面的顺序。</p>\n<p>浏览器在请求静态资源时（在未过期的情况下），向服务器端发起一个http请求（询问自从上一次修改时间到现在有没有对资源进行修改），如果服务器端返回304状态码（告诉浏览器服务器端没有修改），那么浏览器会直接读取本地的该资源的缓存文件。<br><img src=\"http://s3.51cto.com/wyfs02/M00/11/7D/wKiom1LSX_PT06f3AAF_5iS18UA331.jpg\" alt=\"wKiom1LSX_PT06f3AAF_5iS18UA331.jpg\"></p>\n<p>详细的浏览器工作原理请看：<a href=\"http://kb.cnblogs.com/page/129756/\" target=\"_blank\" rel=\"external\">http://kb.cnblogs.com/page/129756/</a></p>\n<p>6.浏览器对页面进行渲染呈现给用户</p>\n<p>最后，浏览器利用自己内部的工作机制，把请求到的静态资源和html代码进行渲染，渲染之后呈现给用户。</p>\n<p>自此一次完整的HTTP事务宣告完成.</p>\n<p>本文出自 “雷纳科斯的博客” 博客，请务必保留此出处<a href=\"http://linux5588.blog.51cto.com/65280/1351007\" target=\"_blank\" rel=\"external\">http://linux5588.blog.51cto.com/65280/1351007</a></p>\n","excerpt":"<h1 id=\"一次完整的HTTP事务是怎样一个过程\"><a href=\"#一次完整的HTTP事务是怎样一个过程\" class=\"headerlink\" title=\"一次完整的HTTP事务是怎样一个过程\"></a>一次完整的HTTP事务是怎样一个过程</h1><p>当我们在浏览器的地址栏输入 www.linux178.com ，然后回车，回车这一瞬间到看到页面到底发生了什么呢？</p>\n<p>以下过程仅是个人理解：</p>\n<p>域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户</p>\n<p>关于HTTP协议可以参考以下：<br>HTTP协议漫谈  <a href=\"http://kb.cnblogs.com/page/140611/\">http://kb.cnblogs.com/page/140611/</a></p>\n<p>HTTP协议概览  <a href=\"http://www.cnblogs.com/vamei/archive/2013/05/11/3069788.html\">http://www.cnblogs.com/vamei/archive/2013/05/11/3069788.html</a></p>\n<p>了解HTTP Headers的方方面面  <a href=\"http://kb.cnblogs.com/page/55442/\">http://kb.cnblogs.com/page/55442/</a><br>","more":"</p>\n<p>以下就是上面过程的一一分析，我们就以Chrome浏览器为例：</p>\n<h2 id=\"域名解析\"><a href=\"#域名解析\" class=\"headerlink\" title=\"域名解析\"></a>域名解析</h2><p>首先Chrome浏览器会解析 www.linux178.com 这个域名（准确的叫法应该是主机名）对应的IP地址。怎么解析到对应的IP地址？</p>\n<p>① Chrome浏览器 会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有www.linux178.com 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。</p>\n<pre><code>注：我们怎么查看Chrome自身的缓存？可以使用 chrome://net-internals/#dns 来进行查看\n</code></pre><p>② 如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.</p>\n<pre><code>注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看  \n</code></pre><p>③ 如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\\Windows\\System32\\drivers\\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。</p>\n<p>④ 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问www.linux178.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.linux178.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.linux178.com这个域名的IP地址，但是我知道linux178.com这个域的DNS地址，你去找它去，于是运营商的DNS又向linux178.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.linux178.com这个域名的IP地址是多少？），这个时候linux178.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.linux178.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.linux178.com  对应的IP地址，该进行一步的动作了。</p>\n<h4 id=\"注：一般情况下是不会进行以下步骤的\"><a href=\"#注：一般情况下是不会进行以下步骤的\" class=\"headerlink\" title=\"注：一般情况下是不会进行以下步骤的\"></a>注：一般情况下是不会进行以下步骤的</h4><p>如果经过以上的4个步骤，还没有解析成功，那么会进行如下步骤（以下是针对Windows操作系统）：</p>\n<p>⑤ 操作系统就会查找NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和Ip地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。</p>\n<p>⑥ 如果第⑤步也没有成功，那会查询WINS 服务器（是NETBIOS名称和IP地址对应的服务器）</p>\n<p>⑦ 如果第⑥步也没有查询成功，那么客户端就要进行广播查找</p>\n<p>⑧ 如果第⑦步也没有成功，那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样）</p>\n<p>如果第八步还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要这八步中有一步可以解析成功，那就可以成功和目标计算机进行通信。</p>\n<p>看下图抓包截图：<br>Linux虚拟机测试，使用命令 wget www.linux178.com 来请求，发现直接使用chrome浏览器请求时，干扰请求比较多，所以就使用wget命令来请求，不过使用wget命令只能把index.html请求回来，并不会对index.html中包含的静态资源（js、css等文件）进行请求。<br><img src=\"http://s3.51cto.com/wyfs02/M00/11/7C/wKioL1LSWzzxRParAAKbC85UJtE371.jpg\" alt=\"http://s3.51cto.com/wyfs02/M00/11/7C/wKioL1LSWzzxRParAAKbC85UJtE371.jpg\"></p>\n<p>抓包分析：</p>\n<p>① 号包，这个是那台虚拟机在广播，要获取192.168.100.254（也就是网关）的MAC地址，因为局域网的通信靠的是MAC地址，它为什么需要跟网关进行通信是因为我们的DNS服务器IP是外围IP，要出去必须要依靠网关帮我们出去才行。<br>② 号包，这个是网关收到了虚拟机的广播之后，回应给虚拟机的回应，告诉虚拟机自己的MAC地址，于是客户端找到了路由出口。</p>\n<p>③ 号包，这个包是wget命令向系统配置的DNS服务器提出域名解析请求（准确的说应该是wget发起了一个DNS解析的系统调用），请求的域名www.linux178.com,期望得到的是IP6的地址（AAAA代表的是IPv6地址）<br>④ 号包，这个DNS服务器给系统的响应，很显然目前使用IPv6的还是极少数，所以得不到AAAA记录的<br>⑤ 号包，这个还是请求解析IPv6地址，但是www.linux178.com.leo.com这个主机名是不存在的，所以得到结果就是no such name</p>\n<p>⑥ 号包，这个才是请求的域名对应的IPv4地址（A记录）<br>⑦ 号包，DNS服务器不管是从缓存里面，还是进行迭代查询最终得到了域名的IP地址，响应给了系统，系统再给了wget命令，wget于是得到了www.linux178.com的IP地址，这里也可以看出客户端和本地的DNS服务器是递归的查询（也就是服务器必须给客户端一个结果）这就可以开始下一步了，进行TCP的三次握手。</p>\n<h2 id=\"发起TCP的3次握手\"><a href=\"#发起TCP的3次握手\" class=\"headerlink\" title=\"发起TCP的3次握手\"></a>发起TCP的3次握手</h2><p>拿到域名对应的IP地址之后，User-Agent（一般是指浏览器）会以一个随机端口（1024 &lt; 端口 &lt; 65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求（原始的http请求经过TCP/IP4层模型的层层封包）到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序（本文就以Nginx为例），最终建立了TCP/IP的连接。<br>如下图：<br><img src=\"http://s3.51cto.com/wyfs02/M01/11/7C/wKioL1LSW6rjI1nhAAE63Uv8ZRY731.jpg\" alt=\"wKioL1LSW6rjI1nhAAE63Uv8ZRY731.jpg\"><br>1） Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复<br>2） Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。<br>3） Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。<br>看抓包截图：<br><img src=\"http://s3.51cto.com/wyfs02/M00/11/7D/wKiom1LSW9-BWZw6AAD7FV3OfS4963.jpg\" alt=\"wKiom1LSW9-BWZw6AAD7FV3OfS4963.jpg\"></p>\n<p>⑨ 号包 这个就是对应上面的步骤 1）<br>⑩ 号包 这个对应的上面的步骤 2）<br>号包 这个对应的上面的步骤 3）</p>\n<p>TCP 为什么需要3次握手？</p>\n<p>举个例子：</p>\n<p>假设一个老外在故宫里面迷路了，看到了小明，于是就有下面的对话：</p>\n<pre><code>老外： Excuse me，Can you Speak English?\n小明： yes 。\n老外： OK,I want ...\n</code></pre><p>在问路之前，老外先问小明是否会说英语，小明回答是的，这时老外才开始问路</p>\n<p>2个计算机通信是靠协议（目前流行的TCP/IP协议）来实现,如果2个计算机使用的协议不一样，那是不能进行通信的，所以这个3次握手就相当于试探一下对方是否遵循TCP/IP协议，协商完成后就可以进行通信了，当然这样理解不是那么准确。</p>\n<p>为什么HTTP协议要基于TCP来实现？</p>\n<p>目前在Internet中所有的传输都是通过TCP/IP进行的，HTTP协议作为TCP/IP模型中应用层的协议也不例外，TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。</p>\n<h2 id=\"建立TCP连接后发起http请求\"><a href=\"#建立TCP连接后发起http请求\" class=\"headerlink\" title=\"建立TCP连接后发起http请求\"></a>建立TCP连接后发起http请求</h2><p>进过TCP3次握手之后，浏览器发起了http的请求（看第包），使用的http的方法 GET 方法，请求的URL是 / ,协议是HTTP/1.0</p>\n<p><img src=\"http://s3.51cto.com/wyfs02/M00/11/7C/wKioL1LSXDmgmVT_AAFUErYF2ys832.jpg\" alt=\"wKioL1LSXDmgmVT_AAFUErYF2ys832.jpg\"><br>下面是第12号包的详细内容：<br><img src=\"http://s3.51cto.com/wyfs02/M02/11/7D/wKiom1LSXHiCgHkBAAKtTT2l-Ac152.jpg\" alt=\"wKiom1LSXHiCgHkBAAKtTT2l-Ac152.jpg\"></p>\n<p>以上的报文是HTTP请求报文。</p>\n<p>那么HTTP请求报文和响应报文会是什么格式呢？</p>\n<p>起始行：如 GET / HTTP/1.0 （请求的方法  请求的URL 请求所使用的协议）<br>头部信息：User-Agent  Host等成对出现的值<br>主体</p>\n<p>不管是请求报文还是响应报文都会遵循以上的格式。</p>\n<p>那么起始行中的请求方法有哪些种呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET: 完整请求一个资源 （常用）</span><br><span class=\"line\">HEAD: 仅请求响应首部</span><br><span class=\"line\">POST：提交表单  （常用）</span><br><span class=\"line\">PUT: (webdav) 上传文件（但是浏览器不支持该方法）</span><br><span class=\"line\">DELETE：(webdav) 删除</span><br><span class=\"line\">OPTIONS：返回请求的资源所支持的方法的方法</span><br><span class=\"line\">TRACE: 追求一个资源请求中间所经过的代理（该方法不能由浏览器发出）</span><br></pre></td></tr></table></figure>\n<p>那什么是URL、URI、URN？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">URI  Uniform Resource Identifier 统一资源标识符</span><br><span class=\"line\">URL  Uniform Resource Locator 统一资源定位符</span><br><span class=\"line\">    格式如下：  scheme://[username:password@]HOST:port/path/to/source</span><br><span class=\"line\">                http://www.magedu.com/downloads/nginx-1.5.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">URN  Uniform Resource Name 统一资源名称</span><br><span class=\"line\"></span><br><span class=\"line\">URL和URN 都属于 URI</span><br></pre></td></tr></table></figure>\n<p>为了方便就把URL和URI暂时都通指一个东西</p>\n<h2 id=\"请求的协议有哪些种？\"><a href=\"#请求的协议有哪些种？\" class=\"headerlink\" title=\"请求的协议有哪些种？\"></a>请求的协议有哪些种？</h2><p>有以下几种：</p>\n<p>http/0.9: stateless<br>http/1.0: MIME, keep-alive (保持连接), 缓存<br>http/1.1: 更多的请求方法，更精细的缓存控制，持久连接(persistent connection) 比较常用</p>\n<p>下面是Chrome发起的http请求报文头部信息</p>\n<p><img src=\"http://s3.51cto.com/wyfs02/M01/11/7C/wKioL1LSXMqCjyIQAAESKm-mkV8876.jpg\" alt=\"wKioL1LSXMqCjyIQAAESKm-mkV8876.jpg\"></p>\n<p>其中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Accept  就是告诉服务器端，我接受那些MIME类型</span><br><span class=\"line\">Accept-Encoding  这个看起来是接受那些压缩方式的文件</span><br><span class=\"line\">Accept-Lanague   告诉服务器能够发送哪些语言</span><br><span class=\"line\">Connection       告诉服务器支持keep-alive特性</span><br><span class=\"line\">Cookie           每次请求时都会携带上Cookie以方便服务器端识别是否是同一个客户端</span><br><span class=\"line\">Host             用来标识请求服务器上的那个虚拟主机，比如Nginx里面可以定义很多</span><br><span class=\"line\">个虚拟主机</span><br><span class=\"line\">                那这里就是用来标识要访问那个虚拟主机。</span><br><span class=\"line\">User-Agent       用户代理，一般情况是浏览器，也有其他类型，如：wget curl 搜索引擎的蜘蛛等</span><br></pre></td></tr></table></figure>\n<p>条件请求首部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">If-Modified-Since 是浏览器向服务器端询问某个资源文件如果自从什么时间修改过，那么重新发给我，这样就保证服务器端资源文件更新时，浏览器再次去请求，而不是使用缓存中的文件</span><br></pre></td></tr></table></figure>\n<p>安全请求首部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Authorization: 客户端提供给服务器的认证信息；</span><br></pre></td></tr></table></figure>\n<h2 id=\"什么是MIME？\"><a href=\"#什么是MIME？\" class=\"headerlink\" title=\"什么是MIME？\"></a>什么是MIME？</h2><p>MIME（Multipurpose Internet Mail Extesions 多用途互联网邮件扩展）是一个互联网标准，它扩展了电子邮件标准，使其能够支持非ASCII字符、二进制格式附件等多种格式的邮件消息，这个标准被定义在RFC 2045、RFC 2046、RFC 2047、RFC 2048、RFC 2049等RFC中。 由RFC 822转变而来的RFC 2822，规定电子邮件标准并不允许在邮件消息中使用7位ASCII字符集以外的字符。正因如此，一些非英语字符消息和二进制文件，图像，声音等非文字消息都不能在电子邮件中传输。MIME规定了用于表示各种各样的数据类型的符号化方法。 此外，在万维网中使用的HTTP协议中也使用了MIME的框架，标准被扩展为互联网媒体类型。</p>\n<p>MIME 遵循以下格式：major/minor 主类型/次类型 例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">image/jpg</span><br><span class=\"line\">image/gif</span><br><span class=\"line\">text/html</span><br><span class=\"line\">video/quicktime</span><br><span class=\"line\">appliation/x-httpd-php</span><br></pre></td></tr></table></figure>\n<p>4.服务器端响应http请求，浏览器得到html代码</p>\n<p>看下图 第12号包是http请求包，第32包是http响应包</p>\n<p>服务器端WEB程序接收到http请求以后，就开始处理该请求，处理之后就返回给浏览器html文件。</p>\n<p><img src=\"http://s3.51cto.com/wyfs02/M00/11/7D/wKiom1LSXVeQETJrAAaV9VlbbBo896.jpg\" alt=\"wKiom1LSXVeQETJrAAaV9VlbbBo896.jpg\"></p>\n<p>第32号包 是服务器返回给客户端http响应包（200 ok 响应的MIME类型是text/html），代表这一次客户端发起的http请求已成功响应。200 代表是的 响应成功的状态码，还有其他的状态码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1xx: 信息性状态码</span><br><span class=\"line\">    100, 101</span><br><span class=\"line\">2xx: 成功状态码</span><br><span class=\"line\">    200：OK</span><br><span class=\"line\">3xx: 重定向状态码</span><br><span class=\"line\">    301: 永久重定向, Location响应首部的值仍为当前URL，因此为隐藏重定向;</span><br><span class=\"line\">    302: 临时重定向，显式重定向, Location响应首部的值为新的URL</span><br><span class=\"line\">    304：Not Modified  未修改，比如本地缓存的资源文件和服务器上比较时，发现并没有修改，服务器返回一个304状态码，</span><br><span class=\"line\">                        告诉浏览器，你不用请求该资源，直接使用本地的资源即可。</span><br><span class=\"line\">4xx: 客户端错误状态码</span><br><span class=\"line\">    404: Not Found  请求的URL资源并不存在</span><br><span class=\"line\">5xx: 服务器端错误状态码</span><br><span class=\"line\">    500: Internal Server Error  服务器内部错误</span><br><span class=\"line\">    502: Bad Gateway  前面代理服务器联系不到后端的服务器时出现</span><br><span class=\"line\">    504：Gateway Timeout  这个是代理能联系到后端的服务器，但是后端的服务器在规定的时间内没有给代理服务器响应</span><br></pre></td></tr></table></figure>\n<p>用Chrome浏览器看到的响应头信息：</p>\n<p><img src=\"http://s3.51cto.com/wyfs02/M02/11/7C/wKioL1LSXgCDWDvyAADfe7wzmKk795.jpg\" alt=\"wKioL1LSXgCDWDvyAADfe7wzmKk795.jpg\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Connection            使用keep-alive特性</span><br><span class=\"line\">Content-Encoding      使用gzip方式对资源压缩</span><br><span class=\"line\">Content-type          MIME类型为html类型，字符集是 UTF-8</span><br><span class=\"line\">Date                  响应的日期</span><br><span class=\"line\">Server                使用的WEB服务器</span><br><span class=\"line\">Transfer-Encoding:chunked   分块传输编码 是http中的一种数据传输机制，允许HTTP由网页服务器发送给客户端应用（通常是网页浏览器）的数据可以分成多个部分，分块传输编码只在HTTP协议1.1版本（HTTP/1.1）中提供</span><br><span class=\"line\">Vary  这个可以参考（http://blog.csdn.net/tenfyguo/article/details/5939000）</span><br><span class=\"line\">X-Pingback  参考（http://blog.sina.com.cn/s/blog_bb80041c0101fmfz.html）</span><br></pre></td></tr></table></figure>\n<h2 id=\"那到底服务器端接收到http请求后是怎么样生成html文件？\"><a href=\"#那到底服务器端接收到http请求后是怎么样生成html文件？\" class=\"headerlink\" title=\"那到底服务器端接收到http请求后是怎么样生成html文件？\"></a>那到底服务器端接收到http请求后是怎么样生成html文件？</h2><p>假设服务器端使用nginx+php(fastcgi)架构提供服务</p>\n<p>① nginx读取配置文件</p>\n<p>我们在浏览器的地址栏里面输入的是 <a href=\"http://www.linux178.com\">http://www.linux178.com</a> （<a href=\"http://可以不用输入，浏览器会自动帮我们添加），其实完整的应该是http://www.linux178.com./\">http://可以不用输入，浏览器会自动帮我们添加），其实完整的应该是http://www.linux178.com./</a> 后面还有个点（这个点代表就是根域，一般情况下我们不用输入，也不显示）,后面的/也是不用添加，浏览器会自动帮我们添加（且看第3部那个图里面的URL），那么实际请求的URL是<a href=\"http://www.linux178.com/，那么好了Nginx在收到\">http://www.linux178.com/，那么好了Nginx在收到</a> 浏览器 GET / 请求时，会读取http请求里面的头部信息，根据Host来匹配 自己的所有的虚拟主机的配置文件的server_name,看看有没有匹配的，有匹配那么就读取该虚拟主机的配置，发现如下配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root /web/echo</span><br></pre></td></tr></table></figure>\n<p>通过这个就知道所有网页文件的就在这个目录下 这个目录就是/ 当我们<a href=\"http://www.linux178.com/时就是访问这个目录下面的文件，例如访问http://www.linux178.com/index.html,那么代表/web/echo下面有个文件叫index.html\">http://www.linux178.com/时就是访问这个目录下面的文件，例如访问http://www.linux178.com/index.html,那么代表/web/echo下面有个文件叫index.html</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">index index.html index.htm index.php</span><br></pre></td></tr></table></figure>\n<p>通过这个就能得知网站的首页文件是那个文件，也就是我们在入<a href=\"http://www.linux178.com/\">http://www.linux178.com/</a> ，nginx就会自动帮我们把index.html（假设首页是index.php 当然是会尝试的去找到该文件，如果没有找到该文件就依次往下找，如果这3个文件都没有找到，那么就抛出一个404错误）加到后面，那么添加之后的URL是/index.php,然后根据后面的配置进行处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ~ .*\\.php(\\/.*)*$ &#123;</span><br><span class=\"line\">   root /web/echo;</span><br><span class=\"line\">   fastcgi_pass   127.0.0.1:9000;</span><br><span class=\"line\">   fastcgi_index  index.php;</span><br><span class=\"line\">   astcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class=\"line\">   include        fastcgi_params;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这一段配置指明凡是请求的URL中匹配（这里是启用了正则表达式进行匹配） *.php后缀的（后面跟的参数）都交给后端的fastcgi进程进行处理。</p>\n<p>② 把php文件交给fastcgi进程去处理</p>\n<p>于是nginx把/index.php这个URL交给了后端的fastcgi进程处理，等待fastcgi处理完成后（结合数据库查询出数据，填充模板生成html文件）返回给nginx一个index.html文档，Nginx再把这个index.html返回给浏览器，于是乎浏览器就拿到了首页的html代码，同时nginx写一条访问日志到日志文件中去。</p>\n<h3 id=\"注1：nginx是怎么找index-php文件的？\"><a href=\"#注1：nginx是怎么找index-php文件的？\" class=\"headerlink\" title=\"注1：nginx是怎么找index.php文件的？\"></a>注1：nginx是怎么找index.php文件的？</h3><p>当nginx发现需要/web/echo/index.php文件时，就会向内核发起IO系统调用(因为要跟硬件打交道，这里的硬件是指硬盘，通常需要靠内核来操作，而内核提供的这些功能是通过系统调用来实现的)，告诉内核，我需要这个文件,内核从/开始找到web目录，再在web目录下找到echo目录，最后在echo目录下找到index.php文件，于是把这个index.php从硬盘上读取到内核自身的内存空间，然后再把这个文件复制到nginx进程所在的内存空间，于是乎nginx就得到了自己想要的文件了。</p>\n<h3 id=\"注2：寻找文件在文件系统层面是怎么操作的？\"><a href=\"#注2：寻找文件在文件系统层面是怎么操作的？\" class=\"headerlink\" title=\"注2：寻找文件在文件系统层面是怎么操作的？\"></a>注2：寻找文件在文件系统层面是怎么操作的？</h3><p>比如nginx需要得到/web/echo/index.php这个文件</p>\n<p>每个分区（像ext3 ext3等文件系统，block块是文件存储的最小单元 默认是4096字节）都是包含元数据区和数据区，每一个文件在元数据区都有元数据条目（一般是128字节大小），每一个条目都有一个编号，我们称之为inode（index node 索引节点），这个inode里面包含 文件类型、权限、连接次数、属主和数组的ID、时间戳、这个文件占据了那些磁盘块也就是块的编号（block，每个文件可以占用多个block,并且block不一定是连续的，每个block是有编号的），如下图所示：</p>\n<p><img src=\"http://s3.51cto.com/wyfs02/M01/11/7D/wKiom1LSXwWRzx75AACjRCdIYcI778.jpg\" alt=\"wKiom1LSXwWRzx75AACjRCdIYcI778.jpg\"></p>\n<p>还有一个要点：目录其实也普通是文件，也需要占用磁盘块，目录不是一个容器。你看默认创建的目录就是4096字节，也就说只需要占用一个磁盘块，但这是不确定的。所以要找到目录也是需要到元数据区里面找到对应的条目，只有找到对应的inode就可找到目录所占用的磁盘块。</p>\n<p>那到底目录里面存放着什么，难道不是文件或者其他目录吗？</p>\n<p>其实目录存着这么一张表（姑且这么理解），里面放着 目录或者文件的名称和对应的inode号（暂时称之为映射表）,如下图：<br><img src=\"http://s3.51cto.com/wyfs02/M02/11/7D/wKiom1LSX3KATYWYAAAx2GkMEO4103.jpg\" alt=\"wKiom1LSX3KATYWYAAAx2GkMEO4103.jpg\"></p>\n<p>假设<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/           在数据区占据 1、2号block ，/其实也是一个目录 里面有3个目录  web 111</span><br><span class=\"line\">web         占据 5号block  是目录 里面有2个目录 echo data</span><br><span class=\"line\">echo        占据 11号 block  是目录  里面有1个文件 index.php</span><br><span class=\"line\">index.php   占据 15 16号 block  是文件</span><br></pre></td></tr></table></figure></p>\n<p>其在文件系统中分布如下图所示</p>\n<p><img src=\"http://s3.51cto.com/wyfs02/M01/11/7C/wKioL1LSX6OizObEAAHJJkuxCa0943.jpg\" alt=\"wKioL1LSX6OizObEAAHJJkuxCa0943.jpg\"></p>\n<p>那么内核究竟是怎么找到index.php这个文件的呢？</p>\n<p>内核拿到nginx的IO系统调用要获取/web/echo/index.php这个文件请求之后</p>\n<p>① 内核读取元数据区 / 的inode，从inode里面读取/所对应的数据块的编号，然后在数据区找到其对应的块（1 2号块），读取1号块上的映射表找到web这个名称在元数据区对应的inode号</p>\n<p>② 内核读取web对应的inode（3号），从中得知web在数据区对应的块是5号块，于是到数据区找到5号块，从中读取映射表，知道echo对应的inode是5号，于是到元数据区找到5号inode</p>\n<p>③ 内核读取5号inode，得到echo在数据区对应的是11号块，于是到数据区读取11号块得到映射表，得到index.php对应的inode是9号</p>\n<p>④ 内核到元数据区读取9号inode，得到index.php对应的是15和16号数据块，于是就到数据区域找到15 16号块，读取其中的内容，得到index.php的完整内容</p>\n<h2 id=\"浏览器解析html代码，并请求html代码中的资源\"><a href=\"#浏览器解析html代码，并请求html代码中的资源\" class=\"headerlink\" title=\"浏览器解析html代码，并请求html代码中的资源\"></a>浏览器解析html代码，并请求html代码中的资源</h2><p>浏览器拿到index.html文件后，就开始解析其中的html代码，遇到js/css/image等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上keep-alive特性了，建立一次HTTP连接，可以请求多个资源，下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源，所以从下图看出，这里显示的顺序并不一定是代码里面的顺序。</p>\n<p>浏览器在请求静态资源时（在未过期的情况下），向服务器端发起一个http请求（询问自从上一次修改时间到现在有没有对资源进行修改），如果服务器端返回304状态码（告诉浏览器服务器端没有修改），那么浏览器会直接读取本地的该资源的缓存文件。<br><img src=\"http://s3.51cto.com/wyfs02/M00/11/7D/wKiom1LSX_PT06f3AAF_5iS18UA331.jpg\" alt=\"wKiom1LSX_PT06f3AAF_5iS18UA331.jpg\"></p>\n<p>详细的浏览器工作原理请看：<a href=\"http://kb.cnblogs.com/page/129756/\">http://kb.cnblogs.com/page/129756/</a></p>\n<p>6.浏览器对页面进行渲染呈现给用户</p>\n<p>最后，浏览器利用自己内部的工作机制，把请求到的静态资源和html代码进行渲染，渲染之后呈现给用户。</p>\n<p>自此一次完整的HTTP事务宣告完成.</p>\n<p>本文出自 “雷纳科斯的博客” 博客，请务必保留此出处<a href=\"http://linux5588.blog.51cto.com/65280/1351007\">http://linux5588.blog.51cto.com/65280/1351007</a></p>"},{"title":"单元测试","date":"2016-04-13T12:25:47.000Z","_content":"# 单元测试\n如果你听说过“测试驱动开发”（TDD：Test-Driven Development），单元测试就不陌生。\n\n单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。\n\n比如对函数abs()，我们可以编写出以下几个测试用例：\n\n输入正数，比如1、1.2、0.99，期待返回值与输入相同；\n\n输入负数，比如-1、-1.2、-0.99，期待返回值与输入相反；\n\n输入0，期待返回0；\n\n输入非数值类型，比如None、[]、{}，期待抛出TypeError。\n\n把上面的测试用例放到一个测试模块里，就是一个完整的单元测试。\n\n如果单元测试通过，说明我们测试的这个函数能够正常工作。如果单元测试不通过，要么函数有bug，要么测试条件输入不正确，总之，需要修复使单元测试能够通过。\n\n单元测试通过后有什么意义呢？如果我们对abs()函数代码做了修改，只需要再跑一遍单元测试，如果通过，说明我们的修改不会对abs()函数原有的行为造成影响，如果测试不通过，说明我们的修改与原有行为不一致，要么修改代码，要么修改测试。\n\n这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。\n<!--more-->\n我们来编写一个Dict类，这个类的行为和dict一致，但是可以通过属性来访问，用起来就像下面这样：\n```\n\t>>> d = Dict(a=1, b=2)\n\t>>> d['a']\n\t1\n\t>>> d.a\n\t1\n```\n\nmydict.py代码如下：\n\n``` python\nclass Dict(dict):\n\n    def __init__(self, **kw):\n        super().__init__(**kw)\n\n    def __getattr__(self, key):\n        try:\n            return self[key]\n        except KeyError:\n            raise AttributeError(r\"'Dict' object has no attribute '%s'\" % key)\n\n    def __setattr__(self, key, value):\n        self[key] = value\n```\n\n为了编写单元测试，我们需要引入Python自带的unittest模块，编写mydict_test.py如下：\n\n``` python\nimport unittest\n\nfrom mydict import Dict\n\nclass TestDict(unittest.TestCase):\n\n    def test_init(self):\n        d = Dict(a=1, b='test')\n        self.assertEqual(d.a, 1)\n        self.assertEqual(d.b, 'test')\n        self.assertTrue(isinstance(d, dict))\n\n    def test_key(self):\n        d = Dict()\n        d['key'] = 'value'\n        self.assertEqual(d.key, 'value')\n\n    def test_attr(self):\n        d = Dict()\n        d.key = 'value'\n        self.assertTrue('key' in d)\n        self.assertEqual(d['key'], 'value')\n\n    def test_keyerror(self):\n        d = Dict()\n        with self.assertRaises(KeyError):\n            value = d['empty']\n\n    def test_attrerror(self):\n        d = Dict()\n        with self.assertRaises(AttributeError):\n            value = d.empty\n```\n\n编写单元测试时，我们需要编写一个测试类，从unittest.TestCase继承。\n\n以test开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。\n\n对每一类测试都需要编写一个test_xxx()方法。由于unittest.TestCase提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是assertEqual()：\n\n``` python\n\tself.assertEqual(abs(-1), 1) # 断言函数返回的结果与1相等\n```\n\n另一种重要的断言就是期待抛出指定类型的Error，比如通过d['empty']访问不存在的key时，断言会抛出KeyError：\n\n``` python\nwith self.assertRaises(KeyError):\n    value = d['empty']\n```\n\n而通过d.empty访问不存在的key时，我们期待抛出AttributeError：\n\n\n``` python\nwith self.assertRaises(AttributeError):\n    value = d.empty\n```\n\n运行单元测试\n\n一旦编写好单元测试，我们就可以运行单元测试。最简单的运行方式是在mydict_test.py的最后加上两行代码：\n\n\n``` python \nif __name__ == '__main__':\n    unittest.main()\n```\n这样就可以把mydict_test.py当做正常的python脚本运行：\n\n```\n\t$ python3 mydict_test.py\n```\n另一种方法是在命令行通过参数-m unittest直接运行单元测试：\n\n\n```\n$ python3 -m unittest mydict_test\n.....\n----------------------------------------------------------------------\nRan 5 tests in 0.000s\n\nOK\n```\n\n这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试。\n\nsetUp与tearDown\n\n可以在单元测试中编写两个特殊的setUp()和tearDown()方法。这两个方法会分别在每调用一个测试方法的前后分别被执行。\n\nsetUp()和tearDown()方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在setUp()方法中连接数据库，在tearDown()方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码：\n\n``` python \nclass TestDict(unittest.TestCase):\n\n    def setUp(self):\n        print('setUp...')\n\n    def tearDown(self):\n        print('tearDown...')\n```\n\n可以再次运行测试看看每个测试方法调用前后是否会打印出setUp...和tearDown...。\n\n小结\n\n单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。\n\n单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。\n\n单元测试代码要非常简单，如果测试代码太复杂，那么测试代码本身就可能有bug。\n\n单元测试通过了并不意味着程序就没有bug了，但是不通过程序肯定有bug。","source":"_posts/单元测试.md","raw":"---\ntitle: 单元测试\ndate: 2016-04-13 20:25:47\ncategories: TDD\ntags: [单元测试, python, 敏捷开发]\n\n---\n# 单元测试\n如果你听说过“测试驱动开发”（TDD：Test-Driven Development），单元测试就不陌生。\n\n单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。\n\n比如对函数abs()，我们可以编写出以下几个测试用例：\n\n输入正数，比如1、1.2、0.99，期待返回值与输入相同；\n\n输入负数，比如-1、-1.2、-0.99，期待返回值与输入相反；\n\n输入0，期待返回0；\n\n输入非数值类型，比如None、[]、{}，期待抛出TypeError。\n\n把上面的测试用例放到一个测试模块里，就是一个完整的单元测试。\n\n如果单元测试通过，说明我们测试的这个函数能够正常工作。如果单元测试不通过，要么函数有bug，要么测试条件输入不正确，总之，需要修复使单元测试能够通过。\n\n单元测试通过后有什么意义呢？如果我们对abs()函数代码做了修改，只需要再跑一遍单元测试，如果通过，说明我们的修改不会对abs()函数原有的行为造成影响，如果测试不通过，说明我们的修改与原有行为不一致，要么修改代码，要么修改测试。\n\n这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。\n<!--more-->\n我们来编写一个Dict类，这个类的行为和dict一致，但是可以通过属性来访问，用起来就像下面这样：\n```\n\t>>> d = Dict(a=1, b=2)\n\t>>> d['a']\n\t1\n\t>>> d.a\n\t1\n```\n\nmydict.py代码如下：\n\n``` python\nclass Dict(dict):\n\n    def __init__(self, **kw):\n        super().__init__(**kw)\n\n    def __getattr__(self, key):\n        try:\n            return self[key]\n        except KeyError:\n            raise AttributeError(r\"'Dict' object has no attribute '%s'\" % key)\n\n    def __setattr__(self, key, value):\n        self[key] = value\n```\n\n为了编写单元测试，我们需要引入Python自带的unittest模块，编写mydict_test.py如下：\n\n``` python\nimport unittest\n\nfrom mydict import Dict\n\nclass TestDict(unittest.TestCase):\n\n    def test_init(self):\n        d = Dict(a=1, b='test')\n        self.assertEqual(d.a, 1)\n        self.assertEqual(d.b, 'test')\n        self.assertTrue(isinstance(d, dict))\n\n    def test_key(self):\n        d = Dict()\n        d['key'] = 'value'\n        self.assertEqual(d.key, 'value')\n\n    def test_attr(self):\n        d = Dict()\n        d.key = 'value'\n        self.assertTrue('key' in d)\n        self.assertEqual(d['key'], 'value')\n\n    def test_keyerror(self):\n        d = Dict()\n        with self.assertRaises(KeyError):\n            value = d['empty']\n\n    def test_attrerror(self):\n        d = Dict()\n        with self.assertRaises(AttributeError):\n            value = d.empty\n```\n\n编写单元测试时，我们需要编写一个测试类，从unittest.TestCase继承。\n\n以test开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。\n\n对每一类测试都需要编写一个test_xxx()方法。由于unittest.TestCase提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是assertEqual()：\n\n``` python\n\tself.assertEqual(abs(-1), 1) # 断言函数返回的结果与1相等\n```\n\n另一种重要的断言就是期待抛出指定类型的Error，比如通过d['empty']访问不存在的key时，断言会抛出KeyError：\n\n``` python\nwith self.assertRaises(KeyError):\n    value = d['empty']\n```\n\n而通过d.empty访问不存在的key时，我们期待抛出AttributeError：\n\n\n``` python\nwith self.assertRaises(AttributeError):\n    value = d.empty\n```\n\n运行单元测试\n\n一旦编写好单元测试，我们就可以运行单元测试。最简单的运行方式是在mydict_test.py的最后加上两行代码：\n\n\n``` python \nif __name__ == '__main__':\n    unittest.main()\n```\n这样就可以把mydict_test.py当做正常的python脚本运行：\n\n```\n\t$ python3 mydict_test.py\n```\n另一种方法是在命令行通过参数-m unittest直接运行单元测试：\n\n\n```\n$ python3 -m unittest mydict_test\n.....\n----------------------------------------------------------------------\nRan 5 tests in 0.000s\n\nOK\n```\n\n这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试。\n\nsetUp与tearDown\n\n可以在单元测试中编写两个特殊的setUp()和tearDown()方法。这两个方法会分别在每调用一个测试方法的前后分别被执行。\n\nsetUp()和tearDown()方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在setUp()方法中连接数据库，在tearDown()方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码：\n\n``` python \nclass TestDict(unittest.TestCase):\n\n    def setUp(self):\n        print('setUp...')\n\n    def tearDown(self):\n        print('tearDown...')\n```\n\n可以再次运行测试看看每个测试方法调用前后是否会打印出setUp...和tearDown...。\n\n小结\n\n单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。\n\n单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。\n\n单元测试代码要非常简单，如果测试代码太复杂，那么测试代码本身就可能有bug。\n\n单元测试通过了并不意味着程序就没有bug了，但是不通过程序肯定有bug。","slug":"单元测试","published":1,"updated":"2016-06-28T11:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzgzeko0014egfy1itdd1ui","content":"<h1 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h1><p>如果你听说过“测试驱动开发”（TDD：Test-Driven Development），单元测试就不陌生。</p>\n<p>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。</p>\n<p>比如对函数abs()，我们可以编写出以下几个测试用例：</p>\n<p>输入正数，比如1、1.2、0.99，期待返回值与输入相同；</p>\n<p>输入负数，比如-1、-1.2、-0.99，期待返回值与输入相反；</p>\n<p>输入0，期待返回0；</p>\n<p>输入非数值类型，比如None、[]、{}，期待抛出TypeError。</p>\n<p>把上面的测试用例放到一个测试模块里，就是一个完整的单元测试。</p>\n<p>如果单元测试通过，说明我们测试的这个函数能够正常工作。如果单元测试不通过，要么函数有bug，要么测试条件输入不正确，总之，需要修复使单元测试能够通过。</p>\n<p>单元测试通过后有什么意义呢？如果我们对abs()函数代码做了修改，只需要再跑一遍单元测试，如果通过，说明我们的修改不会对abs()函数原有的行为造成影响，如果测试不通过，说明我们的修改与原有行为不一致，要么修改代码，要么修改测试。</p>\n<p>这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。<br><a id=\"more\"></a><br>我们来编写一个Dict类，这个类的行为和dict一致，但是可以通过属性来访问，用起来就像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; d = Dict(a=1, b=2)</span><br><span class=\"line\">&gt;&gt;&gt; d[&apos;a&apos;]</span><br><span class=\"line\">1</span><br><span class=\"line\">&gt;&gt;&gt; d.a</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure></p>\n<p>mydict.py代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dict</span><span class=\"params\">(dict)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, **kw)</span>:</span></span><br><span class=\"line\">        super().__init__(**kw)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getattr__</span><span class=\"params\">(self, key)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self[key]</span><br><span class=\"line\">        <span class=\"keyword\">except</span> KeyError:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> AttributeError(<span class=\"string\">r\"'Dict' object has no attribute '%s'\"</span> % key)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__setattr__</span><span class=\"params\">(self, key, value)</span>:</span></span><br><span class=\"line\">        self[key] = value</span><br></pre></td></tr></table></figure>\n<p>为了编写单元测试，我们需要引入Python自带的unittest模块，编写mydict_test.py如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> mydict <span class=\"keyword\">import</span> Dict</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestDict</span><span class=\"params\">(unittest.TestCase)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_init</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        d = Dict(a=<span class=\"number\">1</span>, b=<span class=\"string\">'test'</span>)</span><br><span class=\"line\">        self.assertEqual(d.a, <span class=\"number\">1</span>)</span><br><span class=\"line\">        self.assertEqual(d.b, <span class=\"string\">'test'</span>)</span><br><span class=\"line\">        self.assertTrue(isinstance(d, dict))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_key</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        d = Dict()</span><br><span class=\"line\">        d[<span class=\"string\">'key'</span>] = <span class=\"string\">'value'</span></span><br><span class=\"line\">        self.assertEqual(d.key, <span class=\"string\">'value'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_attr</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        d = Dict()</span><br><span class=\"line\">        d.key = <span class=\"string\">'value'</span></span><br><span class=\"line\">        self.assertTrue(<span class=\"string\">'key'</span> <span class=\"keyword\">in</span> d)</span><br><span class=\"line\">        self.assertEqual(d[<span class=\"string\">'key'</span>], <span class=\"string\">'value'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_keyerror</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        d = Dict()</span><br><span class=\"line\">        <span class=\"keyword\">with</span> self.assertRaises(KeyError):</span><br><span class=\"line\">            value = d[<span class=\"string\">'empty'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_attrerror</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        d = Dict()</span><br><span class=\"line\">        <span class=\"keyword\">with</span> self.assertRaises(AttributeError):</span><br><span class=\"line\">            value = d.empty</span><br></pre></td></tr></table></figure>\n<p>编写单元测试时，我们需要编写一个测试类，从unittest.TestCase继承。</p>\n<p>以test开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。</p>\n<p>对每一类测试都需要编写一个test_xxx()方法。由于unittest.TestCase提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是assertEqual()：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.assertEqual(abs(<span class=\"number\">-1</span>), <span class=\"number\">1</span>) <span class=\"comment\"># 断言函数返回的结果与1相等</span></span><br></pre></td></tr></table></figure>\n<p>另一种重要的断言就是期待抛出指定类型的Error，比如通过d[‘empty’]访问不存在的key时，断言会抛出KeyError：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> self.assertRaises(KeyError):</span><br><span class=\"line\">    value = d[<span class=\"string\">'empty'</span>]</span><br></pre></td></tr></table></figure>\n<p>而通过d.empty访问不存在的key时，我们期待抛出AttributeError：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> self.assertRaises(AttributeError):</span><br><span class=\"line\">    value = d.empty</span><br></pre></td></tr></table></figure>\n<p>运行单元测试</p>\n<p>一旦编写好单元测试，我们就可以运行单元测试。最简单的运行方式是在mydict_test.py的最后加上两行代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    unittest.main()</span><br></pre></td></tr></table></figure>\n<p>这样就可以把mydict_test.py当做正常的python脚本运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ python3 mydict_test.py</span><br></pre></td></tr></table></figure>\n<p>另一种方法是在命令行通过参数-m unittest直接运行单元测试：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ python3 -m unittest mydict_test</span><br><span class=\"line\">.....</span><br><span class=\"line\">----------------------------------------------------------------------</span><br><span class=\"line\">Ran 5 tests in 0.000s</span><br><span class=\"line\"></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<p>这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试。</p>\n<p>setUp与tearDown</p>\n<p>可以在单元测试中编写两个特殊的setUp()和tearDown()方法。这两个方法会分别在每调用一个测试方法的前后分别被执行。</p>\n<p>setUp()和tearDown()方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在setUp()方法中连接数据库，在tearDown()方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestDict</span><span class=\"params\">(unittest.TestCase)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">setUp</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'setUp...'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tearDown</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'tearDown...'</span>)</span><br></pre></td></tr></table></figure>\n<p>可以再次运行测试看看每个测试方法调用前后是否会打印出setUp…和tearDown…。</p>\n<p>小结</p>\n<p>单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。</p>\n<p>单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。</p>\n<p>单元测试代码要非常简单，如果测试代码太复杂，那么测试代码本身就可能有bug。</p>\n<p>单元测试通过了并不意味着程序就没有bug了，但是不通过程序肯定有bug。</p>\n","excerpt":"<h1 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h1><p>如果你听说过“测试驱动开发”（TDD：Test-Driven Development），单元测试就不陌生。</p>\n<p>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。</p>\n<p>比如对函数abs()，我们可以编写出以下几个测试用例：</p>\n<p>输入正数，比如1、1.2、0.99，期待返回值与输入相同；</p>\n<p>输入负数，比如-1、-1.2、-0.99，期待返回值与输入相反；</p>\n<p>输入0，期待返回0；</p>\n<p>输入非数值类型，比如None、[]、{}，期待抛出TypeError。</p>\n<p>把上面的测试用例放到一个测试模块里，就是一个完整的单元测试。</p>\n<p>如果单元测试通过，说明我们测试的这个函数能够正常工作。如果单元测试不通过，要么函数有bug，要么测试条件输入不正确，总之，需要修复使单元测试能够通过。</p>\n<p>单元测试通过后有什么意义呢？如果我们对abs()函数代码做了修改，只需要再跑一遍单元测试，如果通过，说明我们的修改不会对abs()函数原有的行为造成影响，如果测试不通过，说明我们的修改与原有行为不一致，要么修改代码，要么修改测试。</p>\n<p>这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。<br>","more":"<br>我们来编写一个Dict类，这个类的行为和dict一致，但是可以通过属性来访问，用起来就像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; d = Dict(a=1, b=2)</span><br><span class=\"line\">&gt;&gt;&gt; d[&apos;a&apos;]</span><br><span class=\"line\">1</span><br><span class=\"line\">&gt;&gt;&gt; d.a</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure></p>\n<p>mydict.py代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dict</span><span class=\"params\">(dict)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, **kw)</span>:</span></span><br><span class=\"line\">        super().__init__(**kw)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getattr__</span><span class=\"params\">(self, key)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self[key]</span><br><span class=\"line\">        <span class=\"keyword\">except</span> KeyError:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> AttributeError(<span class=\"string\">r\"'Dict' object has no attribute '%s'\"</span> % key)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__setattr__</span><span class=\"params\">(self, key, value)</span>:</span></span><br><span class=\"line\">        self[key] = value</span><br></pre></td></tr></table></figure>\n<p>为了编写单元测试，我们需要引入Python自带的unittest模块，编写mydict_test.py如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> mydict <span class=\"keyword\">import</span> Dict</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestDict</span><span class=\"params\">(unittest.TestCase)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_init</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        d = Dict(a=<span class=\"number\">1</span>, b=<span class=\"string\">'test'</span>)</span><br><span class=\"line\">        self.assertEqual(d.a, <span class=\"number\">1</span>)</span><br><span class=\"line\">        self.assertEqual(d.b, <span class=\"string\">'test'</span>)</span><br><span class=\"line\">        self.assertTrue(isinstance(d, dict))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_key</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        d = Dict()</span><br><span class=\"line\">        d[<span class=\"string\">'key'</span>] = <span class=\"string\">'value'</span></span><br><span class=\"line\">        self.assertEqual(d.key, <span class=\"string\">'value'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_attr</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        d = Dict()</span><br><span class=\"line\">        d.key = <span class=\"string\">'value'</span></span><br><span class=\"line\">        self.assertTrue(<span class=\"string\">'key'</span> <span class=\"keyword\">in</span> d)</span><br><span class=\"line\">        self.assertEqual(d[<span class=\"string\">'key'</span>], <span class=\"string\">'value'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_keyerror</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        d = Dict()</span><br><span class=\"line\">        <span class=\"keyword\">with</span> self.assertRaises(KeyError):</span><br><span class=\"line\">            value = d[<span class=\"string\">'empty'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_attrerror</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        d = Dict()</span><br><span class=\"line\">        <span class=\"keyword\">with</span> self.assertRaises(AttributeError):</span><br><span class=\"line\">            value = d.empty</span><br></pre></td></tr></table></figure>\n<p>编写单元测试时，我们需要编写一个测试类，从unittest.TestCase继承。</p>\n<p>以test开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。</p>\n<p>对每一类测试都需要编写一个test_xxx()方法。由于unittest.TestCase提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是assertEqual()：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.assertEqual(abs(<span class=\"number\">-1</span>), <span class=\"number\">1</span>) <span class=\"comment\"># 断言函数返回的结果与1相等</span></span><br></pre></td></tr></table></figure>\n<p>另一种重要的断言就是期待抛出指定类型的Error，比如通过d[‘empty’]访问不存在的key时，断言会抛出KeyError：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> self.assertRaises(KeyError):</span><br><span class=\"line\">    value = d[<span class=\"string\">'empty'</span>]</span><br></pre></td></tr></table></figure>\n<p>而通过d.empty访问不存在的key时，我们期待抛出AttributeError：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> self.assertRaises(AttributeError):</span><br><span class=\"line\">    value = d.empty</span><br></pre></td></tr></table></figure>\n<p>运行单元测试</p>\n<p>一旦编写好单元测试，我们就可以运行单元测试。最简单的运行方式是在mydict_test.py的最后加上两行代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    unittest.main()</span><br></pre></td></tr></table></figure>\n<p>这样就可以把mydict_test.py当做正常的python脚本运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ python3 mydict_test.py</span><br></pre></td></tr></table></figure>\n<p>另一种方法是在命令行通过参数-m unittest直接运行单元测试：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ python3 -m unittest mydict_test</span><br><span class=\"line\">.....</span><br><span class=\"line\">----------------------------------------------------------------------</span><br><span class=\"line\">Ran 5 tests in 0.000s</span><br><span class=\"line\"></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<p>这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试。</p>\n<p>setUp与tearDown</p>\n<p>可以在单元测试中编写两个特殊的setUp()和tearDown()方法。这两个方法会分别在每调用一个测试方法的前后分别被执行。</p>\n<p>setUp()和tearDown()方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在setUp()方法中连接数据库，在tearDown()方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestDict</span><span class=\"params\">(unittest.TestCase)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">setUp</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'setUp...'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tearDown</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'tearDown...'</span>)</span><br></pre></td></tr></table></figure>\n<p>可以再次运行测试看看每个测试方法调用前后是否会打印出setUp…和tearDown…。</p>\n<p>小结</p>\n<p>单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。</p>\n<p>单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。</p>\n<p>单元测试代码要非常简单，如果测试代码太复杂，那么测试代码本身就可能有bug。</p>\n<p>单元测试通过了并不意味着程序就没有bug了，但是不通过程序肯定有bug。</p>"},{"title":"敏捷开发","date":"2016-04-19T06:41:46.000Z","_content":"# 敏捷开发\n\n敏捷开发是一种以人为核心、迭代、循序渐进的开发方法。在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。\n <!-- more -->\n![123.jpg](http://img.blog.csdn.net/20140328151407843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n## Test-Driven Development，测试驱动开发。\n　　它是敏捷开发的最重要的部分。在ThoughtWorks，我们实现任何一个功能都是从测试开始，首先对业务需求进行分析，分解为一个一个的Story，记录在Story Card上。然后两个人同时坐在电脑前面，一个人依照Story，从业务需求的角度来编写测试代码，另一个人看着他并且进行思考，如果有不同的意见就会提出来进行讨论，直到达成共识，这样写出来的测试代码就真实反映了业务功能需求。接着由另一个人控制键盘，编写该测试代码的实现。如果没有测试代码，就不能编写功能的实现代码。先写测试代码，能够让开发人员明确目标，就是让测试通过。\n## Continuous Integration，持续集成。\n　　在以往的软件开发过程中，集成是一件很痛苦的事情，通常很长时间才会做一次集成，这样的话，会引发很多问题，比如 build未通过或者单元测试失败。敏捷开发中提倡持续集成，一天之内集成十几次甚至几十次，如此频繁的集成能尽量减少冲突，由于集成很频繁，每一次集成的改变也很少，即使集成失败也容易定位错误。一次集成要做哪些事情呢？它至少包括：获得所有源代码、编译源代码、运行所有测试，包括单元测试、功能测试等；确认编译和测试是否通过，最后发送报告。当然也会做一些其它的任务，比如说代码分析、测试覆盖率分析等等。\n## Refactoring，重构。\n　　相信大家对它都很熟悉了，有很多很多的书用来介绍重构，最著名的是Martin的《重构》，Joshua的《从重构到模式》等。重构是在不改变系统外部行为下，对内部结构进行整理优化，使得代码尽量简单、优美、可扩展。在以往开发中，通常是在有需求过来，现在的系统架构不容易实现，从而对原有系统进行重构；或者在开发过程中有剩余时间了，对现在代码进行重构整理。但是在敏捷开发中，重构贯穿于整个开发流程，每一次开发者check in代码之前，都要对所写代码进行重构，让代码达到clean code that works。值得注意的是，在重构时，每一次改变要尽可能小，用单元测试来保证重构是否引起冲突，并且不只是对实现代码进行重构，如果测试代码中有重复，也要对它进行重构。\n## Pair-Programming，结对编程。\n　　在敏捷开发中，做任何事情都是Pair的，包括分析、写测试、写实现代码或者重构。Pair做事有很多好处，两个人在一起探讨很容易产生思想的火花，也不容易走上偏路。在我们公司，还有很多事都是Pair来做，比如Pair学习，Pair翻译，Pair做PPT，关于这个话题，钱钱同学有一篇很有名的文章对它进行介绍，名为Pair Programming (结对编程)。\n## Stand meeting，站立会议。\n　　每天早上，项目组的所有成员都会站立进行一次会议，由于是站立的，所以时间不会很长，一般来说是15-20分钟。会议的内容并不是需求分析、任务分配等，而是每个人都回答三个问题：1. 你昨天做了什么？2. 你今天要做什么？ 3. 你遇到了哪些困难？站立会议让团队进行交流，彼此相互熟悉工作内容，如果有人曾经遇到过和你类似的问题，那么在站立会议后，他就会和你进行讨论。\n## Frequent Releases，小版本发布。\n　　在敏捷开发中，不会出现这种情况，拿到需求以后就闭门造车，直到最后才将产品交付给客户，而是尽量多的产品发布，一般以周、月为单位。这样，客户每隔一段时间就会拿到发布的产品进行试用，而我们可以从客户那得到更多的反馈来改进产品。正因为发布频繁，每一个版本新增的功能简单，不需要复杂的设计，这样文档和设计就在很大程度上简化了。又因为简单设计，没有复杂的架构，所以客户有新的需求或者需求进行变动，也能很快的适应。\n## Minimal Documentation，较少的文档。\n　　其实敏捷开发中并不是没有文档，而是有大量的文档，即测试。这些测试代码真实的反应了客户的需求以及系统API 的用法，如果有新人加入团队，最快的熟悉项目的方法就是给他看测试代码，而比一边看着文档一边进行debug要高效。如果用书面文档或者注释，某天代码变化了，需要对这些文档进行更新。一旦忘记更新文档，就会出现代码和文档不匹配的情况，这更加会让人迷惑。而在敏捷中并不会出现，因为只有测试变化了，代码才会变化，测试是真实反应代码的。这时有人会问：代码不写注释行吗？一般来说好的代码不是需要大量的注释吗？其实简单可读的代码才是好的代码，既然简单可读了，别人一看就能够看懂，这时候根本不需要对代码进行任何注释。若你觉得这段代码不加注释的话别人可能看不懂，就表示设计还不够简单，需要对它进行重构。\n## Collaborative Focus，以合作为中心，表现为代码共享。\n　　在敏捷开发中，代码是归团队所有而不是哪些模块的代码属于哪些人，每个人都有权利获得系统任何一部分的代码然后修改它，如果有人看到某些代码不爽的话，那他能够对这部分代码重构而不需要征求代码作者的同意，很可能也不知道是谁写的这部分代码。这样每个人都能熟悉系统的代码，即使团队的人员变动，也没有风险。\n## Customer Engagement ，现场客户。\n　　敏捷开发中，客户是与开发团队一起工作的，团队到客户现场进行开发或者邀请客户到团队公司里来开发。如果开发过程中有什么问题或者产品经过一个迭代后，能够以最快速度得到客户的反馈。\n## Automated Testing ，自动化测试。\n　　为了减小人力或者重复劳动，所有的测试包括单元测试、功能测试或集成测试等都是自动化的，这对QA人员提出了更高的要求。他们要熟悉开发语言、自动化测试工具，能够编写自动化测试脚本或者用工具录制。我们公司在自动化测试上做了大量的工作，包括Selenium开源项目。\n## Adaptive Planning，可调整计划。\n　　敏捷开发中计划是可调整的，并不是像以往的开发过程中，需求分析->概要设计->详细设计->开发 ->测试->交付，每一个阶段都是有计划的进行，一个阶段结束便开始下一个阶段。而敏捷开发中只有一次一次的迭代，小版本的发布，根据客户反馈随时作出相应的调整和变化。\n　　\n\n   敏捷开发过程与传统的开发过程有很大不同，在这过程中，团队是有激情有活力的，能适应更大的变化，做出更高质量的软件。\t\t\n\n## 敏捷宣言：四中核心价值观和十二条原则\n我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观：\n个体和互动 高于 流程和工具\n工作的软件 高于 详尽的文档\n客户合作 高于 合同谈判\n响应变化 高于 遵循计划\n也就是说，尽管右项有其价值，我们更重视左项的价值。\n我们遵循以下原则：\n我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。\n欣然面对需求变化，即使在开发后期也一样。善于掌控变化，帮助客户获得竞争优势。\n经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。\n业务人员和开发人员必须相互合作，项目中的每一天都不例外。\n激发个体的斗志，以他们为核心搭建项目。提供他们所需的环境和支持，相信他们能够达成目标。\n不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。\n可工作的软件是进度的首要度量标准。\n敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。\n对技术精益求精，对设计不断完善，将提高敏捷能力。\n以简洁为本，极力减少不必要工作量。\n最好的架构、需求和设计出自于自组织的团队。\n团队定期地反思如何能提高成效，并依此调整团队的行为。\n\n[原文链接1](http://blog.csdn.net/burningsheep/article/details/7725181)\n[原文链接2](http://blog.csdn.net/liuchunming033/article/details/22407569)","source":"_posts/敏捷开发.md","raw":"---\ntitle: 敏捷开发\ndate: 2016-04-19 14:41:46\ncategories: TDD\ntags: [敏捷开发, thoughtworks面试]\n\n---\n# 敏捷开发\n\n敏捷开发是一种以人为核心、迭代、循序渐进的开发方法。在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。\n <!-- more -->\n![123.jpg](http://img.blog.csdn.net/20140328151407843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n## Test-Driven Development，测试驱动开发。\n　　它是敏捷开发的最重要的部分。在ThoughtWorks，我们实现任何一个功能都是从测试开始，首先对业务需求进行分析，分解为一个一个的Story，记录在Story Card上。然后两个人同时坐在电脑前面，一个人依照Story，从业务需求的角度来编写测试代码，另一个人看着他并且进行思考，如果有不同的意见就会提出来进行讨论，直到达成共识，这样写出来的测试代码就真实反映了业务功能需求。接着由另一个人控制键盘，编写该测试代码的实现。如果没有测试代码，就不能编写功能的实现代码。先写测试代码，能够让开发人员明确目标，就是让测试通过。\n## Continuous Integration，持续集成。\n　　在以往的软件开发过程中，集成是一件很痛苦的事情，通常很长时间才会做一次集成，这样的话，会引发很多问题，比如 build未通过或者单元测试失败。敏捷开发中提倡持续集成，一天之内集成十几次甚至几十次，如此频繁的集成能尽量减少冲突，由于集成很频繁，每一次集成的改变也很少，即使集成失败也容易定位错误。一次集成要做哪些事情呢？它至少包括：获得所有源代码、编译源代码、运行所有测试，包括单元测试、功能测试等；确认编译和测试是否通过，最后发送报告。当然也会做一些其它的任务，比如说代码分析、测试覆盖率分析等等。\n## Refactoring，重构。\n　　相信大家对它都很熟悉了，有很多很多的书用来介绍重构，最著名的是Martin的《重构》，Joshua的《从重构到模式》等。重构是在不改变系统外部行为下，对内部结构进行整理优化，使得代码尽量简单、优美、可扩展。在以往开发中，通常是在有需求过来，现在的系统架构不容易实现，从而对原有系统进行重构；或者在开发过程中有剩余时间了，对现在代码进行重构整理。但是在敏捷开发中，重构贯穿于整个开发流程，每一次开发者check in代码之前，都要对所写代码进行重构，让代码达到clean code that works。值得注意的是，在重构时，每一次改变要尽可能小，用单元测试来保证重构是否引起冲突，并且不只是对实现代码进行重构，如果测试代码中有重复，也要对它进行重构。\n## Pair-Programming，结对编程。\n　　在敏捷开发中，做任何事情都是Pair的，包括分析、写测试、写实现代码或者重构。Pair做事有很多好处，两个人在一起探讨很容易产生思想的火花，也不容易走上偏路。在我们公司，还有很多事都是Pair来做，比如Pair学习，Pair翻译，Pair做PPT，关于这个话题，钱钱同学有一篇很有名的文章对它进行介绍，名为Pair Programming (结对编程)。\n## Stand meeting，站立会议。\n　　每天早上，项目组的所有成员都会站立进行一次会议，由于是站立的，所以时间不会很长，一般来说是15-20分钟。会议的内容并不是需求分析、任务分配等，而是每个人都回答三个问题：1. 你昨天做了什么？2. 你今天要做什么？ 3. 你遇到了哪些困难？站立会议让团队进行交流，彼此相互熟悉工作内容，如果有人曾经遇到过和你类似的问题，那么在站立会议后，他就会和你进行讨论。\n## Frequent Releases，小版本发布。\n　　在敏捷开发中，不会出现这种情况，拿到需求以后就闭门造车，直到最后才将产品交付给客户，而是尽量多的产品发布，一般以周、月为单位。这样，客户每隔一段时间就会拿到发布的产品进行试用，而我们可以从客户那得到更多的反馈来改进产品。正因为发布频繁，每一个版本新增的功能简单，不需要复杂的设计，这样文档和设计就在很大程度上简化了。又因为简单设计，没有复杂的架构，所以客户有新的需求或者需求进行变动，也能很快的适应。\n## Minimal Documentation，较少的文档。\n　　其实敏捷开发中并不是没有文档，而是有大量的文档，即测试。这些测试代码真实的反应了客户的需求以及系统API 的用法，如果有新人加入团队，最快的熟悉项目的方法就是给他看测试代码，而比一边看着文档一边进行debug要高效。如果用书面文档或者注释，某天代码变化了，需要对这些文档进行更新。一旦忘记更新文档，就会出现代码和文档不匹配的情况，这更加会让人迷惑。而在敏捷中并不会出现，因为只有测试变化了，代码才会变化，测试是真实反应代码的。这时有人会问：代码不写注释行吗？一般来说好的代码不是需要大量的注释吗？其实简单可读的代码才是好的代码，既然简单可读了，别人一看就能够看懂，这时候根本不需要对代码进行任何注释。若你觉得这段代码不加注释的话别人可能看不懂，就表示设计还不够简单，需要对它进行重构。\n## Collaborative Focus，以合作为中心，表现为代码共享。\n　　在敏捷开发中，代码是归团队所有而不是哪些模块的代码属于哪些人，每个人都有权利获得系统任何一部分的代码然后修改它，如果有人看到某些代码不爽的话，那他能够对这部分代码重构而不需要征求代码作者的同意，很可能也不知道是谁写的这部分代码。这样每个人都能熟悉系统的代码，即使团队的人员变动，也没有风险。\n## Customer Engagement ，现场客户。\n　　敏捷开发中，客户是与开发团队一起工作的，团队到客户现场进行开发或者邀请客户到团队公司里来开发。如果开发过程中有什么问题或者产品经过一个迭代后，能够以最快速度得到客户的反馈。\n## Automated Testing ，自动化测试。\n　　为了减小人力或者重复劳动，所有的测试包括单元测试、功能测试或集成测试等都是自动化的，这对QA人员提出了更高的要求。他们要熟悉开发语言、自动化测试工具，能够编写自动化测试脚本或者用工具录制。我们公司在自动化测试上做了大量的工作，包括Selenium开源项目。\n## Adaptive Planning，可调整计划。\n　　敏捷开发中计划是可调整的，并不是像以往的开发过程中，需求分析->概要设计->详细设计->开发 ->测试->交付，每一个阶段都是有计划的进行，一个阶段结束便开始下一个阶段。而敏捷开发中只有一次一次的迭代，小版本的发布，根据客户反馈随时作出相应的调整和变化。\n　　\n\n   敏捷开发过程与传统的开发过程有很大不同，在这过程中，团队是有激情有活力的，能适应更大的变化，做出更高质量的软件。\t\t\n\n## 敏捷宣言：四中核心价值观和十二条原则\n我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观：\n个体和互动 高于 流程和工具\n工作的软件 高于 详尽的文档\n客户合作 高于 合同谈判\n响应变化 高于 遵循计划\n也就是说，尽管右项有其价值，我们更重视左项的价值。\n我们遵循以下原则：\n我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。\n欣然面对需求变化，即使在开发后期也一样。善于掌控变化，帮助客户获得竞争优势。\n经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。\n业务人员和开发人员必须相互合作，项目中的每一天都不例外。\n激发个体的斗志，以他们为核心搭建项目。提供他们所需的环境和支持，相信他们能够达成目标。\n不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。\n可工作的软件是进度的首要度量标准。\n敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。\n对技术精益求精，对设计不断完善，将提高敏捷能力。\n以简洁为本，极力减少不必要工作量。\n最好的架构、需求和设计出自于自组织的团队。\n团队定期地反思如何能提高成效，并依此调整团队的行为。\n\n[原文链接1](http://blog.csdn.net/burningsheep/article/details/7725181)\n[原文链接2](http://blog.csdn.net/liuchunming033/article/details/22407569)","slug":"敏捷开发","published":1,"updated":"2016-06-28T11:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzgzekq0018egfy4dr8u0lz","content":"<h1 id=\"敏捷开发\"><a href=\"#敏捷开发\" class=\"headerlink\" title=\"敏捷开发\"></a>敏捷开发</h1><p>敏捷开发是一种以人为核心、迭代、循序渐进的开发方法。在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。<br> <a id=\"more\"></a><br><img src=\"http://img.blog.csdn.net/20140328151407843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"123.jpg\"></p>\n<h2 id=\"Test-Driven-Development，测试驱动开发。\"><a href=\"#Test-Driven-Development，测试驱动开发。\" class=\"headerlink\" title=\"Test-Driven Development，测试驱动开发。\"></a>Test-Driven Development，测试驱动开发。</h2><p>　　它是敏捷开发的最重要的部分。在ThoughtWorks，我们实现任何一个功能都是从测试开始，首先对业务需求进行分析，分解为一个一个的Story，记录在Story Card上。然后两个人同时坐在电脑前面，一个人依照Story，从业务需求的角度来编写测试代码，另一个人看着他并且进行思考，如果有不同的意见就会提出来进行讨论，直到达成共识，这样写出来的测试代码就真实反映了业务功能需求。接着由另一个人控制键盘，编写该测试代码的实现。如果没有测试代码，就不能编写功能的实现代码。先写测试代码，能够让开发人员明确目标，就是让测试通过。</p>\n<h2 id=\"Continuous-Integration，持续集成。\"><a href=\"#Continuous-Integration，持续集成。\" class=\"headerlink\" title=\"Continuous Integration，持续集成。\"></a>Continuous Integration，持续集成。</h2><p>　　在以往的软件开发过程中，集成是一件很痛苦的事情，通常很长时间才会做一次集成，这样的话，会引发很多问题，比如 build未通过或者单元测试失败。敏捷开发中提倡持续集成，一天之内集成十几次甚至几十次，如此频繁的集成能尽量减少冲突，由于集成很频繁，每一次集成的改变也很少，即使集成失败也容易定位错误。一次集成要做哪些事情呢？它至少包括：获得所有源代码、编译源代码、运行所有测试，包括单元测试、功能测试等；确认编译和测试是否通过，最后发送报告。当然也会做一些其它的任务，比如说代码分析、测试覆盖率分析等等。</p>\n<h2 id=\"Refactoring，重构。\"><a href=\"#Refactoring，重构。\" class=\"headerlink\" title=\"Refactoring，重构。\"></a>Refactoring，重构。</h2><p>　　相信大家对它都很熟悉了，有很多很多的书用来介绍重构，最著名的是Martin的《重构》，Joshua的《从重构到模式》等。重构是在不改变系统外部行为下，对内部结构进行整理优化，使得代码尽量简单、优美、可扩展。在以往开发中，通常是在有需求过来，现在的系统架构不容易实现，从而对原有系统进行重构；或者在开发过程中有剩余时间了，对现在代码进行重构整理。但是在敏捷开发中，重构贯穿于整个开发流程，每一次开发者check in代码之前，都要对所写代码进行重构，让代码达到clean code that works。值得注意的是，在重构时，每一次改变要尽可能小，用单元测试来保证重构是否引起冲突，并且不只是对实现代码进行重构，如果测试代码中有重复，也要对它进行重构。</p>\n<h2 id=\"Pair-Programming，结对编程。\"><a href=\"#Pair-Programming，结对编程。\" class=\"headerlink\" title=\"Pair-Programming，结对编程。\"></a>Pair-Programming，结对编程。</h2><p>　　在敏捷开发中，做任何事情都是Pair的，包括分析、写测试、写实现代码或者重构。Pair做事有很多好处，两个人在一起探讨很容易产生思想的火花，也不容易走上偏路。在我们公司，还有很多事都是Pair来做，比如Pair学习，Pair翻译，Pair做PPT，关于这个话题，钱钱同学有一篇很有名的文章对它进行介绍，名为Pair Programming (结对编程)。</p>\n<h2 id=\"Stand-meeting，站立会议。\"><a href=\"#Stand-meeting，站立会议。\" class=\"headerlink\" title=\"Stand meeting，站立会议。\"></a>Stand meeting，站立会议。</h2><p>　　每天早上，项目组的所有成员都会站立进行一次会议，由于是站立的，所以时间不会很长，一般来说是15-20分钟。会议的内容并不是需求分析、任务分配等，而是每个人都回答三个问题：1. 你昨天做了什么？2. 你今天要做什么？ 3. 你遇到了哪些困难？站立会议让团队进行交流，彼此相互熟悉工作内容，如果有人曾经遇到过和你类似的问题，那么在站立会议后，他就会和你进行讨论。</p>\n<h2 id=\"Frequent-Releases，小版本发布。\"><a href=\"#Frequent-Releases，小版本发布。\" class=\"headerlink\" title=\"Frequent Releases，小版本发布。\"></a>Frequent Releases，小版本发布。</h2><p>　　在敏捷开发中，不会出现这种情况，拿到需求以后就闭门造车，直到最后才将产品交付给客户，而是尽量多的产品发布，一般以周、月为单位。这样，客户每隔一段时间就会拿到发布的产品进行试用，而我们可以从客户那得到更多的反馈来改进产品。正因为发布频繁，每一个版本新增的功能简单，不需要复杂的设计，这样文档和设计就在很大程度上简化了。又因为简单设计，没有复杂的架构，所以客户有新的需求或者需求进行变动，也能很快的适应。</p>\n<h2 id=\"Minimal-Documentation，较少的文档。\"><a href=\"#Minimal-Documentation，较少的文档。\" class=\"headerlink\" title=\"Minimal Documentation，较少的文档。\"></a>Minimal Documentation，较少的文档。</h2><p>　　其实敏捷开发中并不是没有文档，而是有大量的文档，即测试。这些测试代码真实的反应了客户的需求以及系统API 的用法，如果有新人加入团队，最快的熟悉项目的方法就是给他看测试代码，而比一边看着文档一边进行debug要高效。如果用书面文档或者注释，某天代码变化了，需要对这些文档进行更新。一旦忘记更新文档，就会出现代码和文档不匹配的情况，这更加会让人迷惑。而在敏捷中并不会出现，因为只有测试变化了，代码才会变化，测试是真实反应代码的。这时有人会问：代码不写注释行吗？一般来说好的代码不是需要大量的注释吗？其实简单可读的代码才是好的代码，既然简单可读了，别人一看就能够看懂，这时候根本不需要对代码进行任何注释。若你觉得这段代码不加注释的话别人可能看不懂，就表示设计还不够简单，需要对它进行重构。</p>\n<h2 id=\"Collaborative-Focus，以合作为中心，表现为代码共享。\"><a href=\"#Collaborative-Focus，以合作为中心，表现为代码共享。\" class=\"headerlink\" title=\"Collaborative Focus，以合作为中心，表现为代码共享。\"></a>Collaborative Focus，以合作为中心，表现为代码共享。</h2><p>　　在敏捷开发中，代码是归团队所有而不是哪些模块的代码属于哪些人，每个人都有权利获得系统任何一部分的代码然后修改它，如果有人看到某些代码不爽的话，那他能够对这部分代码重构而不需要征求代码作者的同意，很可能也不知道是谁写的这部分代码。这样每个人都能熟悉系统的代码，即使团队的人员变动，也没有风险。</p>\n<h2 id=\"Customer-Engagement-，现场客户。\"><a href=\"#Customer-Engagement-，现场客户。\" class=\"headerlink\" title=\"Customer Engagement ，现场客户。\"></a>Customer Engagement ，现场客户。</h2><p>　　敏捷开发中，客户是与开发团队一起工作的，团队到客户现场进行开发或者邀请客户到团队公司里来开发。如果开发过程中有什么问题或者产品经过一个迭代后，能够以最快速度得到客户的反馈。</p>\n<h2 id=\"Automated-Testing-，自动化测试。\"><a href=\"#Automated-Testing-，自动化测试。\" class=\"headerlink\" title=\"Automated Testing ，自动化测试。\"></a>Automated Testing ，自动化测试。</h2><p>　　为了减小人力或者重复劳动，所有的测试包括单元测试、功能测试或集成测试等都是自动化的，这对QA人员提出了更高的要求。他们要熟悉开发语言、自动化测试工具，能够编写自动化测试脚本或者用工具录制。我们公司在自动化测试上做了大量的工作，包括Selenium开源项目。</p>\n<h2 id=\"Adaptive-Planning，可调整计划。\"><a href=\"#Adaptive-Planning，可调整计划。\" class=\"headerlink\" title=\"Adaptive Planning，可调整计划。\"></a>Adaptive Planning，可调整计划。</h2><p>　　敏捷开发中计划是可调整的，并不是像以往的开发过程中，需求分析-&gt;概要设计-&gt;详细设计-&gt;开发 -&gt;测试-&gt;交付，每一个阶段都是有计划的进行，一个阶段结束便开始下一个阶段。而敏捷开发中只有一次一次的迭代，小版本的发布，根据客户反馈随时作出相应的调整和变化。\n　　</p>\n<p>   敏捷开发过程与传统的开发过程有很大不同，在这过程中，团队是有激情有活力的，能适应更大的变化，做出更高质量的软件。        </p>\n<h2 id=\"敏捷宣言：四中核心价值观和十二条原则\"><a href=\"#敏捷宣言：四中核心价值观和十二条原则\" class=\"headerlink\" title=\"敏捷宣言：四中核心价值观和十二条原则\"></a>敏捷宣言：四中核心价值观和十二条原则</h2><p>我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观：<br>个体和互动 高于 流程和工具<br>工作的软件 高于 详尽的文档<br>客户合作 高于 合同谈判<br>响应变化 高于 遵循计划<br>也就是说，尽管右项有其价值，我们更重视左项的价值。<br>我们遵循以下原则：<br>我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。<br>欣然面对需求变化，即使在开发后期也一样。善于掌控变化，帮助客户获得竞争优势。<br>经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。<br>业务人员和开发人员必须相互合作，项目中的每一天都不例外。<br>激发个体的斗志，以他们为核心搭建项目。提供他们所需的环境和支持，相信他们能够达成目标。<br>不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。<br>可工作的软件是进度的首要度量标准。<br>敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。<br>对技术精益求精，对设计不断完善，将提高敏捷能力。<br>以简洁为本，极力减少不必要工作量。<br>最好的架构、需求和设计出自于自组织的团队。<br>团队定期地反思如何能提高成效，并依此调整团队的行为。</p>\n<p><a href=\"http://blog.csdn.net/burningsheep/article/details/7725181\" target=\"_blank\" rel=\"external\">原文链接1</a><br><a href=\"http://blog.csdn.net/liuchunming033/article/details/22407569\" target=\"_blank\" rel=\"external\">原文链接2</a></p>\n","excerpt":"<h1 id=\"敏捷开发\"><a href=\"#敏捷开发\" class=\"headerlink\" title=\"敏捷开发\"></a>敏捷开发</h1><p>敏捷开发是一种以人为核心、迭代、循序渐进的开发方法。在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。<br>","more":"<br><img src=\"http://img.blog.csdn.net/20140328151407843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"123.jpg\"></p>\n<h2 id=\"Test-Driven-Development，测试驱动开发。\"><a href=\"#Test-Driven-Development，测试驱动开发。\" class=\"headerlink\" title=\"Test-Driven Development，测试驱动开发。\"></a>Test-Driven Development，测试驱动开发。</h2><p>　　它是敏捷开发的最重要的部分。在ThoughtWorks，我们实现任何一个功能都是从测试开始，首先对业务需求进行分析，分解为一个一个的Story，记录在Story Card上。然后两个人同时坐在电脑前面，一个人依照Story，从业务需求的角度来编写测试代码，另一个人看着他并且进行思考，如果有不同的意见就会提出来进行讨论，直到达成共识，这样写出来的测试代码就真实反映了业务功能需求。接着由另一个人控制键盘，编写该测试代码的实现。如果没有测试代码，就不能编写功能的实现代码。先写测试代码，能够让开发人员明确目标，就是让测试通过。</p>\n<h2 id=\"Continuous-Integration，持续集成。\"><a href=\"#Continuous-Integration，持续集成。\" class=\"headerlink\" title=\"Continuous Integration，持续集成。\"></a>Continuous Integration，持续集成。</h2><p>　　在以往的软件开发过程中，集成是一件很痛苦的事情，通常很长时间才会做一次集成，这样的话，会引发很多问题，比如 build未通过或者单元测试失败。敏捷开发中提倡持续集成，一天之内集成十几次甚至几十次，如此频繁的集成能尽量减少冲突，由于集成很频繁，每一次集成的改变也很少，即使集成失败也容易定位错误。一次集成要做哪些事情呢？它至少包括：获得所有源代码、编译源代码、运行所有测试，包括单元测试、功能测试等；确认编译和测试是否通过，最后发送报告。当然也会做一些其它的任务，比如说代码分析、测试覆盖率分析等等。</p>\n<h2 id=\"Refactoring，重构。\"><a href=\"#Refactoring，重构。\" class=\"headerlink\" title=\"Refactoring，重构。\"></a>Refactoring，重构。</h2><p>　　相信大家对它都很熟悉了，有很多很多的书用来介绍重构，最著名的是Martin的《重构》，Joshua的《从重构到模式》等。重构是在不改变系统外部行为下，对内部结构进行整理优化，使得代码尽量简单、优美、可扩展。在以往开发中，通常是在有需求过来，现在的系统架构不容易实现，从而对原有系统进行重构；或者在开发过程中有剩余时间了，对现在代码进行重构整理。但是在敏捷开发中，重构贯穿于整个开发流程，每一次开发者check in代码之前，都要对所写代码进行重构，让代码达到clean code that works。值得注意的是，在重构时，每一次改变要尽可能小，用单元测试来保证重构是否引起冲突，并且不只是对实现代码进行重构，如果测试代码中有重复，也要对它进行重构。</p>\n<h2 id=\"Pair-Programming，结对编程。\"><a href=\"#Pair-Programming，结对编程。\" class=\"headerlink\" title=\"Pair-Programming，结对编程。\"></a>Pair-Programming，结对编程。</h2><p>　　在敏捷开发中，做任何事情都是Pair的，包括分析、写测试、写实现代码或者重构。Pair做事有很多好处，两个人在一起探讨很容易产生思想的火花，也不容易走上偏路。在我们公司，还有很多事都是Pair来做，比如Pair学习，Pair翻译，Pair做PPT，关于这个话题，钱钱同学有一篇很有名的文章对它进行介绍，名为Pair Programming (结对编程)。</p>\n<h2 id=\"Stand-meeting，站立会议。\"><a href=\"#Stand-meeting，站立会议。\" class=\"headerlink\" title=\"Stand meeting，站立会议。\"></a>Stand meeting，站立会议。</h2><p>　　每天早上，项目组的所有成员都会站立进行一次会议，由于是站立的，所以时间不会很长，一般来说是15-20分钟。会议的内容并不是需求分析、任务分配等，而是每个人都回答三个问题：1. 你昨天做了什么？2. 你今天要做什么？ 3. 你遇到了哪些困难？站立会议让团队进行交流，彼此相互熟悉工作内容，如果有人曾经遇到过和你类似的问题，那么在站立会议后，他就会和你进行讨论。</p>\n<h2 id=\"Frequent-Releases，小版本发布。\"><a href=\"#Frequent-Releases，小版本发布。\" class=\"headerlink\" title=\"Frequent Releases，小版本发布。\"></a>Frequent Releases，小版本发布。</h2><p>　　在敏捷开发中，不会出现这种情况，拿到需求以后就闭门造车，直到最后才将产品交付给客户，而是尽量多的产品发布，一般以周、月为单位。这样，客户每隔一段时间就会拿到发布的产品进行试用，而我们可以从客户那得到更多的反馈来改进产品。正因为发布频繁，每一个版本新增的功能简单，不需要复杂的设计，这样文档和设计就在很大程度上简化了。又因为简单设计，没有复杂的架构，所以客户有新的需求或者需求进行变动，也能很快的适应。</p>\n<h2 id=\"Minimal-Documentation，较少的文档。\"><a href=\"#Minimal-Documentation，较少的文档。\" class=\"headerlink\" title=\"Minimal Documentation，较少的文档。\"></a>Minimal Documentation，较少的文档。</h2><p>　　其实敏捷开发中并不是没有文档，而是有大量的文档，即测试。这些测试代码真实的反应了客户的需求以及系统API 的用法，如果有新人加入团队，最快的熟悉项目的方法就是给他看测试代码，而比一边看着文档一边进行debug要高效。如果用书面文档或者注释，某天代码变化了，需要对这些文档进行更新。一旦忘记更新文档，就会出现代码和文档不匹配的情况，这更加会让人迷惑。而在敏捷中并不会出现，因为只有测试变化了，代码才会变化，测试是真实反应代码的。这时有人会问：代码不写注释行吗？一般来说好的代码不是需要大量的注释吗？其实简单可读的代码才是好的代码，既然简单可读了，别人一看就能够看懂，这时候根本不需要对代码进行任何注释。若你觉得这段代码不加注释的话别人可能看不懂，就表示设计还不够简单，需要对它进行重构。</p>\n<h2 id=\"Collaborative-Focus，以合作为中心，表现为代码共享。\"><a href=\"#Collaborative-Focus，以合作为中心，表现为代码共享。\" class=\"headerlink\" title=\"Collaborative Focus，以合作为中心，表现为代码共享。\"></a>Collaborative Focus，以合作为中心，表现为代码共享。</h2><p>　　在敏捷开发中，代码是归团队所有而不是哪些模块的代码属于哪些人，每个人都有权利获得系统任何一部分的代码然后修改它，如果有人看到某些代码不爽的话，那他能够对这部分代码重构而不需要征求代码作者的同意，很可能也不知道是谁写的这部分代码。这样每个人都能熟悉系统的代码，即使团队的人员变动，也没有风险。</p>\n<h2 id=\"Customer-Engagement-，现场客户。\"><a href=\"#Customer-Engagement-，现场客户。\" class=\"headerlink\" title=\"Customer Engagement ，现场客户。\"></a>Customer Engagement ，现场客户。</h2><p>　　敏捷开发中，客户是与开发团队一起工作的，团队到客户现场进行开发或者邀请客户到团队公司里来开发。如果开发过程中有什么问题或者产品经过一个迭代后，能够以最快速度得到客户的反馈。</p>\n<h2 id=\"Automated-Testing-，自动化测试。\"><a href=\"#Automated-Testing-，自动化测试。\" class=\"headerlink\" title=\"Automated Testing ，自动化测试。\"></a>Automated Testing ，自动化测试。</h2><p>　　为了减小人力或者重复劳动，所有的测试包括单元测试、功能测试或集成测试等都是自动化的，这对QA人员提出了更高的要求。他们要熟悉开发语言、自动化测试工具，能够编写自动化测试脚本或者用工具录制。我们公司在自动化测试上做了大量的工作，包括Selenium开源项目。</p>\n<h2 id=\"Adaptive-Planning，可调整计划。\"><a href=\"#Adaptive-Planning，可调整计划。\" class=\"headerlink\" title=\"Adaptive Planning，可调整计划。\"></a>Adaptive Planning，可调整计划。</h2><p>　　敏捷开发中计划是可调整的，并不是像以往的开发过程中，需求分析-&gt;概要设计-&gt;详细设计-&gt;开发 -&gt;测试-&gt;交付，每一个阶段都是有计划的进行，一个阶段结束便开始下一个阶段。而敏捷开发中只有一次一次的迭代，小版本的发布，根据客户反馈随时作出相应的调整和变化。\n　　</p>\n<p>   敏捷开发过程与传统的开发过程有很大不同，在这过程中，团队是有激情有活力的，能适应更大的变化，做出更高质量的软件。        </p>\n<h2 id=\"敏捷宣言：四中核心价值观和十二条原则\"><a href=\"#敏捷宣言：四中核心价值观和十二条原则\" class=\"headerlink\" title=\"敏捷宣言：四中核心价值观和十二条原则\"></a>敏捷宣言：四中核心价值观和十二条原则</h2><p>我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观：<br>个体和互动 高于 流程和工具<br>工作的软件 高于 详尽的文档<br>客户合作 高于 合同谈判<br>响应变化 高于 遵循计划<br>也就是说，尽管右项有其价值，我们更重视左项的价值。<br>我们遵循以下原则：<br>我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。<br>欣然面对需求变化，即使在开发后期也一样。善于掌控变化，帮助客户获得竞争优势。<br>经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。<br>业务人员和开发人员必须相互合作，项目中的每一天都不例外。<br>激发个体的斗志，以他们为核心搭建项目。提供他们所需的环境和支持，相信他们能够达成目标。<br>不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。<br>可工作的软件是进度的首要度量标准。<br>敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。<br>对技术精益求精，对设计不断完善，将提高敏捷能力。<br>以简洁为本，极力减少不必要工作量。<br>最好的架构、需求和设计出自于自组织的团队。<br>团队定期地反思如何能提高成效，并依此调整团队的行为。</p>\n<p><a href=\"http://blog.csdn.net/burningsheep/article/details/7725181\">原文链接1</a><br><a href=\"http://blog.csdn.net/liuchunming033/article/details/22407569\">原文链接2</a></p>"},{"title":"程序员入门之git","date":"2016-05-29T02:49:08.000Z","_content":"# 代码版本管理工具\n在生产环境下的开发过程中，一个工程的代码通常是有多个程序员协同完成，这就涉及到代码在不通终端的同步问题，基于此需求，我们产生了代码版本工具，目前比较主流的两种为git和SVN\n<!-- more -->\n## git 与 SVN\n关于git和SVN的区别，网上有很多，根据笔者使用的经验，感觉git还是要比SVN先进一些，首先git是一个分布式版本管理系统，SVN更像是一个储存代码的仓库，管理员可以给不同的代码提交者提供不同的权限，仅此而已。git于SVN相比明显的优势在于不依赖网络，对分支管理有更好的支持，命令行简介好用（SVN也有命令行工具，但很多公司还是采用图形化界面）\n\n## git介绍\ngit是Linux的创始人Linus于2005年花了大概两周时间用C语言编写的分布式版本控制系统。\n\n## git使用\n\n### 安装\n在控制台输入git 如果弹出提示信息，则跳过此步骤\n\n#### mac \n\n可以使用homebrew安装\n\n```\nbrew install git\n```\n\nhomebrew作为程序员mac的标配，如果你还没有安装，请键入：\n\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n也可以安装xcode，自带git\n\n#### windows\n\n到官网下载安装:\n[http://msysgit.github.com/](http://msysgit.github.com/)\n\n#### Linux\n\n```\nyum install git-core\n```\n\n或者：\n\n```\napt-get install git\n```\n\n### 配置\n在命令行输入：\n\n```\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"email@example.com\"\n```\n\n改配置用于识别代码提交者身份\n\n### 使用\n#### 代码提交\n\n```\ngit init   #创建代码版本库\ngit add .  #将当前目录下所有文件加入版本库\ngit commit -m \"message\"  #提交代码\n```\n\n```\ngit status #查看工作区状态\ngit diff #查看代码更改\ngit log  #查看提交日志\n```\n\n#### 版本回退\n\n```\ngit reflog #查看所有日志，包含head信息\ngit reset --hard HEAD^ 会退到上一版本\ngit reset --hard <commit_id> 会退到指定版本\n```\n\n撤销工作区修改：\t\n\n```\ngit checkout -- file\n```\n\n#### 远程仓库\n这里以github为例\n从远程仓库克隆代码:\n\n```\ngit clone https://github.com/username/projectname.git\n```\n\n如果想讲本地已有的代码推送到远程，则需要跟远程费分支建立连接\n与远程分支建立联系，需要remote origin\n\n```\ngit remote add origin https://github.com/username/projectname.git #添加远程分支\ngit push origin master #推送本地origin分支到master分支\n```\n如果提示有冲突，则需要先pull 下来，修改之后再push\n\n#### 分支管理\ngit中，一个分支为一个工作环境，分支与分支之间可以执行创建和合并操作。\n分支的一般使用：\n\n```\ngit branch # 查看分支\ngit branch <name>  # 创建分支\ngit checkout <name> # 切换分支\ngit checkout -b <name> # 创建并切换分支\ngit merge <name> #合并某分支到当前分支\ngit branch -d <name> # 删除分支 \ngit branch -D <name> # 强行删除分支\n```\n\n当更改同时发生在两个分支上，这时候我们有需要对两个分支进行合并，那解决冲突是很容易发生的状况这时候我们需要使用git status 查看状态，执行合并之后在当前分支解决合并冲突问题，在合并就可以了\n可以使用一下命令查看分支合并情况：\n\n```\ngit log --graph\n```\n\n#### 忽略别名\n在git中可以通过编辑.gitignore 文件达到控制忽略文件类型的目的，当文件自动不被add 到仓库里。\n忽略的语法规则：\n(#)表示注释\n(*)  表示任意多个字符; \n(?) 代表一个字符;\n ([abc]) 代表可选字符范围\n如果名称最前面是路径分隔符 (/) ，表示忽略的该文件在此目录下。\n如果名称的最后面是 (/) ，表示忽略整个目录，但同名文件不忽略。\n通过在名称前面加 (!) ，代表不忽略。\n例子如下：\n\n```\n# 这行是注释\n*.a   # 忽略所有 .a 伟扩展名的文件\n!lib.a   # 但是 lib.a 不忽略，即时之前设置了\t忽略所有的 .a\n/TODO   # 只忽略此目录下 TODO 文件，子目录的 TODO 不忽略 \nbuild/    # 忽略所有的 build/ 目录下文件\ndoc/*.txt    # 忽略如 doc/notes.txt, 但是不忽略如 doc/server/arch.txt\n```\n\n关于不同编程语言，通常会有统一的忽略规则，大家可以在这里直接找到配置模板：\n[https://github.com/github/gitignore](https://github.com/github/gitignore)\n#### 快捷命令配置\n在git里可以使用\n\n```\ngit config --global alias.<shortname> <command_name>\n```\n\n的方式指定快捷命令，\n以下为一些常用的快捷命令设置\n\n```\ngit config --global alias.st status\ngit config --global alias.co checkout\ngit config --global alias.ci commit\ngit config --global alias.br branch\ngit config --global alias.unstage 'reset HEAD'\ngit config --global alias.last 'log -1'\ngit config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit\"\n```\n\n\nok ,that's all\n","source":"_posts/程序员入门之git.md","raw":"---\ntitle: 程序员入门之git\ndate: 2016-05-29 10:49:08\ncategories: worker\ntags: 工具\n\n---\n# 代码版本管理工具\n在生产环境下的开发过程中，一个工程的代码通常是有多个程序员协同完成，这就涉及到代码在不通终端的同步问题，基于此需求，我们产生了代码版本工具，目前比较主流的两种为git和SVN\n<!-- more -->\n## git 与 SVN\n关于git和SVN的区别，网上有很多，根据笔者使用的经验，感觉git还是要比SVN先进一些，首先git是一个分布式版本管理系统，SVN更像是一个储存代码的仓库，管理员可以给不同的代码提交者提供不同的权限，仅此而已。git于SVN相比明显的优势在于不依赖网络，对分支管理有更好的支持，命令行简介好用（SVN也有命令行工具，但很多公司还是采用图形化界面）\n\n## git介绍\ngit是Linux的创始人Linus于2005年花了大概两周时间用C语言编写的分布式版本控制系统。\n\n## git使用\n\n### 安装\n在控制台输入git 如果弹出提示信息，则跳过此步骤\n\n#### mac \n\n可以使用homebrew安装\n\n```\nbrew install git\n```\n\nhomebrew作为程序员mac的标配，如果你还没有安装，请键入：\n\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n也可以安装xcode，自带git\n\n#### windows\n\n到官网下载安装:\n[http://msysgit.github.com/](http://msysgit.github.com/)\n\n#### Linux\n\n```\nyum install git-core\n```\n\n或者：\n\n```\napt-get install git\n```\n\n### 配置\n在命令行输入：\n\n```\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"email@example.com\"\n```\n\n改配置用于识别代码提交者身份\n\n### 使用\n#### 代码提交\n\n```\ngit init   #创建代码版本库\ngit add .  #将当前目录下所有文件加入版本库\ngit commit -m \"message\"  #提交代码\n```\n\n```\ngit status #查看工作区状态\ngit diff #查看代码更改\ngit log  #查看提交日志\n```\n\n#### 版本回退\n\n```\ngit reflog #查看所有日志，包含head信息\ngit reset --hard HEAD^ 会退到上一版本\ngit reset --hard <commit_id> 会退到指定版本\n```\n\n撤销工作区修改：\t\n\n```\ngit checkout -- file\n```\n\n#### 远程仓库\n这里以github为例\n从远程仓库克隆代码:\n\n```\ngit clone https://github.com/username/projectname.git\n```\n\n如果想讲本地已有的代码推送到远程，则需要跟远程费分支建立连接\n与远程分支建立联系，需要remote origin\n\n```\ngit remote add origin https://github.com/username/projectname.git #添加远程分支\ngit push origin master #推送本地origin分支到master分支\n```\n如果提示有冲突，则需要先pull 下来，修改之后再push\n\n#### 分支管理\ngit中，一个分支为一个工作环境，分支与分支之间可以执行创建和合并操作。\n分支的一般使用：\n\n```\ngit branch # 查看分支\ngit branch <name>  # 创建分支\ngit checkout <name> # 切换分支\ngit checkout -b <name> # 创建并切换分支\ngit merge <name> #合并某分支到当前分支\ngit branch -d <name> # 删除分支 \ngit branch -D <name> # 强行删除分支\n```\n\n当更改同时发生在两个分支上，这时候我们有需要对两个分支进行合并，那解决冲突是很容易发生的状况这时候我们需要使用git status 查看状态，执行合并之后在当前分支解决合并冲突问题，在合并就可以了\n可以使用一下命令查看分支合并情况：\n\n```\ngit log --graph\n```\n\n#### 忽略别名\n在git中可以通过编辑.gitignore 文件达到控制忽略文件类型的目的，当文件自动不被add 到仓库里。\n忽略的语法规则：\n(#)表示注释\n(*)  表示任意多个字符; \n(?) 代表一个字符;\n ([abc]) 代表可选字符范围\n如果名称最前面是路径分隔符 (/) ，表示忽略的该文件在此目录下。\n如果名称的最后面是 (/) ，表示忽略整个目录，但同名文件不忽略。\n通过在名称前面加 (!) ，代表不忽略。\n例子如下：\n\n```\n# 这行是注释\n*.a   # 忽略所有 .a 伟扩展名的文件\n!lib.a   # 但是 lib.a 不忽略，即时之前设置了\t忽略所有的 .a\n/TODO   # 只忽略此目录下 TODO 文件，子目录的 TODO 不忽略 \nbuild/    # 忽略所有的 build/ 目录下文件\ndoc/*.txt    # 忽略如 doc/notes.txt, 但是不忽略如 doc/server/arch.txt\n```\n\n关于不同编程语言，通常会有统一的忽略规则，大家可以在这里直接找到配置模板：\n[https://github.com/github/gitignore](https://github.com/github/gitignore)\n#### 快捷命令配置\n在git里可以使用\n\n```\ngit config --global alias.<shortname> <command_name>\n```\n\n的方式指定快捷命令，\n以下为一些常用的快捷命令设置\n\n```\ngit config --global alias.st status\ngit config --global alias.co checkout\ngit config --global alias.ci commit\ngit config --global alias.br branch\ngit config --global alias.unstage 'reset HEAD'\ngit config --global alias.last 'log -1'\ngit config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit\"\n```\n\n\nok ,that's all\n","slug":"程序员入门之git","published":1,"updated":"2016-06-28T11:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzgzekr001begfye1hleckf","content":"<h1 id=\"代码版本管理工具\"><a href=\"#代码版本管理工具\" class=\"headerlink\" title=\"代码版本管理工具\"></a>代码版本管理工具</h1><p>在生产环境下的开发过程中，一个工程的代码通常是有多个程序员协同完成，这就涉及到代码在不通终端的同步问题，基于此需求，我们产生了代码版本工具，目前比较主流的两种为git和SVN<br><a id=\"more\"></a></p>\n<h2 id=\"git-与-SVN\"><a href=\"#git-与-SVN\" class=\"headerlink\" title=\"git 与 SVN\"></a>git 与 SVN</h2><p>关于git和SVN的区别，网上有很多，根据笔者使用的经验，感觉git还是要比SVN先进一些，首先git是一个分布式版本管理系统，SVN更像是一个储存代码的仓库，管理员可以给不同的代码提交者提供不同的权限，仅此而已。git于SVN相比明显的优势在于不依赖网络，对分支管理有更好的支持，命令行简介好用（SVN也有命令行工具，但很多公司还是采用图形化界面）</p>\n<h2 id=\"git介绍\"><a href=\"#git介绍\" class=\"headerlink\" title=\"git介绍\"></a>git介绍</h2><p>git是Linux的创始人Linus于2005年花了大概两周时间用C语言编写的分布式版本控制系统。</p>\n<h2 id=\"git使用\"><a href=\"#git使用\" class=\"headerlink\" title=\"git使用\"></a>git使用</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>在控制台输入git 如果弹出提示信息，则跳过此步骤</p>\n<h4 id=\"mac\"><a href=\"#mac\" class=\"headerlink\" title=\"mac\"></a>mac</h4><p>可以使用homebrew安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install git</span><br></pre></td></tr></table></figure>\n<p>homebrew作为程序员mac的标配，如果你还没有安装，请键入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>\n<p>也可以安装xcode，自带git</p>\n<h4 id=\"windows\"><a href=\"#windows\" class=\"headerlink\" title=\"windows\"></a>windows</h4><p>到官网下载安装:<br><a href=\"http://msysgit.github.com/\" target=\"_blank\" rel=\"external\">http://msysgit.github.com/</a></p>\n<h4 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install git-core</span><br></pre></td></tr></table></figure>\n<p>或者：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install git</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>在命令行输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name &quot;Your Name&quot;</span><br><span class=\"line\">git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>\n<p>改配置用于识别代码提交者身份</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><h4 id=\"代码提交\"><a href=\"#代码提交\" class=\"headerlink\" title=\"代码提交\"></a>代码提交</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init   #创建代码版本库</span><br><span class=\"line\">git add .  #将当前目录下所有文件加入版本库</span><br><span class=\"line\">git commit -m &quot;message&quot;  #提交代码</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status #查看工作区状态</span><br><span class=\"line\">git diff #查看代码更改</span><br><span class=\"line\">git log  #查看提交日志</span><br></pre></td></tr></table></figure>\n<h4 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reflog #查看所有日志，包含head信息</span><br><span class=\"line\">git reset --hard HEAD^ 会退到上一版本</span><br><span class=\"line\">git reset --hard &lt;commit_id&gt; 会退到指定版本</span><br></pre></td></tr></table></figure>\n<p>撤销工作区修改：    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -- file</span><br></pre></td></tr></table></figure>\n<h4 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h4><p>这里以github为例<br>从远程仓库克隆代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/username/projectname.git</span><br></pre></td></tr></table></figure>\n<p>如果想讲本地已有的代码推送到远程，则需要跟远程费分支建立连接<br>与远程分支建立联系，需要remote origin</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin https://github.com/username/projectname.git #添加远程分支</span><br><span class=\"line\">git push origin master #推送本地origin分支到master分支</span><br></pre></td></tr></table></figure>\n<p>如果提示有冲突，则需要先pull 下来，修改之后再push</p>\n<h4 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h4><p>git中，一个分支为一个工作环境，分支与分支之间可以执行创建和合并操作。<br>分支的一般使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch # 查看分支</span><br><span class=\"line\">git branch &lt;name&gt;  # 创建分支</span><br><span class=\"line\">git checkout &lt;name&gt; # 切换分支</span><br><span class=\"line\">git checkout -b &lt;name&gt; # 创建并切换分支</span><br><span class=\"line\">git merge &lt;name&gt; #合并某分支到当前分支</span><br><span class=\"line\">git branch -d &lt;name&gt; # 删除分支 </span><br><span class=\"line\">git branch -D &lt;name&gt; # 强行删除分支</span><br></pre></td></tr></table></figure>\n<p>当更改同时发生在两个分支上，这时候我们有需要对两个分支进行合并，那解决冲突是很容易发生的状况这时候我们需要使用git status 查看状态，执行合并之后在当前分支解决合并冲突问题，在合并就可以了<br>可以使用一下命令查看分支合并情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --graph</span><br></pre></td></tr></table></figure>\n<h4 id=\"忽略别名\"><a href=\"#忽略别名\" class=\"headerlink\" title=\"忽略别名\"></a>忽略别名</h4><p>在git中可以通过编辑.gitignore 文件达到控制忽略文件类型的目的，当文件自动不被add 到仓库里。<br>忽略的语法规则：<br>(#)表示注释<br>(*)  表示任意多个字符;<br>(?) 代表一个字符;<br> ([abc]) 代表可选字符范围<br>如果名称最前面是路径分隔符 (/) ，表示忽略的该文件在此目录下。<br>如果名称的最后面是 (/) ，表示忽略整个目录，但同名文件不忽略。<br>通过在名称前面加 (!) ，代表不忽略。<br>例子如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 这行是注释</span><br><span class=\"line\">*.a   # 忽略所有 .a 伟扩展名的文件</span><br><span class=\"line\">!lib.a   # 但是 lib.a 不忽略，即时之前设置了\t忽略所有的 .a</span><br><span class=\"line\">/TODO   # 只忽略此目录下 TODO 文件，子目录的 TODO 不忽略 </span><br><span class=\"line\">build/    # 忽略所有的 build/ 目录下文件</span><br><span class=\"line\">doc/*.txt    # 忽略如 doc/notes.txt, 但是不忽略如 doc/server/arch.txt</span><br></pre></td></tr></table></figure>\n<p>关于不同编程语言，通常会有统一的忽略规则，大家可以在这里直接找到配置模板：<br><a href=\"https://github.com/github/gitignore\" target=\"_blank\" rel=\"external\">https://github.com/github/gitignore</a></p>\n<h4 id=\"快捷命令配置\"><a href=\"#快捷命令配置\" class=\"headerlink\" title=\"快捷命令配置\"></a>快捷命令配置</h4><p>在git里可以使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global alias.&lt;shortname&gt; &lt;command_name&gt;</span><br></pre></td></tr></table></figure>\n<p>的方式指定快捷命令，<br>以下为一些常用的快捷命令设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global alias.st status</span><br><span class=\"line\">git config --global alias.co checkout</span><br><span class=\"line\">git config --global alias.ci commit</span><br><span class=\"line\">git config --global alias.br branch</span><br><span class=\"line\">git config --global alias.unstage &apos;reset HEAD&apos;</span><br><span class=\"line\">git config --global alias.last &apos;log -1&apos;</span><br><span class=\"line\">git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</span><br></pre></td></tr></table></figure>\n<p>ok ,that’s all</p>\n","excerpt":"<h1 id=\"代码版本管理工具\"><a href=\"#代码版本管理工具\" class=\"headerlink\" title=\"代码版本管理工具\"></a>代码版本管理工具</h1><p>在生产环境下的开发过程中，一个工程的代码通常是有多个程序员协同完成，这就涉及到代码在不通终端的同步问题，基于此需求，我们产生了代码版本工具，目前比较主流的两种为git和SVN<br>","more":"</p>\n<h2 id=\"git-与-SVN\"><a href=\"#git-与-SVN\" class=\"headerlink\" title=\"git 与 SVN\"></a>git 与 SVN</h2><p>关于git和SVN的区别，网上有很多，根据笔者使用的经验，感觉git还是要比SVN先进一些，首先git是一个分布式版本管理系统，SVN更像是一个储存代码的仓库，管理员可以给不同的代码提交者提供不同的权限，仅此而已。git于SVN相比明显的优势在于不依赖网络，对分支管理有更好的支持，命令行简介好用（SVN也有命令行工具，但很多公司还是采用图形化界面）</p>\n<h2 id=\"git介绍\"><a href=\"#git介绍\" class=\"headerlink\" title=\"git介绍\"></a>git介绍</h2><p>git是Linux的创始人Linus于2005年花了大概两周时间用C语言编写的分布式版本控制系统。</p>\n<h2 id=\"git使用\"><a href=\"#git使用\" class=\"headerlink\" title=\"git使用\"></a>git使用</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>在控制台输入git 如果弹出提示信息，则跳过此步骤</p>\n<h4 id=\"mac\"><a href=\"#mac\" class=\"headerlink\" title=\"mac\"></a>mac</h4><p>可以使用homebrew安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install git</span><br></pre></td></tr></table></figure>\n<p>homebrew作为程序员mac的标配，如果你还没有安装，请键入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>\n<p>也可以安装xcode，自带git</p>\n<h4 id=\"windows\"><a href=\"#windows\" class=\"headerlink\" title=\"windows\"></a>windows</h4><p>到官网下载安装:<br><a href=\"http://msysgit.github.com/\">http://msysgit.github.com/</a></p>\n<h4 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install git-core</span><br></pre></td></tr></table></figure>\n<p>或者：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install git</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>在命令行输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name &quot;Your Name&quot;</span><br><span class=\"line\">git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>\n<p>改配置用于识别代码提交者身份</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><h4 id=\"代码提交\"><a href=\"#代码提交\" class=\"headerlink\" title=\"代码提交\"></a>代码提交</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init   #创建代码版本库</span><br><span class=\"line\">git add .  #将当前目录下所有文件加入版本库</span><br><span class=\"line\">git commit -m &quot;message&quot;  #提交代码</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status #查看工作区状态</span><br><span class=\"line\">git diff #查看代码更改</span><br><span class=\"line\">git log  #查看提交日志</span><br></pre></td></tr></table></figure>\n<h4 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reflog #查看所有日志，包含head信息</span><br><span class=\"line\">git reset --hard HEAD^ 会退到上一版本</span><br><span class=\"line\">git reset --hard &lt;commit_id&gt; 会退到指定版本</span><br></pre></td></tr></table></figure>\n<p>撤销工作区修改：    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -- file</span><br></pre></td></tr></table></figure>\n<h4 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h4><p>这里以github为例<br>从远程仓库克隆代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/username/projectname.git</span><br></pre></td></tr></table></figure>\n<p>如果想讲本地已有的代码推送到远程，则需要跟远程费分支建立连接<br>与远程分支建立联系，需要remote origin</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin https://github.com/username/projectname.git #添加远程分支</span><br><span class=\"line\">git push origin master #推送本地origin分支到master分支</span><br></pre></td></tr></table></figure>\n<p>如果提示有冲突，则需要先pull 下来，修改之后再push</p>\n<h4 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h4><p>git中，一个分支为一个工作环境，分支与分支之间可以执行创建和合并操作。<br>分支的一般使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch # 查看分支</span><br><span class=\"line\">git branch &lt;name&gt;  # 创建分支</span><br><span class=\"line\">git checkout &lt;name&gt; # 切换分支</span><br><span class=\"line\">git checkout -b &lt;name&gt; # 创建并切换分支</span><br><span class=\"line\">git merge &lt;name&gt; #合并某分支到当前分支</span><br><span class=\"line\">git branch -d &lt;name&gt; # 删除分支 </span><br><span class=\"line\">git branch -D &lt;name&gt; # 强行删除分支</span><br></pre></td></tr></table></figure>\n<p>当更改同时发生在两个分支上，这时候我们有需要对两个分支进行合并，那解决冲突是很容易发生的状况这时候我们需要使用git status 查看状态，执行合并之后在当前分支解决合并冲突问题，在合并就可以了<br>可以使用一下命令查看分支合并情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --graph</span><br></pre></td></tr></table></figure>\n<h4 id=\"忽略别名\"><a href=\"#忽略别名\" class=\"headerlink\" title=\"忽略别名\"></a>忽略别名</h4><p>在git中可以通过编辑.gitignore 文件达到控制忽略文件类型的目的，当文件自动不被add 到仓库里。<br>忽略的语法规则：<br>(#)表示注释<br>(*)  表示任意多个字符;<br>(?) 代表一个字符;<br> ([abc]) 代表可选字符范围<br>如果名称最前面是路径分隔符 (/) ，表示忽略的该文件在此目录下。<br>如果名称的最后面是 (/) ，表示忽略整个目录，但同名文件不忽略。<br>通过在名称前面加 (!) ，代表不忽略。<br>例子如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 这行是注释</span><br><span class=\"line\">*.a   # 忽略所有 .a 伟扩展名的文件</span><br><span class=\"line\">!lib.a   # 但是 lib.a 不忽略，即时之前设置了\t忽略所有的 .a</span><br><span class=\"line\">/TODO   # 只忽略此目录下 TODO 文件，子目录的 TODO 不忽略 </span><br><span class=\"line\">build/    # 忽略所有的 build/ 目录下文件</span><br><span class=\"line\">doc/*.txt    # 忽略如 doc/notes.txt, 但是不忽略如 doc/server/arch.txt</span><br></pre></td></tr></table></figure>\n<p>关于不同编程语言，通常会有统一的忽略规则，大家可以在这里直接找到配置模板：<br><a href=\"https://github.com/github/gitignore\">https://github.com/github/gitignore</a></p>\n<h4 id=\"快捷命令配置\"><a href=\"#快捷命令配置\" class=\"headerlink\" title=\"快捷命令配置\"></a>快捷命令配置</h4><p>在git里可以使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global alias.&lt;shortname&gt; &lt;command_name&gt;</span><br></pre></td></tr></table></figure>\n<p>的方式指定快捷命令，<br>以下为一些常用的快捷命令设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global alias.st status</span><br><span class=\"line\">git config --global alias.co checkout</span><br><span class=\"line\">git config --global alias.ci commit</span><br><span class=\"line\">git config --global alias.br branch</span><br><span class=\"line\">git config --global alias.unstage &apos;reset HEAD&apos;</span><br><span class=\"line\">git config --global alias.last &apos;log -1&apos;</span><br><span class=\"line\">git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</span><br></pre></td></tr></table></figure>\n<p>ok ,that’s all</p>"},{"title":"程序员工具（mac）","date":"2016-03-24T14:26:14.000Z","_content":"# mac下有关的程序员工具\n\n## item2\n\n代替苹果自带的终端，好看，而且功能更丰富。\n\n下载地址：[https://www.iterm2.com/](https://www.iterm2.com/)\n\n## Oh-My-Zsh\n\n一款功能更加强大的shell。\n<!-- more -->\n自动安装：\n``` python\nwget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh\n```\n手动安装：\n``` python\ngit clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh\ncp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\n```\n","source":"_posts/程序员工具（mac）.md","raw":"---\ntitle: 程序员工具（mac）\ndate: 2016-03-24 22:26:14\ncategories: worker\ntags: \n\t工具\n---\n# mac下有关的程序员工具\n\n## item2\n\n代替苹果自带的终端，好看，而且功能更丰富。\n\n下载地址：[https://www.iterm2.com/](https://www.iterm2.com/)\n\n## Oh-My-Zsh\n\n一款功能更加强大的shell。\n<!-- more -->\n自动安装：\n``` python\nwget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh\n```\n手动安装：\n``` python\ngit clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh\ncp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\n```\n","slug":"程序员工具（mac）","published":1,"updated":"2016-06-28T11:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzgzekv001gegfyq6lig8cf","content":"<h1 id=\"mac下有关的程序员工具\"><a href=\"#mac下有关的程序员工具\" class=\"headerlink\" title=\"mac下有关的程序员工具\"></a>mac下有关的程序员工具</h1><h2 id=\"item2\"><a href=\"#item2\" class=\"headerlink\" title=\"item2\"></a>item2</h2><p>代替苹果自带的终端，好看，而且功能更丰富。</p>\n<p>下载地址：<a href=\"https://www.iterm2.com/\" target=\"_blank\" rel=\"external\">https://www.iterm2.com/</a></p>\n<h2 id=\"Oh-My-Zsh\"><a href=\"#Oh-My-Zsh\" class=\"headerlink\" title=\"Oh-My-Zsh\"></a>Oh-My-Zsh</h2><p>一款功能更加强大的shell。<br><a id=\"more\"></a><br>自动安装：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br></pre></td></tr></table></figure></p>\n<p>手动安装：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class=\"line\">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure></p>\n","excerpt":"<h1 id=\"mac下有关的程序员工具\"><a href=\"#mac下有关的程序员工具\" class=\"headerlink\" title=\"mac下有关的程序员工具\"></a>mac下有关的程序员工具</h1><h2 id=\"item2\"><a href=\"#item2\" class=\"headerlink\" title=\"item2\"></a>item2</h2><p>代替苹果自带的终端，好看，而且功能更丰富。</p>\n<p>下载地址：<a href=\"https://www.iterm2.com/\">https://www.iterm2.com/</a></p>\n<h2 id=\"Oh-My-Zsh\"><a href=\"#Oh-My-Zsh\" class=\"headerlink\" title=\"Oh-My-Zsh\"></a>Oh-My-Zsh</h2><p>一款功能更加强大的shell。<br>","more":"<br>自动安装：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br></pre></td></tr></table></figure></p>\n<p>手动安装：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class=\"line\">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure></p>"},{"title":"程序员工具（windows）","date":"2016-03-24T13:31:48.000Z","_content":"# windows下好用的程序员工具\n\n## Lanuchy\n\n代替mac的Spotlight，虽然功能没有Spotlight完善，但还是非常好用，比如可以执行kill命令结束掉进程，可以快捷运行应用程序，还可以做简单的计算器使用。\n\n## everything\n作为一款开源的强大的windows文件查询软件，它将系统中所有文件名保存成一个字典，可以迅速查询系统内文件，比windows自带的搜索功能不知道好用多少倍。 \n<!-- more -->\n## InternetDownloadManager\n面对迅雷日益臃肿，浏览器自带下载功能残废的今天，你需要一款轻巧，支持断点续传的下载器，IDM是不二人选。\n\n## 关于数据库\n`navicat premium`\n可以支持多种数据库：MySQL、MariaDB、SQL Server、SQLite、Oracle 和 PostgreSQL ，功能强大，操作便捷。\n\n### 关于浏览器\n`firefox`\n开发者工具很好看，可以换肤，恩，插件还可以。\n\n`chrom`\n毫无疑问是因为Chrome的网上应用商店，还有他的断点调试功能比较方便，但个人觉得它的开发者工具没有火狐好用。\n\n## SUblimen Text 3 \n之所以把Sublime作为一款软件来说是因为他是windows下兼顾GUI和性能比较理想的一款文本编辑器，windows自带的记事本和Word会在文件头加BOOM标记所以不推荐在写代码时使用，最理想的还是Sublime。\n下面附上Sublime的一些常见设置：\n\n``` python\n{\n\t\"bold_folder_labels\": true,\n\t\"color_scheme\": \"Packages/User/Monokai (SublimePythonIDE).tmTheme\",\n\t\"create_window_at_startup\": false,\n\t\"default_encoding\": \"UTF-8\",\n\t\"ensure_newline_at_eof_on_save\": true,\n\t\"font_size\": 10,\n\t\"highlight_modified_tabs\": true,\n\t\"hot_exit\": true,\n\t\"ignored_packages\":\n\t[\n\t\t\"Vintage\"\n\t],\n\t\"open_files_in_new_window\": false,\n\t\"remember_full_screen\": true,\n\t\"remember_open_files\": true,\n\t\"tab_size\": 4,\n\t\"translate_tabs_to_spaces\": true,\n\t\"trim_trailing_white_space_on_save\": true\n}\n\n```\n= = 都是英文相信你应该看得懂，我就不写注释了。\n\n\t如果看不懂。。出门左转下个[有道词典](http://cidian.youdao.com/multi.html)吧。","source":"_posts/程序员工具（windows）.md","raw":"---\ntitle: 程序员工具（windows）\ndate: 2016-03-24 21:31:48\ncategories: worker\ntags: \n\t工具\n---\n# windows下好用的程序员工具\n\n## Lanuchy\n\n代替mac的Spotlight，虽然功能没有Spotlight完善，但还是非常好用，比如可以执行kill命令结束掉进程，可以快捷运行应用程序，还可以做简单的计算器使用。\n\n## everything\n作为一款开源的强大的windows文件查询软件，它将系统中所有文件名保存成一个字典，可以迅速查询系统内文件，比windows自带的搜索功能不知道好用多少倍。 \n<!-- more -->\n## InternetDownloadManager\n面对迅雷日益臃肿，浏览器自带下载功能残废的今天，你需要一款轻巧，支持断点续传的下载器，IDM是不二人选。\n\n## 关于数据库\n`navicat premium`\n可以支持多种数据库：MySQL、MariaDB、SQL Server、SQLite、Oracle 和 PostgreSQL ，功能强大，操作便捷。\n\n### 关于浏览器\n`firefox`\n开发者工具很好看，可以换肤，恩，插件还可以。\n\n`chrom`\n毫无疑问是因为Chrome的网上应用商店，还有他的断点调试功能比较方便，但个人觉得它的开发者工具没有火狐好用。\n\n## SUblimen Text 3 \n之所以把Sublime作为一款软件来说是因为他是windows下兼顾GUI和性能比较理想的一款文本编辑器，windows自带的记事本和Word会在文件头加BOOM标记所以不推荐在写代码时使用，最理想的还是Sublime。\n下面附上Sublime的一些常见设置：\n\n``` python\n{\n\t\"bold_folder_labels\": true,\n\t\"color_scheme\": \"Packages/User/Monokai (SublimePythonIDE).tmTheme\",\n\t\"create_window_at_startup\": false,\n\t\"default_encoding\": \"UTF-8\",\n\t\"ensure_newline_at_eof_on_save\": true,\n\t\"font_size\": 10,\n\t\"highlight_modified_tabs\": true,\n\t\"hot_exit\": true,\n\t\"ignored_packages\":\n\t[\n\t\t\"Vintage\"\n\t],\n\t\"open_files_in_new_window\": false,\n\t\"remember_full_screen\": true,\n\t\"remember_open_files\": true,\n\t\"tab_size\": 4,\n\t\"translate_tabs_to_spaces\": true,\n\t\"trim_trailing_white_space_on_save\": true\n}\n\n```\n= = 都是英文相信你应该看得懂，我就不写注释了。\n\n\t如果看不懂。。出门左转下个[有道词典](http://cidian.youdao.com/multi.html)吧。","slug":"程序员工具（windows）","published":1,"updated":"2016-06-28T11:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzgzekw001hegfylnxrf7rl","content":"<h1 id=\"windows下好用的程序员工具\"><a href=\"#windows下好用的程序员工具\" class=\"headerlink\" title=\"windows下好用的程序员工具\"></a>windows下好用的程序员工具</h1><h2 id=\"Lanuchy\"><a href=\"#Lanuchy\" class=\"headerlink\" title=\"Lanuchy\"></a>Lanuchy</h2><p>代替mac的Spotlight，虽然功能没有Spotlight完善，但还是非常好用，比如可以执行kill命令结束掉进程，可以快捷运行应用程序，还可以做简单的计算器使用。</p>\n<h2 id=\"everything\"><a href=\"#everything\" class=\"headerlink\" title=\"everything\"></a>everything</h2><p>作为一款开源的强大的windows文件查询软件，它将系统中所有文件名保存成一个字典，可以迅速查询系统内文件，比windows自带的搜索功能不知道好用多少倍。<br><a id=\"more\"></a></p>\n<h2 id=\"InternetDownloadManager\"><a href=\"#InternetDownloadManager\" class=\"headerlink\" title=\"InternetDownloadManager\"></a>InternetDownloadManager</h2><p>面对迅雷日益臃肿，浏览器自带下载功能残废的今天，你需要一款轻巧，支持断点续传的下载器，IDM是不二人选。</p>\n<h2 id=\"关于数据库\"><a href=\"#关于数据库\" class=\"headerlink\" title=\"关于数据库\"></a>关于数据库</h2><p><code>navicat premium</code><br>可以支持多种数据库：MySQL、MariaDB、SQL Server、SQLite、Oracle 和 PostgreSQL ，功能强大，操作便捷。</p>\n<h3 id=\"关于浏览器\"><a href=\"#关于浏览器\" class=\"headerlink\" title=\"关于浏览器\"></a>关于浏览器</h3><p><code>firefox</code><br>开发者工具很好看，可以换肤，恩，插件还可以。</p>\n<p><code>chrom</code><br>毫无疑问是因为Chrome的网上应用商店，还有他的断点调试功能比较方便，但个人觉得它的开发者工具没有火狐好用。</p>\n<h2 id=\"SUblimen-Text-3\"><a href=\"#SUblimen-Text-3\" class=\"headerlink\" title=\"SUblimen Text 3\"></a>SUblimen Text 3</h2><p>之所以把Sublime作为一款软件来说是因为他是windows下兼顾GUI和性能比较理想的一款文本编辑器，windows自带的记事本和Word会在文件头加BOOM标记所以不推荐在写代码时使用，最理想的还是Sublime。<br>下面附上Sublime的一些常见设置：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"string\">\"bold_folder_labels\"</span>: true,</span><br><span class=\"line\">\t<span class=\"string\">\"color_scheme\"</span>: <span class=\"string\">\"Packages/User/Monokai (SublimePythonIDE).tmTheme\"</span>,</span><br><span class=\"line\">\t<span class=\"string\">\"create_window_at_startup\"</span>: false,</span><br><span class=\"line\">\t<span class=\"string\">\"default_encoding\"</span>: <span class=\"string\">\"UTF-8\"</span>,</span><br><span class=\"line\">\t<span class=\"string\">\"ensure_newline_at_eof_on_save\"</span>: true,</span><br><span class=\"line\">\t<span class=\"string\">\"font_size\"</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">\t<span class=\"string\">\"highlight_modified_tabs\"</span>: true,</span><br><span class=\"line\">\t<span class=\"string\">\"hot_exit\"</span>: true,</span><br><span class=\"line\">\t<span class=\"string\">\"ignored_packages\"</span>:</span><br><span class=\"line\">\t[</span><br><span class=\"line\">\t\t<span class=\"string\">\"Vintage\"</span></span><br><span class=\"line\">\t],</span><br><span class=\"line\">\t<span class=\"string\">\"open_files_in_new_window\"</span>: false,</span><br><span class=\"line\">\t<span class=\"string\">\"remember_full_screen\"</span>: true,</span><br><span class=\"line\">\t<span class=\"string\">\"remember_open_files\"</span>: true,</span><br><span class=\"line\">\t<span class=\"string\">\"tab_size\"</span>: <span class=\"number\">4</span>,</span><br><span class=\"line\">\t<span class=\"string\">\"translate_tabs_to_spaces\"</span>: true,</span><br><span class=\"line\">\t<span class=\"string\">\"trim_trailing_white_space_on_save\"</span>: true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>= = 都是英文相信你应该看得懂，我就不写注释了。</p>\n<pre><code>如果看不懂。。出门左转下个[有道词典](http://cidian.youdao.com/multi.html)吧。\n</code></pre>","excerpt":"<h1 id=\"windows下好用的程序员工具\"><a href=\"#windows下好用的程序员工具\" class=\"headerlink\" title=\"windows下好用的程序员工具\"></a>windows下好用的程序员工具</h1><h2 id=\"Lanuchy\"><a href=\"#Lanuchy\" class=\"headerlink\" title=\"Lanuchy\"></a>Lanuchy</h2><p>代替mac的Spotlight，虽然功能没有Spotlight完善，但还是非常好用，比如可以执行kill命令结束掉进程，可以快捷运行应用程序，还可以做简单的计算器使用。</p>\n<h2 id=\"everything\"><a href=\"#everything\" class=\"headerlink\" title=\"everything\"></a>everything</h2><p>作为一款开源的强大的windows文件查询软件，它将系统中所有文件名保存成一个字典，可以迅速查询系统内文件，比windows自带的搜索功能不知道好用多少倍。<br>","more":"</p>\n<h2 id=\"InternetDownloadManager\"><a href=\"#InternetDownloadManager\" class=\"headerlink\" title=\"InternetDownloadManager\"></a>InternetDownloadManager</h2><p>面对迅雷日益臃肿，浏览器自带下载功能残废的今天，你需要一款轻巧，支持断点续传的下载器，IDM是不二人选。</p>\n<h2 id=\"关于数据库\"><a href=\"#关于数据库\" class=\"headerlink\" title=\"关于数据库\"></a>关于数据库</h2><p><code>navicat premium</code><br>可以支持多种数据库：MySQL、MariaDB、SQL Server、SQLite、Oracle 和 PostgreSQL ，功能强大，操作便捷。</p>\n<h3 id=\"关于浏览器\"><a href=\"#关于浏览器\" class=\"headerlink\" title=\"关于浏览器\"></a>关于浏览器</h3><p><code>firefox</code><br>开发者工具很好看，可以换肤，恩，插件还可以。</p>\n<p><code>chrom</code><br>毫无疑问是因为Chrome的网上应用商店，还有他的断点调试功能比较方便，但个人觉得它的开发者工具没有火狐好用。</p>\n<h2 id=\"SUblimen-Text-3\"><a href=\"#SUblimen-Text-3\" class=\"headerlink\" title=\"SUblimen Text 3\"></a>SUblimen Text 3</h2><p>之所以把Sublime作为一款软件来说是因为他是windows下兼顾GUI和性能比较理想的一款文本编辑器，windows自带的记事本和Word会在文件头加BOOM标记所以不推荐在写代码时使用，最理想的还是Sublime。<br>下面附上Sublime的一些常见设置：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"string\">\"bold_folder_labels\"</span>: true,</span><br><span class=\"line\">\t<span class=\"string\">\"color_scheme\"</span>: <span class=\"string\">\"Packages/User/Monokai (SublimePythonIDE).tmTheme\"</span>,</span><br><span class=\"line\">\t<span class=\"string\">\"create_window_at_startup\"</span>: false,</span><br><span class=\"line\">\t<span class=\"string\">\"default_encoding\"</span>: <span class=\"string\">\"UTF-8\"</span>,</span><br><span class=\"line\">\t<span class=\"string\">\"ensure_newline_at_eof_on_save\"</span>: true,</span><br><span class=\"line\">\t<span class=\"string\">\"font_size\"</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">\t<span class=\"string\">\"highlight_modified_tabs\"</span>: true,</span><br><span class=\"line\">\t<span class=\"string\">\"hot_exit\"</span>: true,</span><br><span class=\"line\">\t<span class=\"string\">\"ignored_packages\"</span>:</span><br><span class=\"line\">\t[</span><br><span class=\"line\">\t\t<span class=\"string\">\"Vintage\"</span></span><br><span class=\"line\">\t],</span><br><span class=\"line\">\t<span class=\"string\">\"open_files_in_new_window\"</span>: false,</span><br><span class=\"line\">\t<span class=\"string\">\"remember_full_screen\"</span>: true,</span><br><span class=\"line\">\t<span class=\"string\">\"remember_open_files\"</span>: true,</span><br><span class=\"line\">\t<span class=\"string\">\"tab_size\"</span>: <span class=\"number\">4</span>,</span><br><span class=\"line\">\t<span class=\"string\">\"translate_tabs_to_spaces\"</span>: true,</span><br><span class=\"line\">\t<span class=\"string\">\"trim_trailing_white_space_on_save\"</span>: true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>= = 都是英文相信你应该看得懂，我就不写注释了。</p>\n<pre><code>如果看不懂。。出门左转下个[有道词典](http://cidian.youdao.com/multi.html)吧。\n</code></pre>"}],"PostAsset":[],"PostCategory":[{"post_id":"cipzgzejq0000egfypsq7c5j7","category_id":"cipzgzejz0005egfyjf3z46uo","_id":"cipzgzek8000degfyhnjjxclb"},{"post_id":"cipzgzek20009egfytyab4iq8","category_id":"cipzgzejz0005egfyjf3z46uo","_id":"cipzgzeka000hegfy2h2wbxq8"},{"post_id":"cipzgzejv0002egfyjykery5x","category_id":"cipzgzek3000aegfyvsgqtjuv","_id":"cipzgzekd000kegfyydz7q1r4"},{"post_id":"cipzgzejz0006egfyqdzj1whc","category_id":"cipzgzek9000gegfybinnrdrz","_id":"cipzgzekg000pegfyz5y9299c"},{"post_id":"cipzgzek10007egfynihe2tkp","category_id":"cipzgzekd000megfysy7we4xx","_id":"cipzgzekl000wegfyfxj85p17"},{"post_id":"cipzgzekf000oegfymwnxv9si","category_id":"cipzgzek9000gegfybinnrdrz","_id":"cipzgzekn0011egfy2irnjy67"},{"post_id":"cipzgzek4000cegfyd1fnwn28","category_id":"cipzgzekg000regfyczas022t","_id":"cipzgzeko0013egfypj502496"},{"post_id":"cipzgzekn0012egfy4peosndw","category_id":"cipzgzek3000aegfyvsgqtjuv","_id":"cipzgzekr001aegfyyf60kuns"},{"post_id":"cipzgzekb000iegfyaedyb7te","category_id":"cipzgzekn000zegfyr1d5ie15","_id":"cipzgzeku001fegfy5i6i6bpc"},{"post_id":"cipzgzekc000jegfyy3zhoq37","category_id":"cipzgzekn000zegfyr1d5ie15","_id":"cipzgzekx001iegfylp4w739x"},{"post_id":"cipzgzeke000negfylt2axq3k","category_id":"cipzgzekn000zegfyr1d5ie15","_id":"cipzgzeky001megfy0b048geb"},{"post_id":"cipzgzekh000segfyzicnbl5q","category_id":"cipzgzekx001jegfyd236u397","_id":"cipzgzekz001qegfy0vpl5mv9"},{"post_id":"cipzgzekm000yegfy0yfk3n3h","category_id":"cipzgzeky001oegfy6ngpdol6","_id":"cipzgzel0001uegfy6pptu766"},{"post_id":"cipzgzeko0014egfy1itdd1ui","category_id":"cipzgzekz001regfy59n14okg","_id":"cipzgzel1001yegfycc78stu7"},{"post_id":"cipzgzekq0018egfy4dr8u0lz","category_id":"cipzgzekz001regfy59n14okg","_id":"cipzgzel30022egfy95r2gx3e"},{"post_id":"cipzgzekr001begfye1hleckf","category_id":"cipzgzel1001zegfyge4dyeti","_id":"cipzgzel50026egfyh31fl23i"},{"post_id":"cipzgzekv001gegfyq6lig8cf","category_id":"cipzgzel1001zegfyge4dyeti","_id":"cipzgzel5002aegfyczk0o3jo"},{"post_id":"cipzgzekw001hegfylnxrf7rl","category_id":"cipzgzel1001zegfyge4dyeti","_id":"cipzgzel6002degfy8pszkvn0"}],"PostTag":[{"post_id":"cipzgzejq0000egfypsq7c5j7","tag_id":"cipzgzejx0004egfy3izwsd0w","_id":"cipzgzek4000begfynmyfqobz"},{"post_id":"cipzgzejv0002egfyjykery5x","tag_id":"cipzgzek20008egfy6b74jxpm","_id":"cipzgzeki000tegfykfl1avh0"},{"post_id":"cipzgzejv0002egfyjykery5x","tag_id":"cipzgzek9000fegfyaj4hgvum","_id":"cipzgzekl000vegfywvi1w1u7"},{"post_id":"cipzgzejv0002egfyjykery5x","tag_id":"cipzgzekd000legfy9fgyu8bu","_id":"cipzgzekn0010egfy9hyc658x"},{"post_id":"cipzgzekn0012egfy4peosndw","tag_id":"cipzgzekd000legfy9fgyu8bu","_id":"cipzgzekp0017egfys4hmul2h"},{"post_id":"cipzgzejz0006egfyqdzj1whc","tag_id":"cipzgzekg000qegfypxga1hai","_id":"cipzgzekr0019egfygxlzycma"},{"post_id":"cipzgzejz0006egfyqdzj1whc","tag_id":"cipzgzekl000xegfyiv8mg9bs","_id":"cipzgzeku001eegfyrqzbv7wz"},{"post_id":"cipzgzek10007egfynihe2tkp","tag_id":"cipzgzekp0015egfyhphwqkik","_id":"cipzgzeky001legfy8ee8zdqd"},{"post_id":"cipzgzek10007egfynihe2tkp","tag_id":"cipzgzeku001degfyawmte9pi","_id":"cipzgzeky001negfyl55103yg"},{"post_id":"cipzgzek20009egfytyab4iq8","tag_id":"cipzgzekx001kegfy4kq5o5f8","_id":"cipzgzekz001tegfyjes4cm57"},{"post_id":"cipzgzek20009egfytyab4iq8","tag_id":"cipzgzekz001pegfywx4cj20g","_id":"cipzgzel0001vegfytre3gov5"},{"post_id":"cipzgzek4000cegfyd1fnwn28","tag_id":"cipzgzekz001segfy4mvbgprb","_id":"cipzgzel30021egfyh8swodtc"},{"post_id":"cipzgzek4000cegfyd1fnwn28","tag_id":"cipzgzel0001xegfyei1lj3k7","_id":"cipzgzel30024egfyd24pe8r6"},{"post_id":"cipzgzekb000iegfyaedyb7te","tag_id":"cipzgzel30020egfyhmw7uzyt","_id":"cipzgzel50029egfywwe3dfch"},{"post_id":"cipzgzekb000iegfyaedyb7te","tag_id":"cipzgzel40025egfyb1byqljw","_id":"cipzgzel5002begfyfpz50425"},{"post_id":"cipzgzekc000jegfyy3zhoq37","tag_id":"cipzgzel50028egfy2aougoht","_id":"cipzgzel6002fegfy0537rxsj"},{"post_id":"cipzgzekc000jegfyy3zhoq37","tag_id":"cipzgzel40025egfyb1byqljw","_id":"cipzgzel6002gegfyedaap39k"},{"post_id":"cipzgzeke000negfylt2axq3k","tag_id":"cipzgzel30020egfyhmw7uzyt","_id":"cipzgzel7002jegfycj9u4qv6"},{"post_id":"cipzgzeke000negfylt2axq3k","tag_id":"cipzgzel40025egfyb1byqljw","_id":"cipzgzel7002kegfy3iosfg74"},{"post_id":"cipzgzekf000oegfymwnxv9si","tag_id":"cipzgzekg000qegfypxga1hai","_id":"cipzgzel8002pegfyo2xz07vu"},{"post_id":"cipzgzekf000oegfymwnxv9si","tag_id":"cipzgzel7002legfynvu95rr2","_id":"cipzgzel8002qegfyohj3ugky"},{"post_id":"cipzgzekf000oegfymwnxv9si","tag_id":"cipzgzel7002megfy9xdyxu1o","_id":"cipzgzel8002segfylur69l4j"},{"post_id":"cipzgzekf000oegfymwnxv9si","tag_id":"cipzgzel8002negfykh203t2m","_id":"cipzgzel8002tegfyho5ra1by"},{"post_id":"cipzgzekh000segfyzicnbl5q","tag_id":"cipzgzek20008egfy6b74jxpm","_id":"cipzgzel8002vegfyw7gtcmhr"},{"post_id":"cipzgzekh000segfyzicnbl5q","tag_id":"cipzgzel40025egfyb1byqljw","_id":"cipzgzel9002wegfyyltkuodq"},{"post_id":"cipzgzekk000uegfy2rf93a0t","tag_id":"cipzgzel8002regfyn4tf6w6a","_id":"cipzgzel9002yegfyxrid1dqh"},{"post_id":"cipzgzekm000yegfy0yfk3n3h","tag_id":"cipzgzel40025egfyb1byqljw","_id":"cipzgzel9002zegfy6aebjdgb"},{"post_id":"cipzgzeko0014egfy1itdd1ui","tag_id":"cipzgzel9002xegfye2e54n74","_id":"cipzgzel90032egfyfao932c2"},{"post_id":"cipzgzeko0014egfy1itdd1ui","tag_id":"cipzgzel40025egfyb1byqljw","_id":"cipzgzel90033egfyzllfgp6d"},{"post_id":"cipzgzeko0014egfy1itdd1ui","tag_id":"cipzgzejx0004egfy3izwsd0w","_id":"cipzgzela0035egfytbd5dmwe"},{"post_id":"cipzgzekq0018egfy4dr8u0lz","tag_id":"cipzgzejx0004egfy3izwsd0w","_id":"cipzgzela0036egfyfe9t1yo3"},{"post_id":"cipzgzekq0018egfy4dr8u0lz","tag_id":"cipzgzel90031egfyl49eqy1l","_id":"cipzgzela0038egfy2hu9ynrx"},{"post_id":"cipzgzekr001begfye1hleckf","tag_id":"cipzgzel90034egfysphuyo95","_id":"cipzgzela0039egfy0ejoh3rb"},{"post_id":"cipzgzekv001gegfyq6lig8cf","tag_id":"cipzgzel90034egfysphuyo95","_id":"cipzgzela003begfynh2nqare"},{"post_id":"cipzgzekw001hegfylnxrf7rl","tag_id":"cipzgzel90034egfysphuyo95","_id":"cipzgzelb003cegfyctrg5pt2"}],"Tag":[{"name":"敏捷开发","_id":"cipzgzejx0004egfy3izwsd0w"},{"name":"爬虫","_id":"cipzgzek20008egfy6b74jxpm"},{"name":"web","_id":"cipzgzek9000fegfyaj4hgvum"},{"name":"HTTP","_id":"cipzgzekd000legfy9fgyu8bu"},{"name":"Nosql","_id":"cipzgzekg000qegfypxga1hai"},{"name":"RDBMS","_id":"cipzgzekl000xegfyiv8mg9bs"},{"name":"Linux","_id":"cipzgzekp0015egfyhphwqkik"},{"name":"Systemd","_id":"cipzgzeku001degfyawmte9pi"},{"name":"敏捷","_id":"cipzgzekx001kegfy4kq5o5f8"},{"name":"ThoughtWorks","_id":"cipzgzekz001pegfywx4cj20g"},{"name":"opration","_id":"cipzgzekz001segfy4mvbgprb"},{"name":"ansible","_id":"cipzgzel0001xegfyei1lj3k7"},{"name":"代码优化","_id":"cipzgzel30020egfyhmw7uzyt"},{"name":"python","_id":"cipzgzel40025egfyb1byqljw"},{"name":"编程思想","_id":"cipzgzel50028egfy2aougoht"},{"name":"redis","_id":"cipzgzel7002legfynvu95rr2"},{"name":"memcache","_id":"cipzgzel7002megfy9xdyxu1o"},{"name":"mongoDB","_id":"cipzgzel8002negfykh203t2m"},{"name":"thoughtworks","_id":"cipzgzel8002regfyn4tf6w6a"},{"name":"单元测试","_id":"cipzgzel9002xegfye2e54n74"},{"name":"thoughtworks面试","_id":"cipzgzel90031egfyl49eqy1l"},{"name":"工具","_id":"cipzgzel90034egfysphuyo95"}]}}